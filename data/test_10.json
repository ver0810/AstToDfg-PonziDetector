{"code":"contract ResetPonzi {\r\r\n    \r\r\n    struct Person {\r\r\n      address addr;\r\r\n    }\r\r\n    \r\r\n    struct NiceGuy {\r\r\n      address addr2;\r\r\n    }\r\r\n    \r\r\n    Person[] public persons;\r\r\n    NiceGuy[] public niceGuys;\r\r\n    \r\r\n    uint public payoutIdx = 0;\r\r\n    uint public currentNiceGuyIdx = 0;\r\r\n    uint public investor = 0;\r\r\n    \r\r\n    address public currentNiceGuy;\r\r\n    address public beta;\r\r\n    \r\r\n    function ResetPonzi() {\r\r\n        currentNiceGuy = msg.sender;\r\r\n        beta = msg.sender;\r\r\n    }\r\r\n    \r\r\n    \r\r\n    function() {\r\r\n        \r\r\n        if (msg.value != 9 ether) {\r\r\n            throw;\r\r\n        }\r\r\n        \r\r\n        if (investor > 8) {\r\r\n            uint ngidx = niceGuys.length;\r\r\n            niceGuys.length += 1;\r\r\n            niceGuys[ngidx].addr2 = msg.sender;\r\r\n            if (investor == 10) {\r\r\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\r\r\n                currentNiceGuyIdx += 1;\r\r\n            }\r\r\n        }\r\r\n        \r\r\n        if (investor < 9) {\r\r\n            uint idx = persons.length;\r\r\n            persons.length += 1;\r\r\n            persons[idx].addr = msg.sender;\r\r\n        }\r\r\n        \r\r\n        investor += 1;\r\r\n        if (investor == 11) {\r\r\n            investor = 0;\r\r\n        }\r\r\n        \r\r\n        currentNiceGuy.send(1 ether);\r\r\n        \r\r\n        while (this.balance >= 10 ether) {\r\r\n            persons[payoutIdx].addr.send(10 ether);\r\r\n            payoutIdx += 1;\r\r\n        }\r\r\n    }\r\r\n    \r\r\n    \r\r\n    function funnel() {\r\r\n        beta.send(this.balance);\r\r\n    }\r\r\n    \r\r\n    \r\r\n}","label":1}
{"code":"pragma solidity ^0.4.18;\r\r\n\/\/ THIS IS A REAL WORLD SIMULATION AS SOCIAL EXPERIMENT\r\r\n\/\/ By sending ETH to the smart contract, you&#39;re trusting \r\r\n\/\/ an uncaring mathematical gambling robot to entrust you with Tokens.\r\r\n\/\/ Every Time a Token is purchased, the contract increases the price \r\r\n\/\/ of the next token by a small percentage (about 0.25%). \r\r\n\/\/ Every time a Token is sold, the next Token is valued slightly less (about -0.25%).\r\r\n\/\/ At any time, you can sell your Tokens back to the Smart Contract\r\r\n\/\/ for 90% of the current price, or withdraw just the dividends \r\r\n\/\/ you&#39;ve accumulated!\r\r\n\/\/ This is a Simulation and kinda a Social Experiment \r\r\n\r\r\n\/\/ ------- DO NOT USE FUNDS YOU CAN&#39;T EFFORT TO LOSE -------\r\r\n\/\/ ------- THIS IS A PURE SIMULATION OF THE CAPABILITIES OF ETHEREUM CONTRACTS -------\r\r\n\r\r\n\/\/ If you want to WITHDRAW accumulated DIVIDENDS \r\r\n\/\/ 1. open MEW\/METAMASK\r\r\n\/\/ 2. Put this as data: 0x2e1a7d4d0000000000000000000000000000000000000000000000000000000000000000\r\r\n\/\/ 3. send 50.000+ gas\r\r\n\r\r\n\/\/ If you want to escape this contract REALLY FAST\r\r\n\/\/ 1. open MEW\/METAMASK\r\r\n\/\/ 2. Put this as data: 0xb1e35242\r\r\n\/\/ 3. send 150.000+ gas\r\r\n\/\/ That calls the getMeOutOfHere() method\r\r\n\r\r\ncontract ethpyramid {\r\r\n\tuint256 constant PRECISION = 0x10000000000000000;  \/\/ 2^64\r\r\n\t\/\/ CRR = 80 %\r\r\n\tint constant CRRN = 1;\r\r\n\tint constant CRRD = 2;\r\r\n\t\/\/ The price coefficient. Chosen such that at 1 token total supply\r\r\n\t\/\/ the reserve is 0.8 ether and price 1 ether\/token.\r\r\n\tint constant LOGC = -0x296ABF784A358468C;\r\r\n\t\r\r\n\tstring constant public name = \"EthPyramid\";\r\r\n\tstring constant public symbol = \"EPT\";\r\r\n\tuint8 constant public decimals = 18;\r\r\n\tuint256 public totalSupply;\r\r\n\t\/\/ amount of shares for each address (scaled number)\r\r\n\tmapping(address => uint256) public balanceOfOld;\r\r\n\t\/\/ allowance map, see erc20\r\r\n\tmapping(address => mapping(address => uint256)) public allowance;\r\r\n\t\/\/ amount payed out for each address (scaled number)\r\r\n\tmapping(address => int256) payouts;\r\r\n\t\/\/ sum of all payouts (scaled number)\r\r\n\tint256 totalPayouts;\r\r\n\t\/\/ amount earned for each share (scaled number)\r\r\n\tuint256 earningsPerShare;\r\r\n\t\r\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n\r\r\n\t\/\/address owner;\r\r\n\r\r\n\tfunction ethpyramid() public {\r\r\n\t\t\/\/owner = msg.sender;\r\r\n\t}\r\r\n\t\r\r\n\t\/\/ These are functions solely created to appease the frontend\r\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n        return balanceOfOld[_owner];\r\r\n    }\r\r\n\r\r\n\tfunction withdraw(uint tokenCount) \/\/ the parameter is ignored, yes\r\r\n      public\r\r\n      returns (bool)\r\r\n    {\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * PRECISION);\r\r\n\t\ttotalPayouts += (int256) (balance * PRECISION);\r\r\n\t\tmsg.sender.transfer(balance);\r\r\n\t\treturn true;\r\r\n    }\r\r\n\t\r\r\n\tfunction sellMyTokensDaddy() public {\r\r\n\t\tvar balance = balanceOf(msg.sender);\r\r\n\t\ttransferTokens(msg.sender, address(this),  balance); \/\/ this triggers the internal sell function\r\r\n\t}\r\r\n\r\r\n    function getMeOutOfHere() public {\r\r\n\t\tsellMyTokensDaddy();\r\r\n        withdraw(1); \/\/ parameter is ignored\r\r\n\t}\r\r\n\t\r\r\n\tfunction fund()\r\r\n      public\r\r\n      payable \r\r\n      returns (bool)\r\r\n    {\r\r\n      if (msg.value > 0.000001 ether)\r\r\n\t\t\tbuy();\r\r\n\t\telse\r\r\n\t\t\treturn false;\r\r\n\t  \r\r\n      return true;\r\r\n    }\r\r\n\r\r\n\tfunction buyPrice() public constant returns (uint) {\r\r\n\t\treturn getTokensForEther(1 finney);\r\r\n\t}\r\r\n\t\r\r\n\tfunction sellPrice() public constant returns (uint) {\r\r\n\t\treturn getEtherForTokens(1 finney);\r\r\n\t}\r\r\n\r\r\n\t\/\/ End of useless functions\r\r\n\r\r\n\t\/\/ Invariants\r\r\n\t\/\/ totalPayout\/Supply correct:\r\r\n\t\/\/   totalPayouts = \\sum_{addr:address} payouts(addr)\r\r\n\t\/\/   totalSupply  = \\sum_{addr:address} balanceOfOld(addr)\r\r\n\t\/\/ dividends not negative:\r\r\n\t\/\/   \\forall addr:address. payouts[addr] <= earningsPerShare * balanceOfOld[addr]\r\r\n\t\/\/ supply\/reserve correlation:\r\r\n\t\/\/   totalSupply ~= exp(LOGC + CRRN\/CRRD*log(reserve())\r\r\n\t\/\/   i.e. totalSupply = C * reserve()**CRR\r\r\n\t\/\/ reserve equals balance minus payouts\r\r\n\t\/\/   reserve() = this.balance - \\sum_{addr:address} dividends(addr)\r\r\n\r\r\n\tfunction transferTokens(address _from, address _to, uint256 _value) internal {\r\r\n\t\tif (balanceOfOld[_from] < _value)\r\r\n\t\t\trevert();\r\r\n\t\tif (_to == address(this)) {\r\r\n\t\t\tsell(_value);\r\r\n\t\t} else {\r\r\n\t\t    int256 payoutDiff = (int256) (earningsPerShare * _value);\r\r\n\t\t    balanceOfOld[_from] -= _value;\r\r\n\t\t    balanceOfOld[_to] += _value;\r\r\n\t\t    payouts[_from] -= payoutDiff;\r\r\n\t\t    payouts[_to] += payoutDiff;\r\r\n\t\t}\r\r\n\t\tTransfer(_from, _to, _value);\r\r\n\t}\r\r\n\t\r\r\n\tfunction transfer(address _to, uint256 _value) public {\r\r\n\t    transferTokens(msg.sender, _to,  _value);\r\r\n\t}\r\r\n\t\r\r\n    function transferFrom(address _from, address _to, uint256 _value) public {\r\r\n        var _allowance = allowance[_from][msg.sender];\r\r\n        if (_allowance < _value)\r\r\n            revert();\r\r\n        allowance[_from][msg.sender] = _allowance - _value;\r\r\n        transferTokens(_from, _to, _value);\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint256 _value) public {\r\r\n        \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n        \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n        \/\/  already 0 to mitigate the race condition described here:\r\r\n        \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();\r\r\n        allowance[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n    }\r\r\n\r\r\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\r\r\n\t\treturn (uint256) ((int256)(earningsPerShare * balanceOfOld[_owner]) - payouts[_owner]) \/ PRECISION;\r\r\n\t}\r\r\n\r\r\n\tfunction withdrawOld(address to) public {\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * PRECISION);\r\r\n\t\ttotalPayouts += (int256) (balance * PRECISION);\r\r\n\t\tto.transfer(balance);\r\r\n\t}\r\r\n\r\r\n\tfunction balance() internal constant returns (uint256 amount) {\r\r\n\t\treturn this.balance - msg.value;\r\r\n\t}\r\r\n\tfunction reserve() public constant returns (uint256 amount) {\r\r\n\t\treturn balance()\r\r\n\t\t\t- ((uint256) ((int256) (earningsPerShare * totalSupply) - totalPayouts) \/ PRECISION) - 1;\r\r\n\t}\r\r\n\r\r\n\tfunction buy() internal {\r\r\n\t\tif (msg.value < 0.000001 ether || msg.value > 1000000 ether)\r\r\n\t\t\trevert();\r\r\n\t\tvar sender = msg.sender;\r\r\n\t\t\/\/ 5 % of the amount is used to pay holders.\r\r\n\t\tvar fee = (uint)(msg.value \/ 10);\r\r\n\t\t\r\r\n\t\t\/\/ compute number of bought tokens\r\r\n\t\tvar numEther = msg.value - fee;\r\r\n\t\tvar numTokens = getTokensForEther(numEther);\r\r\n\r\r\n\t\tvar buyerfee = fee * PRECISION;\r\r\n\t\tif (totalSupply > 0) {\r\r\n\t\t\t\/\/ compute how the fee distributed to previous holders and buyer.\r\r\n\t\t\t\/\/ The buyer already gets a part of the fee as if he would buy each token separately.\r\r\n\t\t\tvar holderreward =\r\r\n\t\t\t    (PRECISION - (reserve() + numEther) * numTokens * PRECISION \/ (totalSupply + numTokens) \/ numEther)\r\r\n\t\t\t    * (uint)(CRRD) \/ (uint)(CRRD-CRRN);\r\r\n\t\t\tvar holderfee = fee * holderreward;\r\r\n\t\t\tbuyerfee -= holderfee;\r\r\n\t\t\r\r\n\t\t\t\/\/ Fee is distributed to all existing tokens before buying\r\r\n\t\t\tvar feePerShare = holderfee \/ totalSupply;\r\r\n\t\t\tearningsPerShare += feePerShare;\r\r\n\t\t}\r\r\n\t\t\/\/ add numTokens to total supply\r\r\n\t\ttotalSupply += numTokens;\r\r\n\t\t\/\/ add numTokens to balance\r\r\n\t\tbalanceOfOld[sender] += numTokens;\r\r\n\t\t\/\/ fix payouts so that sender doesn&#39;t get old earnings for the new tokens.\r\r\n\t\t\/\/ also add its buyerfee\r\r\n\t\tvar payoutDiff = (int256) ((earningsPerShare * numTokens) - buyerfee);\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\t\ttotalPayouts += payoutDiff;\r\r\n\t}\r\r\n\t\r\r\n\tfunction sell(uint256 amount) internal {\r\r\n\t\tvar numEthers = getEtherForTokens(amount);\r\r\n\t\t\/\/ remove tokens\r\r\n\t\ttotalSupply -= amount;\r\r\n\t\tbalanceOfOld[msg.sender] -= amount;\r\r\n\t\t\r\r\n\t\t\/\/ fix payouts and put the ethers in payout\r\r\n\t\tvar payoutDiff = (int256) (earningsPerShare * amount + (numEthers * PRECISION));\r\r\n\t\tpayouts[msg.sender] -= payoutDiff;\r\r\n\t\ttotalPayouts -= payoutDiff;\r\r\n\t}\r\r\n\r\r\n\tfunction getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {\r\r\n\t\treturn fixedExp(fixedLog(reserve() + ethervalue)*CRRN\/CRRD + LOGC) - totalSupply;\r\r\n\t}\r\r\n\r\r\n\tfunction getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {\r\r\n\t\tif (tokens == totalSupply)\r\r\n\t\t\treturn reserve();\r\r\n\t\treturn reserve() - fixedExp((fixedLog(totalSupply - tokens) - LOGC) * CRRD\/CRRN);\r\r\n\t}\r\r\n\r\r\n\tint256 constant one       = 0x10000000000000000;\r\r\n\tuint256 constant sqrt2    = 0x16a09e667f3bcc908;\r\r\n\tuint256 constant sqrtdot5 = 0x0b504f333f9de6484;\r\r\n\tint256 constant ln2       = 0x0b17217f7d1cf79ac;\r\r\n\tint256 constant ln2_64dot5= 0x2cb53f09f05cc627c8;\r\r\n\tint256 constant c1        = 0x1ffffffffff9dac9b;\r\r\n\tint256 constant c3        = 0x0aaaaaaac16877908;\r\r\n\tint256 constant c5        = 0x0666664e5e9fa0c99;\r\r\n\tint256 constant c7        = 0x049254026a7630acf;\r\r\n\tint256 constant c9        = 0x038bd75ed37753d68;\r\r\n\tint256 constant c11       = 0x03284a0c14610924f;\r\r\n\r\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\r\n\t\tint32 scale = 0;\r\r\n\t\twhile (a > sqrt2) {\r\r\n\t\t\ta \/= 2;\r\r\n\t\t\tscale++;\r\r\n\t\t}\r\r\n\t\twhile (a <= sqrtdot5) {\r\r\n\t\t\ta *= 2;\r\r\n\t\t\tscale--;\r\r\n\t\t}\r\r\n\t\tint256 s = (((int256)(a) - one) * one) \/ ((int256)(a) + one);\r\r\n\t\t\/\/ The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\r\n\t\t\/\/ approximates the function log(1+x)-log(1-x)\r\r\n\t\t\/\/ Hence R(s) = log((1+s)\/(1-s)) = log(a)\r\r\n\t\tvar z = (s*s) \/ one;\r\r\n\t\treturn scale * ln2 +\r\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11\/one))\r\r\n\t\t\t\t\/one))\/one))\/one))\/one))\/one);\r\r\n\t}\r\r\n\r\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\r\n\t\tint256 scale = (a + (ln2_64dot5)) \/ ln2 - 64;\r\r\n\t\ta -= scale*ln2;\r\r\n\t\t\/\/ The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\r\n\t\t\/\/ approximates the function x*(exp(x)+1)\/(exp(x)-1)\r\r\n\t\t\/\/ Hence exp(x) = (R(x)+x)\/(R(x)-x)\r\r\n\t\tint256 z = (a*a) \/ one;\r\r\n\t\tint256 R = ((int256)(2) * one) +\r\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8\/one))\/one))\/one))\/one);\r\r\n\t\texp = (uint256) (((R + a) * one) \/ (R - a));\r\r\n\t\tif (scale >= 0)\r\r\n\t\t\texp <<= scale;\r\r\n\t\telse\r\r\n\t\t\texp >>= -scale;\r\r\n\t\treturn exp;\r\r\n\t}\r\r\n\r\r\n\t\/*function destroy() external {\r\r\n\t    selfdestruct(owner);\r\r\n\t}*\/\r\r\n\r\r\n\tfunction () payable public {\r\r\n\t\tif (msg.value > 0)\r\r\n\t\t\tbuy();\r\r\n\t\telse\r\r\n\t\t\twithdrawOld(msg.sender);\r\r\n\t}\r\r\n}","label":1}
{"code":"pragma solidity 0.4.18;\r\r\n\r\r\n\/**\r\r\n * @title Ownable\r\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\r\n * functions, this simplifies the implementation of \"user permissions\".\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n\r\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\r\n   * account.\r\r\n   *\/\r\r\n  function Ownable() public {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Throws if called by any account other than the owner.\r\r\n   *\/\r\r\n  modifier onlyOwner() {\r\r\n    require(msg.sender == owner);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\r\n   * @param newOwner The address to transfer ownership to.\r\r\n   *\/\r\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\r\n    require(newOwner != address(0));\r\r\n    OwnershipTransferred(owner, newOwner);\r\r\n    owner = newOwner;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title SafeMath\r\r\n * @dev Math operations with safety checks that throw on error\r\r\n *\/\r\r\nlibrary SafeMath {\r\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n    uint256 c = a \/ b;\r\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn&#39;t hold\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    uint256 c = a + b;\r\r\n    assert(c >= a);\r\r\n    return c;\r\r\n  }\r\r\n}\r\r\n\r\r\n\/**\r\r\n * @title ERC20Basic\r\r\n * @dev Simpler version of ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\r\n *\/\r\r\ncontract ERC20Basic {\r\r\n  uint256 public totalSupply;\r\r\n  function balanceOf(address who) public constant returns (uint256);\r\r\n  function transfer(address to, uint256 value) public returns (bool);\r\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title ERC20 interface\r\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 is ERC20Basic {\r\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\r\n  function approve(address spender, uint256 value) public returns (bool);\r\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Basic token\r\r\n * @dev Basic version of StandardToken, with no allowances.\r\r\n *\/\r\r\ncontract BasicToken is ERC20Basic {\r\r\n  using SafeMath for uint256;\r\r\n\r\r\n  mapping(address => uint256) balances;\r\r\n\r\r\n  \/**\r\r\n  * @dev transfer token for a specified address\r\r\n  * @param _to The address to transfer to.\r\r\n  * @param _value The amount to be transferred.\r\r\n  *\/\r\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\r\n    require(_to != address(0));\r\r\n    require(_value <= balances[msg.sender]);\r\r\n\r\r\n    \/\/ SafeMath.sub will throw if there is not enough balance.\r\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n  * @dev Gets the balance of the specified address.\r\r\n  * @param _owner The address to query the the balance of.\r\r\n  * @return An uint256 representing the amount owned by the passed address.\r\r\n  *\/\r\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Standard ERC20 token\r\r\n *\r\r\n * @dev Implementation of the basic standard token.\r\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, BasicToken {\r\r\n\r\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\r\n\r\r\n\r\r\n  \/**\r\r\n   * @dev Transfer tokens from one address to another\r\r\n   * @param _from address The address which you want to send tokens from\r\r\n   * @param _to address The address which you want to transfer to\r\r\n   * @param _value uint256 the amount of tokens to be transferred\r\r\n   *\/\r\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\r\n    require(_to != address(0));\r\r\n    require(_value <= balances[_from]);\r\r\n    require(_value <= allowed[_from][msg.sender]);\r\r\n\r\r\n    balances[_from] = balances[_from].sub(_value);\r\r\n    balances[_to] = balances[_to].add(_value);\r\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\r\n   *\r\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\r\n   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\r\r\n   * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n   * @param _spender The address which will spend the funds.\r\r\n   * @param _value The amount of tokens to be spent.\r\r\n   *\/\r\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\r\n   * @param _owner address The address which owns the funds.\r\r\n   * @param _spender address The address which will spend the funds.\r\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\r\n   *\/\r\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\r\n   * the first transaction is mined)\r\r\n   * From MonolithDAO Token.sol\r\r\n   *\/\r\r\n  function increaseApproval (address _spender, uint256 _addedValue) public returns (bool success) {\r\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function decreaseApproval (address _spender, uint256 _subtractedValue) public returns (bool success) {\r\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\r\n    if (_subtractedValue > oldValue) {\r\r\n      allowed[msg.sender][_spender] = 0;\r\r\n    } else {\r\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\r\n    }\r\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * @title Mintable token\r\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\r\n * @dev Issue: * https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/issues\/120\r\r\n * Based on code by TokenMarketNet: https:\/\/github.com\/TokenMarketNet\/ico\/blob\/master\/contracts\/MintableToken.sol\r\r\n *\/\r\r\n\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n  event Mint(address indexed to, uint256 amount);\r\r\n  event MintFinished();\r\r\n\r\r\n  address public saleAgent;\r\r\n\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n\r\r\n  modifier canMint() {\r\r\n    require(!mintingFinished);\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function setSaleAgent(address newSaleAgent) public {\r\r\n    require(msg.sender == saleAgent || msg.sender == owner);\r\r\n    saleAgent = newSaleAgent;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to mint tokens\r\r\n   * @param _to The address that will receive the minted tokens.\r\r\n   * @param _amount The amount of tokens to mint.\r\r\n   * @return A boolean that indicates if the operation was successful.\r\r\n   *\/\r\r\n  \/\/function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\r\n  function mint(address _to, uint256 _amount) canMint public returns (bool) {    \r\r\n    require(msg.sender == saleAgent || msg.sender == owner);\r\r\n    totalSupply = totalSupply.add(_amount);\r\r\n    balances[_to] = balances[_to].add(_amount);\r\r\n    Mint(_to, _amount);\r\r\n    Transfer(address(0), _to, _amount);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * @dev Function to stop minting new tokens.\r\r\n   * @return True if the operation was successful.\r\r\n   *\/\r\r\n  function finishMinting() canMint public returns (bool) {\r\r\n    require(msg.sender == saleAgent || msg.sender == owner);\r\r\n    mintingFinished = true;\r\r\n    MintFinished();\r\r\n    return true;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\ncontract ATFToken is MintableToken {\t\r\r\n    \r\r\n    string public constant name = \"AlgoTradingFun\";\r\r\n   \r\r\n    string public constant symbol = \"ATF\";\r\r\n    \r\r\n    uint32 public constant decimals = 18;\r\r\n\r\r\n    mapping (address => uint256) public locked;\r\r\n\r\r\n    bool public transfersEnabled = false;\r\r\n\r\r\n    event Burn(address indexed burner, uint256 value);\r\r\n\r\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\r\n      require(locked[msg.sender] < now);\r\r\n      require(transfersEnabled);\r\r\n      return super.transfer(_to, _value);\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\r\n      require(locked[_from] < now);\r\r\n      require(transfersEnabled);      \r\r\n      return super.transferFrom(_from, _to, _value);\r\r\n    }\r\r\n  \r\r\n    \/**\r\r\n     * @dev Function that enables\/disables transfers of token.\r\r\n     * @return True if the operation was successful.\r\r\n     *\/\r\r\n    function enableTransfers(bool _value) external onlyOwner {\r\r\n        transfersEnabled = _value;\r\r\n    }\r\r\n    \r\r\n    function lock(address addr, uint256 periodInDays) public {\r\r\n      require(locked[addr] < now && (msg.sender == saleAgent || msg.sender == addr));\r\r\n      locked[addr] = now + periodInDays * 1 days;\r\r\n    }\r\r\n\r\r\n    \/**\r\r\n     * @dev Burns a specific amount of tokens.\r\r\n     * @param _value The amount of token to be burned.\r\r\n     *\/\r\r\n    function burn(uint256 _value) public {\r\r\n        require(_value > 0);\r\r\n        require(_value <= balances[msg.sender]);\r\r\n\r\r\n        \/\/ no need to require value <= totalSupply, since that would imply the\r\r\n        \/\/ sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\r\r\n\r\r\n        address burner = msg.sender;\r\r\n        balances[burner] = balances[burner].sub(_value);\r\r\n        totalSupply = totalSupply.sub(_value);\r\r\n        Burn(burner, _value);\r\r\n    }\r\r\n\r\r\n    function () payable {\r\r\n      revert();\r\r\n    }\r\r\n\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.8;\r\r\n\r\r\n\/\/ ----------------------------------------------------------------------------------------------\r\r\n\/\/ The Incent \/ ETH smart contract - to find out more, join the Incent Slack; http:\/\/incentinvites.herokuapp.com\/\r\r\n\/\/ A collaboration between Incent and Bok :)\r\r\n\/\/ Enjoy. (c) Incent Loyalty Pty Ltd and Bok Consulting Pty Ltd 2017. The MIT Licence.\r\r\n\/\/ ----------------------------------------------------------------------------------------------\r\r\n\r\r\n\/\/ Contract configuration\r\r\ncontract TokenConfig {\r\r\n    string public constant symbol = \"INC\";\r\r\n    string public constant name = \"Incent\";\r\r\n    uint8 public constant decimals = 8;  \/\/ 8 decimal places, the same as tokens on Wave\r\r\n    uint256 _totalSupply = 4601662500000000;\r\r\n}\r\r\n\r\r\n\/\/ ERC Token Standard #20 Interface\r\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\ncontract ERC20Interface {\r\r\n    \/\/ Get the total token supply\r\r\n    function totalSupply() constant returns (uint256 totalSupply);\r\r\n\r\r\n    \/\/ Get the account balance of another account with address _owner\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\r\n\r\r\n    \/\/ Send _value amount of tokens to address _to\r\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/ Send _value amount of tokens from address _from to address _to\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/ Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\r\n    \/\/ If this function is called again it overwrites the current allowance with _value.\r\r\n    \/\/ this function is required for some DEX functionality\r\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\r\n\r\r\n    \/\/ Returns the amount which _spender is still allowed to withdraw from _owner\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n\r\r\n    \/\/ Triggered when tokens are transferred.\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n\r\r\n    \/\/ Triggered whenever approve(address _spender, uint256 _value) is called.\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\ncontract IncentToken is ERC20Interface, TokenConfig {\r\r\n    \/\/ Owner of this contract\r\r\n    address public owner;\r\r\n\r\r\n    \/\/ Balances for each account\r\r\n    mapping(address => uint256) balances;\r\r\n\r\r\n    \/\/ Owner of account approves the transfer of an amount to another account\r\r\n    mapping(address => mapping (address => uint256)) allowed;\r\r\n\r\r\n    \/\/ Functions with this modifier can only be executed by the owner\r\r\n    modifier onlyOwner() {\r\r\n        if (msg.sender != owner) {\r\r\n            throw;\r\r\n        }\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    \/\/ Constructor\r\r\n    function IncentToken() {\r\r\n        owner = msg.sender;\r\r\n        balances[owner] = _totalSupply;\r\r\n    }\r\r\n\r\r\n    function totalSupply() constant returns (uint256 totalSupply) {\r\r\n        totalSupply = _totalSupply;\r\r\n    }\r\r\n\r\r\n    \/\/ What is the balance of a particular account?\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n    \/\/ Transfer the balance from owner&#39;s account to another account\r\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\r\n        if (balances[msg.sender] >= _amount\r\r\n            && _amount > 0\r\r\n            && balances[_to] + _amount > balances[_to]) {\r\r\n            balances[msg.sender] -= _amount;\r\r\n            balances[_to] += _amount;\r\r\n            Transfer(msg.sender, _to, _amount);\r\r\n            return true;\r\r\n        } else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/ Send _value amount of tokens from address _from to address _to\r\r\n    \/\/ The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\r\n    \/\/ tokens on your behalf, for example to \"deposit\" to a contract address and\/or to charge\r\r\n    \/\/ fees in sub-currencies; the command should fail unless the _from account has\r\r\n    \/\/ deliberately authorized the sender of the message via some mechanism; we propose\r\r\n    \/\/ these standardized APIs for approval:\r\r\n    function transferFrom(\r\r\n        address _from,\r\r\n        address _to,\r\r\n        uint256 _amount\r\r\n) returns (bool success) {\r\r\n        if (balances[_from] >= _amount\r\r\n            && allowed[_from][msg.sender] >= _amount\r\r\n            && _amount > 0\r\r\n            && balances[_to] + _amount > balances[_to]) {\r\r\n            balances[_from] -= _amount;\r\r\n            allowed[_from][msg.sender] -= _amount;\r\r\n            balances[_to] += _amount;\r\r\n            Transfer(_from, _to, _amount);\r\r\n            return true;\r\r\n        } else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    \/\/ Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\r\n    \/\/ If this function is called again it overwrites the current allowance with _value.\r\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\r\n        allowed[msg.sender][_spender] = _amount;\r\r\n        Approval(msg.sender, _spender, _amount);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract WavesEthereumSwap is IncentToken {\r\r\n    event WavesTransfer(address indexed _from, string wavesAddress, uint256 amount);\r\r\n\r\r\n    function moveToWaves(string wavesAddress, uint256 amount) {\r\r\n        if (!transfer(owner, amount)) throw;\r\r\n        WavesTransfer(msg.sender, wavesAddress, amount);\r\r\n    }\r\r\n}","label":0}
{"code":"\/*\r\r\n * ERC20 interface\r\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\r\n *\/\r\r\ncontract ERC20 {\r\r\n  uint public totalSupply;\r\r\n  function balanceOf(address who) constant returns (uint);\r\r\n  function allowance(address owner, address spender) constant returns (uint);\r\r\n\r\r\n  function transfer(address to, uint value) returns (bool ok);\r\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\r\n  function approve(address spender, uint value) returns (bool ok);\r\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Math operations with safety checks\r\r\n *\/\r\r\ncontract SafeMath {\r\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\r\n    assert(b > 0);\r\r\n    uint c = a \/ b;\r\r\n    assert(a == b * c + a % b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a && c>=b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a >= b ? a : b;\r\r\n  }\r\r\n\r\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\r\n    return a < b ? a : b;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) internal {\r\r\n    if (!assertion) {\r\r\n      throw;\r\r\n    }\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\r\n *\r\r\n * Based on code by FirstBlood:\r\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\r\n *\/\r\r\ncontract StandardToken is ERC20, SafeMath {\r\r\n\r\r\n  \/* Token supply got increased and a new owner received these tokens *\/\r\r\n  event Minted(address receiver, uint amount);\r\r\n\r\r\n  \/* Actual balances of token holders *\/\r\r\n  mapping(address => uint) balances;\r\r\n\r\r\n  \/* approve() allowances *\/\r\r\n  mapping (address => mapping (address => uint)) allowed;\r\r\n\r\r\n  \/* Interface declaration *\/\r\r\n  function isToken() public constant returns (bool weAre) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    Transfer(msg.sender, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\r\n    uint _allowance = allowed[_from][msg.sender];\r\r\n\r\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\r\n    balances[_from] = safeSub(balances[_from], _value);\r\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\r\n    Transfer(_from, _to, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\r\n    return balances[_owner];\r\r\n  }\r\r\n\r\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\r\n\r\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\r\n    \/\/  already 0 to mitigate the race condition described here:\r\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\r\n\r\r\n    allowed[msg.sender][_spender] = _value;\r\r\n    Approval(msg.sender, _spender, _value);\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\r\n    return allowed[_owner][_spender];\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Upgrade agent interface inspired by Lunyr.\r\r\n *\r\r\n * Upgrade agent transfers tokens to a new contract.\r\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\r\n *\/\r\r\ncontract UpgradeAgent {\r\r\n\r\r\n  uint public originalSupply;\r\r\n\r\r\n  \/** Interface marker *\/\r\r\n  function isUpgradeAgent() public constant returns (bool) {\r\r\n    return true;\r\r\n  }\r\r\n\r\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\r\n *\r\r\n * First envisioned by Golem and Lunyr projects.\r\r\n *\/\r\r\ncontract UpgradeableToken is StandardToken {\r\r\n\r\r\n  \/** Contract \/ person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. *\/\r\r\n  address public upgradeMaster;\r\r\n\r\r\n  \/** The next contract where the tokens will be migrated. *\/\r\r\n  UpgradeAgent public upgradeAgent;\r\r\n\r\r\n  \/** How many tokens we have upgraded by now. *\/\r\r\n  uint256 public totalUpgraded;\r\r\n\r\r\n  \/**\r\r\n   * Upgrade states.\r\r\n   *\r\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\r\n   * - WaitingForAgent: Token allows upgrade, but we don&#39;t have a new agent yet\r\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\r\n   *\r\r\n   *\/\r\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\r\n\r\r\n  \/**\r\r\n   * Somebody has upgraded some of his tokens.\r\r\n   *\/\r\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\r\n\r\r\n  \/**\r\r\n   * New upgrade agent available.\r\r\n   *\/\r\r\n  event UpgradeAgentSet(address agent);\r\r\n\r\r\n  \/**\r\r\n   * Do not allow construction without upgrade master set.\r\r\n   *\/\r\r\n  function UpgradeableToken(address _upgradeMaster) {\r\r\n    upgradeMaster = _upgradeMaster;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\r\n   *\/\r\r\n  function upgrade(uint256 value) public {\r\r\n\r\r\n      UpgradeState state = getUpgradeState();\r\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\r\n        \/\/ Called in a bad state\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      \/\/ Validate input value.\r\r\n      if (value == 0) throw;\r\r\n\r\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\r\n\r\r\n      \/\/ Take tokens out from circulation\r\r\n      totalSupply = safeSub(totalSupply, value);\r\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\r\n\r\r\n      \/\/ Upgrade agent reissues the tokens\r\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set an upgrade agent that handles\r\r\n   *\/\r\r\n  function setUpgradeAgent(address agent) external {\r\r\n\r\r\n      if(!canUpgrade()) {\r\r\n        \/\/ The token is not yet in a state that we could think upgrading\r\r\n        throw;\r\r\n      }\r\r\n\r\r\n      if (agent == 0x0) throw;\r\r\n      \/\/ Only a master can designate the next agent\r\r\n      if (msg.sender != upgradeMaster) throw;\r\r\n      \/\/ Upgrade has already begun for an agent\r\r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\r\n\r\r\n      upgradeAgent = UpgradeAgent(agent);\r\r\n\r\r\n      \/\/ Bad interface\r\r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\r\n      \/\/ Make sure that token supplies match in source and target\r\r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\r\n\r\r\n      UpgradeAgentSet(upgradeAgent);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Get the state of the token upgrade.\r\r\n   *\/\r\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\r\n    else return UpgradeState.Upgrading;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Change the upgrade master.\r\r\n   *\r\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\r\n   *\/\r\r\n  function setUpgradeMaster(address master) public {\r\r\n      if (master == 0x0) throw;\r\r\n      if (msg.sender != upgradeMaster) throw;\r\r\n      upgradeMaster = master;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\r\n   *\/\r\r\n  function canUpgrade() public constant returns(bool) {\r\r\n     return true;\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n * Ownable\r\r\n *\r\r\n * Base contract with an owner.\r\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\r\n *\/\r\r\ncontract Ownable {\r\r\n  address public owner;\r\r\n\r\r\n  function Ownable() {\r\r\n    owner = msg.sender;\r\r\n  }\r\r\n\r\r\n  modifier onlyOwner() {\r\r\n    if (msg.sender != owner) {\r\r\n      throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transferOwnership(address newOwner) onlyOwner {\r\r\n    if (newOwner != address(0)) {\r\r\n      owner = newOwner;\r\r\n    }\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\r\n *\/\r\r\ncontract ReleasableToken is ERC20, Ownable {\r\r\n\r\r\n  \/* The finalizer contract that allows unlift the transfer limits on this token *\/\r\r\n  address public releaseAgent;\r\r\n\r\r\n  \/** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*\/\r\r\n  bool public released = false;\r\r\n\r\r\n  \/** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. *\/\r\r\n  mapping (address => bool) public transferAgents;\r\r\n\r\r\n  \/**\r\r\n   * Limit token transfer until the crowdsale is over.\r\r\n   *\r\r\n   *\/\r\r\n  modifier canTransfer(address _sender) {\r\r\n\r\r\n    if(!released) {\r\r\n        if(!transferAgents[_sender]) {\r\r\n            throw;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Set the contract that can call release and make the token transferable.\r\r\n   *\r\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\r\n   *\/\r\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\r\n\r\r\n    \/\/ We don&#39;t do interface check here as we might want to a normal wallet address to act as a release agent\r\r\n    releaseAgent = addr;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\r\n   *\/\r\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\r\n    transferAgents[addr] = state;\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * One way function to release the tokens to the wild.\r\r\n   *\r\r\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\r\n   *\/\r\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\r\n    released = true;\r\r\n  }\r\r\n\r\r\n  \/** The function can be called only before or after the tokens have been releasesd *\/\r\r\n  modifier inReleaseState(bool releaseState) {\r\r\n    if(releaseState != released) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/** The function can be called only by a whitelisted release agent. *\/\r\r\n  modifier onlyReleaseAgent() {\r\r\n    if(msg.sender != releaseAgent) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\r\n    \/\/ Call StandardToken.transfer()\r\r\n   return super.transfer(_to, _value);\r\r\n  }\r\r\n\r\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\r\n    \/\/ Call StandardToken.transferForm()\r\r\n    return super.transferFrom(_from, _to, _value);\r\r\n  }\r\r\n\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * Safe unsigned safe math.\r\r\n *\r\r\n * https:\/\/blog.aragon.one\/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\r\n *\r\r\n * Originally from https:\/\/raw.githubusercontent.com\/AragonOne\/zeppelin-solidity\/master\/contracts\/SafeMathLib.sol\r\r\n *\r\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\r\n *\r\r\n *\/\r\r\nlibrary SafeMathLib {\r\r\n\r\r\n  function times(uint a, uint b) returns (uint) {\r\r\n    uint c = a * b;\r\r\n    assert(a == 0 || c \/ a == b);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function minus(uint a, uint b) returns (uint) {\r\r\n    assert(b <= a);\r\r\n    return a - b;\r\r\n  }\r\r\n\r\r\n  function plus(uint a, uint b) returns (uint) {\r\r\n    uint c = a + b;\r\r\n    assert(c>=a);\r\r\n    return c;\r\r\n  }\r\r\n\r\r\n  function assert(bool assertion) private {\r\r\n    if (!assertion) throw;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * A token that can increase its supply by another contract.\r\r\n *\r\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\r\n *\r\r\n *\/\r\r\ncontract MintableToken is StandardToken, Ownable {\r\r\n\r\r\n  using SafeMathLib for uint;\r\r\n\r\r\n  bool public mintingFinished = false;\r\r\n\r\r\n  \/** List of agents that are allowed to create new tokens *\/\r\r\n  mapping (address => bool) public mintAgents;\r\r\n\r\r\n  event MintingAgentChanged(address addr, bool state  );\r\r\n\r\r\n  \/**\r\r\n   * Create new tokens and allocate them to an address..\r\r\n   *\r\r\n   * Only callably by a crowdsale contract (mint agent).\r\r\n   *\/\r\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\r\n    totalSupply = totalSupply.plus(amount);\r\r\n    balances[receiver] = balances[receiver].plus(amount);\r\r\n\r\r\n    \/\/ This will make the mint transaction apper in EtherScan.io\r\r\n    \/\/ We can remove this after there is a standardized minting event\r\r\n    Transfer(0, receiver, amount);\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\r\n   *\/\r\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\r\n    mintAgents[addr] = state;\r\r\n    MintingAgentChanged(addr, state);\r\r\n  }\r\r\n\r\r\n  modifier onlyMintAgent() {\r\r\n    \/\/ Only crowdsale contracts are allowed to mint new tokens\r\r\n    if(!mintAgents[msg.sender]) {\r\r\n        throw;\r\r\n    }\r\r\n    _;\r\r\n  }\r\r\n\r\r\n  \/** Make sure we are not done yet. *\/\r\r\n  modifier canMint() {\r\r\n    if(mintingFinished) throw;\r\r\n    _;\r\r\n  }\r\r\n}\r\r\n\r\r\n\r\r\n\r\r\n\/**\r\r\n * A crowdsaled token.\r\r\n *\r\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\r\n *\r\r\n * - The token transfer() is disabled until the crowdsale is over\r\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\r\n *\r\r\n *\/\r\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\r\r\n\r\r\n  \/** Name and symbol were updated. *\/\r\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\r\n\r\r\n  string public name;\r\r\n\r\r\n  string public symbol;\r\r\n\r\r\n  uint public decimals;\r\r\n\r\r\n  \/**\r\r\n   * Construct the token.\r\r\n   *\r\r\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\r\n   *\r\r\n   * @param _name Token name\r\r\n   * @param _symbol Token symbol - should be all caps\r\r\n   * @param _initialSupply How many tokens we start with\r\r\n   * @param _decimals Number of decimal places\r\r\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\r\r\n   *\/\r\r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\r\r\n    UpgradeableToken(msg.sender) {\r\r\n\r\r\n    \/\/ Create any address, can be transferred\r\r\n    \/\/ to team multisig via changeOwner(),\r\r\n    \/\/ also remember to call setUpgradeMaster()\r\r\n    owner = msg.sender;\r\r\n\r\r\n    name = _name;\r\r\n    symbol = _symbol;\r\r\n\r\r\n    totalSupply = _initialSupply;\r\r\n\r\r\n    decimals = _decimals;\r\r\n\r\r\n    \/\/ Create initially all balance on the team multisig\r\r\n    balances[owner] = totalSupply;\r\r\n\r\r\n    if(totalSupply > 0) {\r\r\n      Minted(owner, totalSupply);\r\r\n    }\r\r\n\r\r\n    \/\/ No more new supply allowed after the token creation\r\r\n    if(!_mintable) {\r\r\n      mintingFinished = true;\r\r\n      if(totalSupply == 0) {\r\r\n        throw; \/\/ Cannot create a token without supply and no minting\r\r\n      }\r\r\n    }\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * When token is released to be transferable, enforce no new tokens can be created.\r\r\n   *\/\r\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\r\n    mintingFinished = true;\r\r\n    super.releaseTokenTransfer();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\r\n   *\/\r\r\n  function canUpgrade() public constant returns(bool) {\r\r\n    return released && super.canUpgrade();\r\r\n  }\r\r\n\r\r\n  \/**\r\r\n   * Owner can update token information here.\r\r\n   *\r\r\n   * It is often useful to conceal the actual token association, until\r\r\n   * the token operations, like central issuance or reissuance have been completed.\r\r\n   *\r\r\n   * This function allows the token owner to rename the token after the operations\r\r\n   * have been completed and then point the audience to use the token contract.\r\r\n   *\/\r\r\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\r\r\n    name = _name;\r\r\n    symbol = _symbol;\r\r\n\r\r\n    UpdatedTokenInformation(name, symbol);\r\r\n  }\r\r\n\r\r\n}","label":0}
{"code":"\/\/ Refund contract for trust DAO #39\r\r\n\r\r\ncontract DAO {\r\r\n    function balanceOf(address addr) returns (uint);\r\r\n    function transferFrom(address from, address to, uint balance) returns (bool);\r\r\n    uint public totalSupply;\r\r\n}\r\r\n\r\r\ncontract WithdrawDAO {\r\r\n    DAO constant public mainDAO = DAO(0x6131c42fa982e56929107413a9d526fd99405560);\r\r\n    address public trustee = 0xf4c0eef475ab35625ac223394f9c410ccb577747;\r\r\n\r\r\n    function withdraw(){\r\r\n        uint balance = mainDAO.balanceOf(msg.sender);\r\r\n\r\r\n        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))\r\r\n            throw;\r\r\n    }\r\r\n\r\r\n    function trusteeWithdraw() {\r\r\n        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());\r\r\n    }\r\r\n}","label":0}
{"code":"\/* This contract is the API for blockchain2email.com, \r\r\n   which allows you to send emails from your smart contract.\r\r\n   Check out http:\/\/blockchain2email.com\/ fpr info on how to\r\r\n   include API reference into your contract.\r\r\n   \r\r\n   Version 1.1      *\/\r\r\n   \r\r\n\r\r\ncontract depletable {\r\r\n    address owner;\r\r\n    function depletable() { \r\r\n        owner = msg.sender;\r\r\n    }\r\r\n    function withdraw() { \r\r\n        if (msg.sender == owner) {\r\r\n            while(!owner.send(this.balance)){}\r\r\n        }\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract blockchain2email is depletable {\r\r\n\tevent EmailSent(address Sender, string EmailAddress, string Message);\r\r\n\t\r\r\n\tfunction SendEmail(string EmailAddress, string Message) returns (bool) { \r\r\n\t\tif(msg.value>999999999999999){\r\r\n\t\t\tEmailSent(msg.sender, EmailAddress, Message);\r\r\n\t\t\treturn (true);\r\r\n\t\t}else{\r\r\n\t\t    while(!msg.sender.send(msg.value)){}\r\r\n\t\t    return (false);\r\r\n\t\t}\r\r\n    } \r\r\n}","label":0}
{"code":"\/**\r\r\n\r\r\n *Submitted for verification at Etherscan.io on 2018-02-02\r\r\n\r\r\n*\/\r\r\n\r\r\n\r\r\n\r\r\npragma solidity ^0.4.18;\r\r\n\r\r\n\r\r\n\r\r\n\/*\r\r\n\r\r\n          ,\/`.\r\r\n\r\r\n        ,'\/ __`.\r\r\n\r\r\n      ,'_\/_  _ _`.\r\r\n\r\r\n    ,'__\/_ ___ _  `.\r\r\n\r\r\n  ,'_  \/___ __ _ __ `.\r\r\n\r\r\n '-.._\/___...-\"-.-..__`.\r\r\n\r\r\n  B\r\r\n\r\r\n\r\r\n\r\r\n EthPyramid. A no-bullshit, transparent, self-sustaining pyramid scheme.\r\r\n\r\r\n \r\r\n\r\r\n Inspired by https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/\r\r\n\r\r\n\r\r\n\r\r\n Developers:\r\r\n\r\r\n\tArc\r\r\n\r\r\n\tDivine\r\r\n\r\r\n\tNorsefire\r\r\n\r\r\n\tToCsIcK\r\r\n\r\r\n\t\r\r\n\r\r\n Front-End:\r\r\n\r\r\n\tCardioth\r\r\n\r\r\n\ttenmei\r\r\n\r\r\n\tTrendium\r\r\n\r\r\n\t\r\r\n\r\r\n Moral Support:\r\r\n\r\r\n\tDeadCow.Rat\r\r\n\r\r\n\tDots\r\r\n\r\r\n\tFatKreamy\r\r\n\r\r\n\tKaseylol\r\r\n\r\r\n\tQuantumDeath666\r\r\n\r\r\n\tQuentin\r\r\n\r\r\n \r\r\n\r\r\n Shit-Tier:\r\r\n\r\r\n\tHentaiChrist\r\r\n\r\r\n \r\r\n\r\r\n*\/\r\r\n\r\r\n\r\r\n\r\r\ncontract EthPyramid {\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ scaleFactor is used to convert Ether into tokens and vice-versa: they're of different\r\r\n\r\r\n\t\/\/ orders of magnitude, hence the need to bridge between the two.\r\r\n\r\r\n\tuint256 constant scaleFactor = 0x10000000000000000;  \/\/ 2^64\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ CRR = 50%\r\r\n\r\r\n\t\/\/ CRR is Cash Reserve Ratio (in this case Crypto Reserve Ratio).\r\r\n\r\r\n\t\/\/ For more on this: check out https:\/\/en.wikipedia.org\/wiki\/Reserve_requirement\r\r\n\r\r\n\tint constant crr_n = 1; \/\/ CRR numerator\r\r\n\r\r\n\tint constant crr_d = 2; \/\/ CRR denominator\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The price coefficient. Chosen such that at 1 token total supply\r\r\n\r\r\n\t\/\/ the amount in reserve is 0.5 ether and token price is 1 Ether.\r\r\n\r\r\n\tint constant price_coeff = -0x296ABF784A358468C;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Typical values that we have to declare.\r\r\n\r\r\n\tstring constant public name = \"EthPyramid\";\r\r\n\r\r\n\tstring constant public symbol = \"EPY\";\r\r\n\r\r\n\tuint8 constant public decimals = 18;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Array between each address and their number of tokens.\r\r\n\r\r\n\tmapping(address => uint256) public tokenBalance;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\/\/ Array between each address and how much Ether has been paid out to it.\r\r\n\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\r\r\n\tmapping(address => int256) public payouts;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Variable tracking how many tokens are in existence overall.\r\r\n\r\r\n\tuint256 public totalSupply;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Aggregate sum of all payouts.\r\r\n\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\r\r\n\tint256 totalPayouts;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Variable tracking how much Ether each token is currently worth.\r\r\n\r\r\n\t\/\/ Note that this is scaled by the scaleFactor variable.\r\r\n\r\r\n\tuint256 earningsPerToken;\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ Current contract balance in Ether\r\r\n\r\r\n\tuint256 public contractBalance;\r\r\n\r\r\n\r\r\n\r\r\n\tfunction EthPyramid() public {}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The following functions are used by the front-end for display purposes.\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Returns the number of tokens currently held by _owner.\r\r\n\r\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\r\n\r\r\n\t\treturn tokenBalance[_owner];\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Withdraws all dividends held by the caller sending the transaction, updates\r\r\n\r\r\n\t\/\/ the requisite global variables, and transfers Ether back to the caller.\r\r\n\r\r\n\tfunction withdraw() public {\r\r\n\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n\r\r\n\t\tmsg.sender.transfer(balance);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Converts the Ether accrued as dividends back into EPY tokens without having to\r\r\n\r\r\n\t\/\/ withdraw it first. Saves on gas and potential price spike loss.\r\r\n\r\r\n\tfunction reinvestDividends() public {\r\r\n\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\r\r\n\t\t\/\/ Since this is essentially a shortcut to withdrawing and reinvesting, this step still holds.\r\r\n\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Assign balance to a new variable.\r\r\n\r\r\n\t\tuint value_ = (uint) (balance);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ If your dividends are worth less than 1 szabo, or more than a million Ether\r\r\n\r\r\n\t\t\/\/ (in which case, why are you even here), abort.\r\r\n\r\r\n\t\tif (value_ < 0.000001 ether || value_ > 1000000 ether)\r\r\n\r\r\n\t\t\trevert();\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\r\r\n\t\tvar sender = msg.sender;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ A temporary reserve variable used for calculating the reward the holder gets for buying tokens.\r\r\n\r\r\n\t\t\/\/ (Yes, the buyer receives a part of the distribution as well!)\r\r\n\r\r\n\t\tvar res = reserve() - balance;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\r\r\n\t\tvar fee = div(value_, 10);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\r\r\n\t\tvar numEther = value_ - fee;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\r\r\n\t\tvar numTokens = calculateDividendTokens(numEther, balance);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\r\r\n\t\t\/\/ else you're gonna have a bad time.\r\r\n\r\r\n\t\tif (totalSupply > 0) {\r\r\n\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\r\r\n\t\t\tvar bonusCoEff =\r\r\n\r\r\n\t\t\t    (scaleFactor - (res + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\r\r\n\t\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We're a crypto central bank!\r\r\n\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\r\r\n\t\tvar payoutDiff  = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Sells your tokens for Ether. This Ether is assigned to the callers entry\r\r\n\r\r\n\t\/\/ in the tokenBalance array, and therefore is shown as a dividend. A second\r\r\n\r\r\n\t\/\/ call to withdraw() must be made to invoke the transfer of Ether back to your address.\r\r\n\r\r\n\tfunction sellMyTokens() public {\r\r\n\r\r\n\t\tvar balance = balanceOf(msg.sender);\r\r\n\r\r\n\t\tsell(balance);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The slam-the-button escape hatch. Sells the callers tokens for Ether, then immediately\r\r\n\r\r\n\t\/\/ invokes the withdraw() function, sending the resulting Ether to the callers address.\r\r\n\r\r\n    function getMeOutOfHere() public {\r\r\n\r\r\n\t\tsellMyTokens();\r\r\n\r\r\n        withdraw();\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Gatekeeper function to check if the amount of Ether being sent isn't either\r\r\n\r\r\n\t\/\/ too small or too large. If it passes, goes direct to buy().\r\r\n\r\r\n\tfunction fund() payable public {\r\r\n\r\r\n\t\t\/\/ Don't allow for funding if the amount of Ether sent is less than 1 szabo.\r\r\n\r\r\n\t\tif (msg.value > 0.000001 ether) {\r\r\n\r\r\n\t\t    contractBalance = add(contractBalance, msg.value);\r\r\n\r\r\n\t\t\tbuy();\r\r\n\r\r\n\t\t} else {\r\r\n\r\r\n\t\t\trevert();\r\r\n\r\r\n\t\t}\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of buying a finney worth of tokens.\r\r\n\r\r\n\tfunction buyPrice() public constant returns (uint) {\r\r\n\r\r\n\t\treturn getTokensForEther(1 finney);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Function that returns the (dynamic) price of selling a single token.\r\r\n\r\r\n\tfunction sellPrice() public constant returns (uint) {\r\r\n\r\r\n        var eth = getEtherForTokens(1 finney);\r\r\n\r\r\n        var fee = div(eth, 10);\r\r\n\r\r\n        return eth - fee;\r\r\n\r\r\n    }\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Calculate the current dividends associated with the caller address. This is the net result\r\r\n\r\r\n\t\/\/ of multiplying the number of tokens held by their current value in Ether and subtracting the\r\r\n\r\r\n\t\/\/ Ether that has already been paid out.\r\r\n\r\r\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\r\r\n\r\r\n\t\treturn (uint256) ((int256)(earningsPerToken * tokenBalance[_owner]) - payouts[_owner]) \/ scaleFactor;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Version of withdraw that extracts the dividends and sends the Ether to the caller.\r\r\n\r\r\n\t\/\/ This is only used in the case when there is no transaction data, and that should be\r\r\n\r\r\n\t\/\/ quite rare unless interacting directly with the smart contract.\r\r\n\r\r\n\tfunction withdrawOld(address to) public {\r\r\n\r\r\n\t\t\/\/ Retrieve the dividends associated with the address the request came from.\r\r\n\r\r\n\t\tvar balance = dividends(msg.sender);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Update the payouts array, incrementing the request address by `balance`.\r\r\n\r\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Increase the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Send the dividends to the address that requested the withdraw.\r\r\n\r\r\n\t\tcontractBalance = sub(contractBalance, balance);\r\r\n\r\r\n\t\tto.transfer(balance);\t\t\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Internal balance function, used to calculate the dynamic reserve value.\r\r\n\r\r\n\tfunction balance() internal constant returns (uint256 amount) {\r\r\n\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\r\r\n\t\treturn contractBalance - msg.value;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction buy() internal {\r\r\n\r\r\n\t\t\/\/ Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\r\n\r\r\n\t\tif (msg.value < 0.000001 ether || msg.value > 1000000 ether)\r\r\n\r\r\n\t\t\trevert();\r\r\n\r\r\n\t\t\t\t\t\t\r\r\n\r\r\n\t\t\/\/ msg.sender is the address of the caller.\r\r\n\r\r\n\t\tvar sender = msg.sender;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ 10% of the total Ether sent is used to pay existing holders.\r\r\n\r\r\n\t\tvar fee = div(msg.value, 10);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The amount of Ether used to purchase new tokens for the caller.\r\r\n\r\r\n\t\tvar numEther = msg.value - fee;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The number of tokens which can be purchased for numEther.\r\r\n\r\r\n\t\tvar numTokens = getTokensForEther(numEther);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ The buyer fee, scaled by the scaleFactor variable.\r\r\n\r\r\n\t\tvar buyerFee = fee * scaleFactor;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Check that we have tokens in existence (this should always be true), or\r\r\n\r\r\n\t\t\/\/ else you're gonna have a bad time.\r\r\n\r\r\n\t\tif (totalSupply > 0) {\r\r\n\r\r\n\t\t\t\/\/ Compute the bonus co-efficient for all existing holders and the buyer.\r\r\n\r\r\n\t\t\t\/\/ The buyer receives part of the distribution for each token bought in the\r\r\n\r\r\n\t\t\t\/\/ same way they would have if they bought each token individually.\r\r\n\r\r\n\t\t\tvar bonusCoEff =\r\r\n\r\r\n\t\t\t    (scaleFactor - (reserve() + numEther) * numTokens * scaleFactor \/ (totalSupply + numTokens) \/ numEther)\r\r\n\r\r\n\t\t\t    * (uint)(crr_d) \/ (uint)(crr_d-crr_n);\r\r\n\r\r\n\t\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The total reward to be distributed amongst the masses is the fee (in Ether)\r\r\n\r\r\n\t\t\t\/\/ multiplied by the bonus co-efficient.\r\r\n\r\r\n\t\t\tvar holderReward = fee * bonusCoEff;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\tbuyerFee -= holderReward;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all existing token holders before the new tokens are purchased.\r\r\n\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this buy-in.\r\r\n\r\r\n\t\t\tvar rewardPerShare = holderReward \/ totalSupply;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\r\r\n\t\t\tearningsPerToken += rewardPerShare;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ Add the numTokens which were just created to the total supply. We're a crypto central bank!\r\r\n\r\r\n\t\ttotalSupply = add(totalSupply, numTokens);\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ Assign the tokens to the balance of the buyer.\r\r\n\r\r\n\t\ttokenBalance[sender] = add(tokenBalance[sender], numTokens);\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\r\n\r\r\n\t\t\/\/ Also include the fee paid for entering the scheme.\r\r\n\r\r\n\t\t\/\/ First we compute how much was just paid out to the buyer...\r\r\n\r\r\n\t\tvar payoutDiff = (int256) ((earningsPerToken * numTokens) - buyerFee);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Then we update the payouts array for the buyer with this amount...\r\r\n\r\r\n\t\tpayouts[sender] += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\r\n\r\r\n\t\ttotalPayouts    += payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Sell function that takes tokens and converts them into Ether. Also comes with a 10% fee\r\r\n\r\r\n\t\/\/ to discouraging dumping, and means that if someone near the top sells, the fee distributed\r\r\n\r\r\n\t\/\/ will be *significant*.\r\r\n\r\r\n\tfunction sell(uint256 amount) internal {\r\r\n\r\r\n\t    \/\/ Calculate the amount of Ether that the holders tokens sell for at the current sell price.\r\r\n\r\r\n\t\tvar numEthersBeforeFee = getEtherForTokens(amount);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ 10% of the resulting Ether is used to pay remaining holders.\r\r\n\r\r\n        var fee = div(numEthersBeforeFee, 10);\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Net Ether for the seller after the fee has been subtracted.\r\r\n\r\r\n        var numEthers = numEthersBeforeFee - fee;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ *Remove* the numTokens which were just sold from the total supply. We're \/definitely\/ a crypto central bank.\r\r\n\r\r\n\t\ttotalSupply = sub(totalSupply, amount);\r\r\n\r\r\n\t\t\r\r\n\r\r\n        \/\/ Remove the tokens from the balance of the buyer.\r\r\n\r\r\n\t\ttokenBalance[msg.sender] = sub(tokenBalance[msg.sender], amount);\r\r\n\r\r\n\r\r\n\r\r\n        \/\/ Update the payout array so that the seller cannot claim future dividends unless they buy back in.\r\r\n\r\r\n\t\t\/\/ First we compute how much was just paid out to the seller...\r\r\n\r\r\n\t\tvar payoutDiff = (int256) (earningsPerToken * amount + (numEthers * scaleFactor));\r\r\n\r\r\n\t\t\r\r\n\r\r\n        \/\/ We reduce the amount paid out to the seller (this effectively resets their payouts value to zero,\r\r\n\r\r\n\t\t\/\/ since they're selling all of their tokens). This makes sure the seller isn't disadvantaged if\r\r\n\r\r\n\t\t\/\/ they decide to buy back in.\r\r\n\r\r\n\t\tpayouts[msg.sender] -= payoutDiff;\t\t\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Decrease the total amount that's been paid out to maintain invariance.\r\r\n\r\r\n        totalPayouts -= payoutDiff;\r\r\n\r\r\n\t\t\r\r\n\r\r\n\t\t\/\/ Check that we have tokens in existence (this is a bit of an irrelevant check since we're\r\r\n\r\r\n\t\t\/\/ selling tokens, but it guards against division by zero).\r\r\n\r\r\n\t\tif (totalSupply > 0) {\r\r\n\r\r\n\t\t\t\/\/ Scale the Ether taken as the selling fee by the scaleFactor variable.\r\r\n\r\r\n\t\t\tvar etherFee = fee * scaleFactor;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ Fee is distributed to all remaining token holders.\r\r\n\r\r\n\t\t\t\/\/ rewardPerShare is the amount gained per token thanks to this sell.\r\r\n\r\r\n\t\t\tvar rewardPerShare = etherFee \/ totalSupply;\r\r\n\r\r\n\t\t\t\r\r\n\r\r\n\t\t\t\/\/ The Ether value per token is increased proportionally.\r\r\n\r\r\n\t\t\tearningsPerToken = add(earningsPerToken, rewardPerShare);\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t}\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ Dynamic value of Ether in reserve, according to the CRR requirement.\r\r\n\r\r\n\tfunction reserve() internal constant returns (uint256 amount) {\r\r\n\r\r\n\t\treturn sub(balance(),\r\r\n\r\r\n\t\t\t ((uint256) ((int256) (earningsPerToken * totalSupply) - totalPayouts) \/ scaleFactor));\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Calculates the number of tokens that can be bought for a given amount of Ether, according to the\r\r\n\r\r\n\t\/\/ dynamic reserve and totalSupply values (derived from the buy and sell prices).\r\r\n\r\r\n\tfunction getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {\r\r\n\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Semantically similar to getTokensForEther, but subtracts the callers balance from the amount of Ether returned for conversion.\r\r\n\r\r\n\tfunction calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {\r\r\n\r\r\n\t\treturn sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n\/crr_d + price_coeff), totalSupply);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ Converts a number tokens into an Ether value.\r\r\n\r\r\n\tfunction getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {\r\r\n\r\r\n\t\t\/\/ How much reserve Ether do we have left in the contract?\r\r\n\r\r\n\t\tvar reserveAmount = reserve();\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ If you're the Highlander (or bagholder), you get The Prize. Everything left in the vault.\r\r\n\r\r\n\t\tif (tokens == totalSupply)\r\r\n\r\r\n\t\t\treturn reserveAmount;\r\r\n\r\r\n\r\r\n\r\r\n\t\t\/\/ If there would be excess Ether left after the transaction this is called within, return the Ether\r\r\n\r\r\n\t\t\/\/ corresponding to the equation in Dr Jochen Hoenicke's original Ponzi paper, which can be found\r\r\n\r\r\n\t\t\/\/ at https:\/\/test.jochen-hoenicke.de\/eth\/ponzitoken\/ in the third equation, with the CRR numerator \r\r\n\r\r\n\t\t\/\/ and denominator altered to 1 and 2 respectively.\r\r\n\r\r\n\t\treturn sub(reserveAmount, fixedExp((fixedLog(totalSupply - tokens) - price_coeff) * crr_d\/crr_n));\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ You don't care about these, but if you really do they're hex values for \r\r\n\r\r\n\t\/\/ co-efficients used to simulate approximations of the log and exp functions.\r\r\n\r\r\n\tint256  constant one        = 0x10000000000000000;\r\r\n\r\r\n\tuint256 constant sqrt2      = 0x16a09e667f3bcc908;\r\r\n\r\r\n\tuint256 constant sqrtdot5   = 0x0b504f333f9de6484;\r\r\n\r\r\n\tint256  constant ln2        = 0x0b17217f7d1cf79ac;\r\r\n\r\r\n\tint256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\r\r\n\r\r\n\tint256  constant c1         = 0x1ffffffffff9dac9b;\r\r\n\r\r\n\tint256  constant c3         = 0x0aaaaaaac16877908;\r\r\n\r\r\n\tint256  constant c5         = 0x0666664e5e9fa0c99;\r\r\n\r\r\n\tint256  constant c7         = 0x049254026a7630acf;\r\r\n\r\r\n\tint256  constant c9         = 0x038bd75ed37753d68;\r\r\n\r\r\n\tint256  constant c11        = 0x03284a0c14610924f;\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\r\n\r\r\n\t\/\/ approximates the function log(1+x)-log(1-x)\r\r\n\r\r\n\t\/\/ Hence R(s) = log((1+s)\/(1-s)) = log(a)\r\r\n\r\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\r\n\r\r\n\t\tint32 scale = 0;\r\r\n\r\r\n\t\twhile (a > sqrt2) {\r\r\n\r\r\n\t\t\ta \/= 2;\r\r\n\r\r\n\t\t\tscale++;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\twhile (a <= sqrtdot5) {\r\r\n\r\r\n\t\t\ta *= 2;\r\r\n\r\r\n\t\t\tscale--;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\tint256 s = (((int256)(a) - one) * one) \/ ((int256)(a) + one);\r\r\n\r\r\n\t\tvar z = (s*s) \/ one;\r\r\n\r\r\n\t\treturn scale * ln2 +\r\r\n\r\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11\/one))\r\r\n\r\r\n\t\t\t\t\/one))\/one))\/one))\/one))\/one);\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\r\n\r\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\r\n\r\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\r\n\r\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\r\n\r\r\n\t\/\/ approximates the function x*(exp(x)+1)\/(exp(x)-1)\r\r\n\r\r\n\t\/\/ Hence exp(x) = (R(x)+x)\/(R(x)-x)\r\r\n\r\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\r\n\r\r\n\t\tint256 scale = (a + (ln2_64dot5)) \/ ln2 - 64;\r\r\n\r\r\n\t\ta -= scale*ln2;\r\r\n\r\r\n\t\tint256 z = (a*a) \/ one;\r\r\n\r\r\n\t\tint256 R = ((int256)(2) * one) +\r\r\n\r\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8\/one))\/one))\/one))\/one);\r\r\n\r\r\n\t\texp = (uint256) (((R + a) * one) \/ (R - a));\r\r\n\r\r\n\t\tif (scale >= 0)\r\r\n\r\r\n\t\t\texp <<= scale;\r\r\n\r\r\n\t\telse\r\r\n\r\r\n\t\t\texp >>= -scale;\r\r\n\r\r\n\t\treturn exp;\r\r\n\r\r\n\t}\r\r\n\r\r\n\t\r\r\n\r\r\n\t\/\/ The below are safemath implementations of the four arithmetic operators\r\r\n\r\r\n\t\/\/ designed to explicitly prevent over- and under-flows of integer values.\r\r\n\r\r\n\r\r\n\r\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\tif (a == 0) {\r\r\n\r\r\n\t\t\treturn 0;\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t\tuint256 c = a * b;\r\r\n\r\r\n\t\tassert(c \/ a == b);\r\r\n\r\r\n\t\treturn c;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\t\/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\r\n\r\r\n\t\tuint256 c = a \/ b;\r\r\n\r\r\n\t\t\/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\r\n\r\r\n\t\treturn c;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\tassert(b <= a);\r\r\n\r\r\n\t\treturn a - b;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\r\n\r\r\n\t\tuint256 c = a + b;\r\r\n\r\r\n\t\tassert(c >= a);\r\r\n\r\r\n\t\treturn c;\r\r\n\r\r\n\t}\r\r\n\r\r\n\r\r\n\r\r\n\t\/\/ This allows you to buy tokens by sending Ether directly to the smart contract\r\r\n\r\r\n\t\/\/ without including any transaction data (useful for, say, mobile wallet apps).\r\r\n\r\r\n\tfunction () payable public {\r\r\n\r\r\n\t\t\/\/ msg.value is the amount of Ether sent by the transaction.\r\r\n\r\r\n\t\tif (msg.value > 0) {\r\r\n\r\r\n\t\t\tfund();\r\r\n\r\r\n\t\t} else {\r\r\n\r\r\n\t\t\twithdrawOld(msg.sender);\r\r\n\r\r\n\t\t}\r\r\n\r\r\n\t}\r\r\n\r\r\n}","label":1}
{"code":"pragma solidity 0.4.11;\r\r\n\r\r\ncontract ERC20 {\r\r\n    function totalSupply() constant returns (uint256 totalSupply) {}\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\r\n    function transfer(address _recipient, uint256 _value) returns (bool success) {}\r\r\n    function transferFrom(address _from, address _recipient, uint256 _value) returns (bool success) {}\r\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _recipient, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\ncontract StandardToken is ERC20 {\r\r\n\r\r\n\tuint256 public totalSupply;\r\r\n\tmapping (address => uint256) balances;\r\r\n    mapping (address => mapping (address => uint256)) allowed;\r\r\n    \r\r\n    modifier when_can_transfer(address _from, uint256 _value) {\r\r\n        if (balances[_from] >= _value) _;\r\r\n    }\r\r\n\r\r\n    modifier when_can_receive(address _recipient, uint256 _value) {\r\r\n        if (balances[_recipient] + _value > balances[_recipient]) _;\r\r\n    }\r\r\n\r\r\n    modifier when_is_allowed(address _from, address _delegate, uint256 _value) {\r\r\n        if (allowed[_from][_delegate] >= _value) _;\r\r\n    }\r\r\n\r\r\n    function transfer(address _recipient, uint256 _value)\r\r\n        when_can_transfer(msg.sender, _value)\r\r\n        when_can_receive(_recipient, _value)\r\r\n        returns (bool o_success)\r\r\n    {\r\r\n        balances[msg.sender] -= _value;\r\r\n        balances[_recipient] += _value;\r\r\n        Transfer(msg.sender, _recipient, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _recipient, uint256 _value)\r\r\n        when_can_transfer(_from, _value)\r\r\n        when_can_receive(_recipient, _value)\r\r\n        when_is_allowed(_from, msg.sender, _value)\r\r\n        returns (bool o_success)\r\r\n    {\r\r\n        allowed[_from][msg.sender] -= _value;\r\r\n        balances[_from] -= _value;\r\r\n        balances[_recipient] += _value;\r\r\n        Transfer(_from, _recipient, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint256 _value) returns (bool o_success) {\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 o_remaining) {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract GECToken is StandardToken {\r\r\n\r\r\n\t\/\/FIELDS\r\r\n\tstring public name = \"GECoin\";\r\r\n    string public symbol = \"GEC\";\r\r\n    uint public decimals = 3;\r\r\n\r\r\n\t\/\/INITIALIZATION\r\r\n\taddress public minter; \/\/address that able to mint new tokens\r\r\n\tuint public icoEndTime; \r\r\n\r\r\n\tuint illiquidBalance_amount;\r\r\n\tmapping (uint => address) illiquidBalance_index;\r\r\n\tmapping (address => uint) public illiquidBalance; \/\/Balance of &#39;Frozen funds&#39;\r\r\n\r\r\n\t\/\/ called by crowdsale contract\r\r\n\tmodifier only_minter {\r\r\n\t\tif (msg.sender != minter) throw;\r\r\n\t\t_;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Token can be transferred immediately after crowdsale.\r\r\n\tmodifier when_transferable {\r\r\n\t\tif (now <= icoEndTime) throw;\r\r\n\t\t_;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Can only be called if the `crowdfunder` is allowed to mint tokens. Any\r\r\n\t\/\/ time before `endMintingTime`.\r\r\n\tmodifier when_mintable {\r\r\n\t\tif (now > icoEndTime + 10 days) throw;\r\r\n\t\t_;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Initialization contract assigns address of crowdfund contract and end time.\r\r\n\tfunction GECToken (address _minter, uint _icoEndTime) {\r\r\n\t\tminter = _minter;\r\r\n\t\ticoEndTime = _icoEndTime;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Create new tokens when called by the crowdfund contract.\r\r\n\t\/\/ Only callable before the end time.\r\r\n\tfunction createToken(address _recipient, uint _value)\r\r\n\t\twhen_mintable\r\r\n\t\tonly_minter\r\r\n\t\treturns (bool o_success)\r\r\n\t{\r\r\n\t\tbalances[_recipient] += _value;\r\r\n\t\ttotalSupply += _value;\r\r\n\t\treturn true;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Create an illiquidBalance which cannot be traded until admin make it liquid.\r\r\n\t\/\/ Can only be called by crowdfund contract before the end time.\r\r\n\tfunction createIlliquidToken(address _recipient, uint _value)\r\r\n\t\twhen_mintable\r\r\n\t\tonly_minter\r\r\n\t\treturns (bool o_success)\r\r\n\t{\r\r\n\t\tilliquidBalance_index[illiquidBalance_amount] = _recipient;\r\r\n\t\tilliquidBalance[_recipient] += _value;\r\r\n\t\tilliquidBalance_amount++;\r\r\n\r\r\n\t\ttotalSupply += _value;\r\r\n\t\treturn true;\r\r\n\t}\r\r\n\r\r\n\t\/\/ Make sender&#39;s illiquid balance liquid when called after lockout period.\r\r\n\tfunction makeLiquid()\r\r\n\t\tonly_minter\r\r\n\t{\r\r\n\t\tfor (uint i=0; i<illiquidBalance_amount; i++) {\r\r\n\t\t\taddress investor = illiquidBalance_index[i];\r\r\n\t\t\tbalances[investor] += illiquidBalance[investor];\r\r\n\t\t\tilliquidBalance[investor] = 0;\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t\/\/ Transfer amount of tokens from sender account to recipient.\r\r\n\t\/\/ Only callable after the crowd fund end date.\r\r\n\tfunction transfer(address _recipient, uint _amount)\r\r\n\t\twhen_transferable\r\r\n\t\treturns (bool o_success)\r\r\n\t{\r\r\n\t\treturn super.transfer(_recipient, _amount);\r\r\n\t}\r\r\n\r\r\n\t\/\/ Transfer amount of tokens from a specified address to a recipient.\r\r\n\t\/\/ Only callable after the crowd fund end date.\r\r\n\tfunction transferFrom(address _from, address _recipient, uint _amount)\r\r\n\t\twhen_transferable\r\r\n\t\treturns (bool o_success)\r\r\n\t{\r\r\n\t\treturn super.transferFrom(_from, _recipient, _amount);\r\r\n\t}\r\r\n}","label":0}
{"code":"pragma solidity ^0.4.13;\r\r\ncontract SafeMath {\r\r\n\r\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\r\n        uint256 z = x + y;\r\r\n        assert((z >= x) && (z >= y));\r\r\n        return z;\r\r\n    }\r\r\n\r\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\r\n        assert(x >= y);\r\r\n        uint256 z = x - y;\r\r\n        return z;\r\r\n    }\r\r\n\r\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\r\n        uint256 z = x * y;\r\r\n        assert((x == 0)||(z\/x == y));\r\r\n        return z;\r\r\n    }\r\r\n}\r\r\n\r\r\ncontract Token {\r\r\n    uint256 public totalSupply;\r\r\n\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\r\n\r\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\r\n}\r\r\n\r\r\n\/*  ERC 20 token *\/\r\r\ncontract StandardToken is Token, SafeMath {\r\r\n\r\r\n    mapping (address => uint256) balances;\r\r\n    mapping (address => mapping (address => uint256)) allowed;\r\r\n\r\r\n    modifier onlyPayloadSize(uint numwords) {\r\r\n        assert(msg.data.length == numwords * 32 + 4);\r\r\n        _;\r\r\n    }\r\r\n\r\r\n    function transfer(address _to, uint256 _value)\r\r\n    returns (bool success)\r\r\n    {\r\r\n        if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) {\r\r\n            balances[msg.sender] = safeSubtract(balances[msg.sender], _value);\r\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\r\n            Transfer(msg.sender, _to, _value);\r\r\n            return true;\r\r\n        } else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\r\n    returns (bool success)\r\r\n    {\r\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) {\r\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\r\n            balances[_from] = safeSubtract(balances[_from], _value);\r\r\n            allowed[_from][msg.sender] = safeSubtract(allowed[_from][msg.sender], _value);\r\r\n            Transfer(_from, _to, _value);\r\r\n            return true;\r\r\n        } else {\r\r\n            return false;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\r\n        return balances[_owner];\r\r\n    }\r\r\n\r\r\n    function approve(address _spender, uint256 _value)\r\r\n    onlyPayloadSize(2)\r\r\n    returns (bool success)\r\r\n    {\r\r\n        allowed[msg.sender][_spender] = _value;\r\r\n        Approval(msg.sender, _spender, _value);\r\r\n        return true;\r\r\n    }\r\r\n\r\r\n    function allowance(address _owner, address _spender)\r\r\n    constant\r\r\n    onlyPayloadSize(2)\r\r\n    returns (uint256 remaining)\r\r\n    {\r\r\n        return allowed[_owner][_spender];\r\r\n    }\r\r\n}\r\r\n\/**\r\r\n * @title VIBECoin\r\r\n * @dev ERC20 Token, where all tokens are pre-assigned to the creator.\r\r\n * Note they can later distribute these tokens as they wish using `transfer` and other\r\r\n * `StandardToken` functions.\r\r\n *\/\r\r\ncontract HubiiNetworkTokens is StandardToken {\r\r\n\r\r\n\r\r\n  string public name = \"Hubii network tokens\";\r\r\n  string public symbol = \"HNBT\";\r\r\n  uint256 public decimals = 18;\r\r\n  uint256 public INITIAL_SUPPLY = 267000000 * 1 ether;\r\r\n\r\r\n  \/**\r\r\n   * @dev Contructor that gives msg.sender all of existing tokens.\r\r\n   *\/\r\r\n  function HubiiNetworkTokens() {\r\r\n    totalSupply = INITIAL_SUPPLY;\r\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\r\n  }\r\r\n\r\r\n}","label":0}
